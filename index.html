<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.16.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一个小学生的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Lightchaser">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Lightchaser">
<meta property="og:description" content="一个小学生的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Keke Liu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Lightchaser</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Lightchaser</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">三人行，必有我师</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Keke Liu</p>
  <div class="site-description" itemprop="description">一个小学生的博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/stemdkk" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;stemdkk" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:257198@whut.edu.cn" title="E-Mail → mailto:257198@whut.edu.cn" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/11/18-47-24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/11/18-47-24/" class="post-title-link" itemprop="url">8.1 QE基础教程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-11 18:47:24" itemprop="dateCreated datePublished" datetime="2024-10-11T18:47:24+08:00">2024-10-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-28 08:59:44" itemprop="dateModified" datetime="2024-10-28T08:59:44+08:00">2024-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="QE简介"><a href="#QE简介" class="headerlink" title="QE简介"></a>QE简介</h1><p>(1)EPW模块:计算载流子迁移率与超导转变温度。<br>(2)声子模块:计算电声耦合以及动力学矩阵。<br>(3)微动弹性带模块:计算化学反应过渡态与反应路径。<br>（4）开源软件，完全免费多种泛函可供选择，提供外部泛函库(libxc)赝势种类众多，根据需求生成</p>
<h1 id="输入文件"><a href="#输入文件" class="headerlink" title="输入文件"></a>输入文件</h1><p>pw.x处理的计算包括以下7种类型，在输入文件中用calculation设置：</p>
<p>‘scf’：自洽计算，self-consistent field，通过迭代的方式数值求解微分-积分方程（Kohn-Sham方程），迭代收敛以电荷的变化足够小为准，最终得到自洽电荷。</p>
<p>‘nscf’：非自洽计算，scf计算常在k空间的网格上进行，网格要足够密以完成k空间上的积分，在DOS等计算需要更密的k<br>点，这时在自洽电荷基础上，计算这些更多的k<br>点，nscf计算保持自洽电荷不变。</p>
<p>‘bands’：也是一种nscf计算，k<br>点按照三维k空间中的特殊路径选取。</p>
<p>‘relax’：一系列scf计算，通过Hellman-Feynman力计算离子坐标驰豫（通过优化算法找到受力为零的结构），relax计算时固定cell不变。</p>
<p>‘vc-relax’: 允许cell变化的relax，通过应力的计算改变cell。</p>
<p>‘md’：分子动力学，将电子对离子的作用看成离子感受到的势，根据势能和离子初始速度求解离子运动的经典力学方程。</p>
<p>‘vc-md’：允许cell改变的md。</p>
<p>pw.x的输入说明见INPUT_PW。注意默认的单位，其中原子单位制为（以下数值见源程序q-e-qe-6.3&#x2F;Modules&#x2F;constants.f90）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 bohr = 1 a.u. (atomic unit) = 0.52917720859 angstroms.</span><br><span class="line">1 Rydberg (Ry) = 13.60569193 eV</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/10/18-47-20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/10/18-47-20/" class="post-title-link" itemprop="url">7.2 磁性计算2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-10 18:47:20" itemprop="dateCreated datePublished" datetime="2024-05-10T18:47:20+08:00">2024-05-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-18 11:00:04" itemprop="dateModified" datetime="2024-10-18T11:00:04+08:00">2024-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Sym4state-Manual"><a href="#Sym4state-Manual" class="headerlink" title="Sym4state Manual"></a>Sym4state Manual</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CurrentModule = Sym4state.ModCore</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>pre_and_post</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">using PrintFileTree</span><br><span class="line">local pair_mat, coeff_array</span><br></pre></td></tr></table></figure>

<p>bilinear Heisenberg model can be described by</p>
<p>$\mathcal{H} &#x3D; \sum_{i &lt; j} S_i \cdot \mathcal{J}<em>{i j} \cdot S_j + \sum</em>{i} S_i \cdot \mathcal{A} \cdot S_i - m \sum_{i} S_i \cdot \vec{B}$</p>
<p>where the symbol $\mathcal{J}_{ij}$ denotes the exchange interaction matrix between two spins, $S_i$ and $S_j$, the matrix $\mathcal{A}$ represents the single-ion anisotropy. 四态法计算磁耦合，需要计算4种不同的磁基态，allowing the extraction of individual components for the exchange matrix.</p>
<p>想计算每一个元素的交换矩阵，就需要计算36个能量，由于一些结构的等价性，手动分析对称性筛选很有挑战，而且有遗漏的风险。</p>
<h2 id="Pre-process"><a href="#Pre-process" class="headerlink" title="Pre-process"></a>Pre-process</h2><p>One can use our program to streamline the simpilifing and calculating process easily. For example, with a POSCAR file of monolayer CrI3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Cr2 I6                                  </span><br><span class="line">   1.00000000000000     </span><br><span class="line">     7.1131374882967124    0.0000000000000000    0.0000000000000000</span><br><span class="line">    -3.5565687441483571    6.1601577654763897    0.0000000000000000</span><br><span class="line">     0.0000000000000000    0.0000000000000000   18.0635365764484419</span><br><span class="line">   Cr   I </span><br><span class="line">     2     6</span><br><span class="line">Direct</span><br><span class="line">  0.6666666666666643  0.3333333333333357  0.5000000247180765</span><br><span class="line">  0.3333333333333357  0.6666666666666643  0.5000000501683317</span><br><span class="line">  0.6415738047516142  0.9999977877949036  0.4116659127023310</span><br><span class="line">  0.3584239830432894  0.3584261952483858  0.4116659127023310</span><br><span class="line">  0.0000022122051035  0.6415760169567106  0.4116659127023310</span><br><span class="line">  0.3584241488090230  0.9999980859273947  0.5883340783387269</span><br><span class="line">  0.6415739371183646  0.6415758511909699  0.5883340783387269</span><br><span class="line">  0.0000019140726053  0.3584260628816354  0.5883340783387269</span><br></pre></td></tr></table></figure>

<p>合适设置 INCAR, POTCAR and KPOINTS 用于磁性自洽计算, 可以用 <code>Sym4state.jl</code> 产生所有的输入文件用于计算最近邻交换作用和单离子各向异性，过程如下：</p>
<figure class="highlight plaintext"><figcaption><span>pre_and_post</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">using Sym4state</span><br><span class="line">cd(&quot;CrI3&quot;) do   # hide</span><br><span class="line">Sym4state.pre_process(</span><br><span class="line">    &quot;./POSCAR&quot;,</span><br><span class="line">    [24],   # Take Cr element as magnetic</span><br><span class="line">    5.0     # There exists an interaction between atoms within a distance of 5 Å.</span><br><span class="line">)</span><br><span class="line">end # hide</span><br></pre></td></tr></table></figure>
<p>它将会构建超胞，满足两个任意原子无相互作用。给定的单层 ${CrI3}$ with a cutoff radius of 5 Å, a $2 \times 2 \times 1$ supercell will provide sufficient size. The supercell diagram below labels all the ${Cr}$ atoms:</p>


<p>Within the 5 Å cutoff radius, the monolayer of <code>\ce&#123;CrI3&#125;</code> exhibits two distinct groups of interactions. The first group corresponds to interactions between nearest neighbors, whereas the second group pertains to interactions arising from single-ion anisotropy. It is important to note that all atom pairs within the same group are considered equivalent. This equivalence implies the existence of symmetric operations that can transform one interaction matrix into another, highlighting the underlying symmetry of the system.</p>
<p> <code>pre_process</code> function的输出结果中，1组包含6对等价，第2组有2对等价。尽管简化了计算，还是要计算几种磁结构。 在考虑最近邻情况下，至少计算9个磁基态，相反在处理单离子各向异性需要2个。<br>不同参数和能量的关系储存在 <code>cal.jld2</code>. 另外该功能会生成几个目录储存对应输入文件。</p>
<figure class="highlight plaintext"><figcaption><span>pre_and_post</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printfiletree(&quot;CrI3&quot;)   # hide</span><br></pre></td></tr></table></figure>
<p>所有的目录储存在 <code>cal_list</code>, 后续提交任务即可。 <a target="_blank" rel="noopener" href="https://slurm.schedmd.com/">Slurm</a>‘s job array by submitting a shell like:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#SBATCH -n 144</span></span><br><span class="line"><span class="comment">#SBATCH --array=1-11%2</span></span><br><span class="line"></span><br><span class="line">module load vasp-6.3.2-optcell</span><br><span class="line"></span><br><span class="line">target_dir=$(sed -n <span class="string">&quot;<span class="variable">$&#123;SLURM_ARRAY_TASK_ID&#125;</span>p&quot;</span> cal_dir_list)</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;target_dir&#125;</span></span><br><span class="line"></span><br><span class="line">srun vasp_ncl</span><br></pre></td></tr></table></figure>

<p>这个 shell 脚本创建  Slurm job array 计算所有 11 magnetic configurations, while efficiently managing computational resources by allowing a maximum of 2 jobs to run simultaneously.</p>
<h2 id="Post-process"><a href="#Post-process" class="headerlink" title="Post-process"></a>Post-process</h2><p>计算完成后 <code>post_process</code> function 提取不同磁结构的能量，最终创建交换矩阵。</p>
<figure class="highlight plaintext"><figcaption><span>pre_and_post</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd(&quot;CrI3&quot;) do   # hide</span><br><span class="line">global pair_mat, coeff_array    # hide</span><br><span class="line">mv(&quot;../oszicar.tar.gz&quot;, &quot;./oszicar.tar.gz&quot;) # hide</span><br><span class="line">run(`tar -xvzf oszicar.tar.gz`) # hide</span><br><span class="line">for (idx, dir_name) in enumerate(readlines(&quot;cal_dir_list&quot;)) # hide</span><br><span class="line">    cp(&quot;oszicar/OSZICAR_$(idx)&quot;, dir_name * &quot;OSZICAR&quot;)  # hide</span><br><span class="line">end # hide</span><br><span class="line">pair_mat, coeff_array = Sym4state.post_process(&quot;./cal.jld2&quot;)</span><br><span class="line">end # hide</span><br></pre></td></tr></table></figure>
<p>我们可以测试 the dimensions of <code>pair_mat</code> and <code>coeff_array</code>, 它分别存储了不同原子对的起始点和结束点的索引及其对应的相互作用矩阵。</p>
<figure class="highlight plaintext"><figcaption><span>pre_and_post</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size(pair_mat)</span><br><span class="line">size(coeff_array)</span><br></pre></td></tr></table></figure>

<p>因此我们看到共有8个相互作用在cutoff radius of 5 Å. 让我们检查<code>pair_mat</code>中的一个特定条目，它包含表示原子对的索引：</p>
<figure class="highlight plaintext"><figcaption><span>pre_and_post</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair_mat[:, 1]</span><br></pre></td></tr></table></figure>

<p>初始数字和最终数字分别对应于起点原子和终点原子的指数。第二个和第三个数字表示原始单元格沿x轴和y轴的偏移量。</p>
<h2 id="Monte-Carlo-Simulation"><a href="#Monte-Carlo-Simulation" class="headerlink" title="Monte Carlo Simulation"></a>Monte Carlo Simulation</h2><p>前面 <code>pair_mat</code> and <code>coeff_array</code>的结果，可以通过 Monte Carlo simulation 计算 phase transition temperature or magnetic texture :</p>
<figure class="highlight plaintext"><figcaption><span>pre_and_post</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">using Unitful, UnitfulAtomic</span><br><span class="line">mcconfig = Sym4state.MC.MCConfig&#123;Float32&#125;(</span><br><span class="line">    lattice_size=[128, 128],</span><br><span class="line">    magmom_vector=[3.5, 3.5],</span><br><span class="line">    pair_mat=pair_mat,</span><br><span class="line">    interact_coeff_array=coeff_array,</span><br><span class="line">    temperature=collect(150:-2:0),</span><br><span class="line">    magnetic_field=zeros(3),</span><br><span class="line">    equilibration_step_num=100_000,</span><br><span class="line">    measuring_step_num=100_000</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>In the aforementioned code snippet, we have configured a simulated annealing simulation, commencing at a temperature of 150 K and progressively reducing it to 0 K in steps of 2 K. The simulation operates on a $128 \times 128$ supercell of ${CrI3}$ using the previously computed interaction matrix. To assess the system, we perform a preliminary equilibration phase consisting of <code>100000</code> sweeps, followed by a measurement phase comprising <code>100000</code> sweeps for acquiring physical quantities. It is worth noting that the magnetic field is absent, rendering the <code>magmom_vector</code> inconsequential.</p>
<p>With the created <code>mcconfig</code>, one can initiate a Monte Carlo simulation as follows:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">    states_over_env,</span><br><span class="line">    norm_mean_mag_over_env,</span><br><span class="line">    susceptibility_over_env,</span><br><span class="line">    specific_heat_over_env</span><br><span class="line">) = Sym4state.MC.mcmc(</span><br><span class="line">    mcconfig,</span><br><span class="line">    backend=Sym4state.MC.CPU()</span><br><span class="line">    progress_enabled=<span class="literal">false</span>,</span><br><span class="line">    log_enabled=<span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>The parameter <code>backend</code> can be configured to employ <code>CUDABackend()</code> provided by <a target="_blank" rel="noopener" href="https://github.com/JuliaGPU/CUDA.jl"><code>CUDA.jl</code></a> or any other backends supported by <a target="_blank" rel="noopener" href="https://github.com/JuliaGPU/KernelAbstractions.jl"><code>KernelAbstractions.jl</code></a> to enhance performance utilizing the GPU.</p>
<p>The <code>MCConfig</code> can also be stored into a <code>.toml</code> file by:</p>
<figure class="highlight plaintext"><figcaption><span>pre_and_post</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd(&quot;CrI3&quot;) do   # hide</span><br><span class="line">Sym4state.MC.save_config(&quot;CrI3.toml&quot;, mcconfig)</span><br><span class="line">end # hide</span><br></pre></td></tr></table></figure>

<p>or it can also be restored by:</p>
<figure class="highlight plaintext"><figcaption><span>pre_and_post</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd(&quot;CrI3&quot;) do   # hide</span><br><span class="line">mcconfig = Sym4state.MC.load_config(&quot;CrI3.toml&quot;)</span><br><span class="line">end # hide</span><br></pre></td></tr></table></figure>

<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reduce_interact_mat_for_a_pair</span><br><span class="line">supercell_check</span><br><span class="line">pre_process</span><br><span class="line">post_process</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm(&quot;CrI3&quot;, recursive=true)</span><br><span class="line">nothing</span><br></pre></td></tr></table></figure>


<h1 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h1><p>以下是您提供的内容的中文翻译，并以 Markdown 格式呈现：</p>
<h1 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h1><h2 id="当前模块"><a href="#当前模块" class="headerlink" title="当前模块"></a>当前模块</h2><p><code>Sym4state.ModCore</code> 使用 <code>PrintFileTree</code> 本地 <code>pair_mat</code>、<code>coeff_array</code></p>
<p>对于磁体的磁性特性的理论探索，双线性海森堡模型被证明是表示磁相互作用的有用框架，可以用以下公式描述：<br>$$<br>\mathcal{H} &#x3D; -\sum_{i,j} \mathcal{J}_{ij} \mathbf{S}_i \cdot \mathbf{S}<em>j + \sum</em>{i} \mathcal{A} \mathbf{S}_i^2<br>$$<br>其中符号 <code>\mathcal&#123;J&#125;_&#123;ij&#125;</code> 表示两个自旋 <code>S_i</code> 和 <code>S_j</code> 之间的交换相互作用矩阵，矩阵 <code>\mathcal&#123;A&#125;</code> 表示单离子各向异性。为了确定磁相互作用矩阵元素，研究人员通常采用四态方法 <a href="#user-content-fn-1-8f7d6183a295783803aaf3f6284a47b5">1</a> <a href="#user-content-fn-2-8f7d6183a295783803aaf3f6284a47b5">2</a> <a href="#user-content-fn-3-8f7d6183a295783803aaf3f6284a47b5">3</a>。该方法涉及计算四种不同的磁配置的能量，从而提取交换矩阵的各个分量。将此方法扩展到交换矩阵的每个元素需要计算总共 36 种能量，以获得完整的矩阵。需要注意的是，由于材料的对称性，一些能量是简并的。尽管如此，进行手动对称分析以简化能量计算的数量仍然是一项具有挑战性的工作，因为存在遗漏或误解某些对称操作的潜在风险。</p>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>可以使用我们的程序轻松简化和计算过程。例如，使用 <code>\ce&#123;CrI3&#125;</code> 的 POSCAR 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Cr2 I6</span><br><span class="line">1.00000000000000</span><br><span class="line">7.11313748829671    0.00000000000000    0.00000000000000</span><br><span class="line">-3.55656874414836    6.16015776547639    0.00000000000000</span><br><span class="line">0.00000000000000    0.00000000000000   18.06353657644844</span><br><span class="line">Cr   I2     6</span><br><span class="line">Direct</span><br><span class="line">0.66666666666666  0.33333333333333  0.50000002471808</span><br><span class="line">0.33333333333333  0.66666666666666  0.50000005016833</span><br><span class="line">0.64157380475161  0.99999778779490  0.41166591270233</span><br><span class="line">0.35842398304329  0.35842619524839  0.41166591270233</span><br><span class="line">0.00000221220510  0.64157601695671  0.41166591270233</span><br><span class="line">0.35842414880902  0.99999808592739  0.58833407833873</span><br><span class="line">0.64157393711836  0.64157585119097  0.58833407833873</span><br><span class="line">0.00000191407261  0.35842606288164  0.58833407833873</span><br></pre></td></tr></table></figure>

<p>以及适当设置的 INCAR、POTCAR 和 KPOINTS 文件以进行 SCF 计算，可以简单地使用 <code>Sym4state.jl</code> 生成所有输入文件以计算最近的交换相互作用和单离子各向异性相互作用，如下所示：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Sym4state</span><br><span class="line">cd(<span class="string">&quot;CrI3&quot;</span>) <span class="keyword">do</span></span><br><span class="line">    Sym4state.pre_process(<span class="string">&quot;./POSCAR&quot;</span>, [<span class="number">24</span>],   <span class="comment"># 以 Cr 元素作为磁性</span></span><br><span class="line">    <span class="number">5.0</span>     <span class="comment"># 存在一个距离为 5 Å 的原子间相互作用</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>此函数将利用 <a target="_blank" rel="noopener" href="https://github.com/A-LOST-WAPITI/Sym4state.jl/blob/main/docs/src/@ref"><code>supercell_check</code></a> 方法为提供的结构创建超晶胞。超晶胞应足够大，以确保在指定的截止半径内，任何两个原子之间不超过一个连接。对于给定的 <code>\ce&#123;CrI3&#125;</code> 单层，截止半径为 5 Å，<code>2 \times 2 \times 1</code> 的超晶胞将提供足够的大小。下图标记了所有的 <code>\ce&#123;Cr&#125;</code> 原子：</p>
<p><img src="https://github.com/A-LOST-WAPITI/Sym4state.jl/raw/main/docs/src/figs/CONTCAR.webp" alt="单层 \ce{CrI3} 的俯视图"></p>
<p>在 5 Å 的截止半径内，单层 <code>\ce&#123;CrI3&#125;</code> 显示出两组不同的相互作用。第一组对应于最近邻之间的相互作用，而第二组则涉及单离子各向异性引起的相互作用。需要注意的是，同一组内的所有原子对被视为等效。这种等效性意味着存在对称操作，可以将一个相互作用矩阵转换为另一个，突显了系统的潜在对称性。</p>
<p>根据 <code>pre_process</code> 函数获得的输出，初始组包含 6 对等效的原子对，而第二组则包含 2 对等效的原子对。尽管通过使用对称操作简化涉及各种相互作用矩阵的计算的潜力存在，但仍然有一个特定的相互作用矩阵需要计算最少数量的配置。在最近邻相互作用的情况下，必须计算至少 9 种磁配置的能量。相反，在处理单离子各向异性相互作用时，需要评估至少 2 种磁配置的能量。</p>
<p>该函数将恢复不同能量和配置之间的所有关系到文件 <code>cal.jld2</code> 中。此外，该函数将生成多个目录以存储与各种磁配置相对应的输入文件。</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printfiletree(<span class="string">&quot;CrI3&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>所有这些目录的路径存储在文件 <code>cal_list</code> 中，可以使用该文件通过提交如下的 shell 创建 Slurm 的作业数组：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#SBATCH -n 144</span></span><br><span class="line"><span class="comment">#SBATCH --array=1-11%2</span></span><br><span class="line">module load vasp-6.3.2-opt</span><br><span class="line">celltarget_dir=$(sed -n <span class="string">&quot;<span class="variable">$&#123;SLURM_ARRAY_TASK_ID&#125;</span>p&quot;</span> cal_dir_list)</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;target_dir&#125;</span></span><br><span class="line">srun vasp_ncl</span><br></pre></td></tr></table></figure>

<p>该 shell 脚本旨在创建一个 Slurm 作业数组，以计算所有 11 种磁配置的能量，同时通过允许最多 2 个作业同时运行来有效管理计算资源。</p>
<h2 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h2><p>一旦所有计算都已收敛，可以利用 <code>post_process</code> 函数提取与不同配置相关的能量。此过程最终导致构建相互作用矩阵。</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd(<span class="string">&quot;CrI3&quot;</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">global</span> pair_mat, coeff_array</span><br><span class="line">    mv(<span class="string">&quot;../oszicar.tar.gz&quot;</span>, <span class="string">&quot;./oszicar.tar.gz&quot;</span>) <span class="comment"># 隐藏</span></span><br><span class="line">    run(<span class="string">`tar -xvzf oszicar.tar.gz`</span>) <span class="comment"># 隐藏</span></span><br><span class="line">    <span class="keyword">for</span> (idx, dir_name) <span class="keyword">in</span> enumerate(readlines(<span class="string">&quot;cal_dir_list&quot;</span>)) <span class="comment"># 隐藏</span></span><br><span class="line">        cp(<span class="string">&quot;oszicar/OSZICAR_<span class="subst">$(idx)</span>&quot;</span>, dir_name * <span class="string">&quot;OSZICAR&quot;</span>)  <span class="comment"># 隐藏</span></span><br><span class="line">    <span class="keyword">end</span> <span class="comment"># 隐藏</span></span><br><span class="line">    pair_mat, coeff_array = Sym4state.post_process(<span class="string">&quot;./cal.jld2&quot;</span>)</span><br><span class="line"><span class="keyword">end</span> <span class="comment"># 隐藏</span></span><br></pre></td></tr></table></figure>

<p>我们可以检查 <code>pair_mat</code> 和 <code>coeff_array</code> 的维度，这些存储了各种原子对的起始和结束点的索引及其对应的相互作用矩阵。</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size(pair_mat)</span><br><span class="line">size(coeff_array)</span><br></pre></td></tr></table></figure>

<p>因此，我们观察到在 5 Å 的截止半径内存在总共 8 种相互作用。让我们检查 <code>pair_mat</code> 中的一个特定条目，该条目包含表示原子对的索引：</p>
<p>初始和最终数字对应于起始和结束点原子的索引，第二和第三个数字表示沿 x 轴和 y 轴的原始单元的偏移量。</p>
<h2 id="蒙特卡罗模拟"><a href="#蒙特卡罗模拟" class="headerlink" title="蒙特卡罗模拟"></a>蒙特卡罗模拟</h2><p>利用前面的结果 <code>pair_mat</code> 和 <code>coeff_array</code>，我们可以设置一个蒙特卡罗模拟的配置，以确定相变温度或磁纹理，如下所示：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Unitful, UnitfulAtomic</span><br><span class="line"></span><br><span class="line">mcconfig = Sym4state.MC.MCConfig&#123;<span class="built_in">Float32</span>&#125;(</span><br><span class="line">    lattice_size=[<span class="number">128</span>, <span class="number">128</span>],</span><br><span class="line">    magmom_vector=[<span class="number">3.5</span>, <span class="number">3.5</span>],</span><br><span class="line">    pair_mat=pair_mat,</span><br><span class="line">    interact_coeff_array=coeff_array,</span><br><span class="line">    temperature=collect(<span class="number">150</span>:-<span class="number">2</span>:<span class="number">0</span>),</span><br><span class="line">    magnetic_field=zeros(<span class="number">3</span>),</span><br><span class="line">    equilibration_step_num=<span class="number">100_000</span>,</span><br><span class="line">    measuring_step_num=<span class="number">100_000</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在上述代码片段中，我们配置了一个模拟退火模拟，从 150 K 开始，逐渐降低到 0 K，步长为 2 K。模拟在 <code>\ce&#123;CrI3&#125;</code> 的 <code>128 \times 128</code> 超晶胞上运行，使用先前计算的相互作用矩阵。为了评估系统，我们进行初步的平衡阶段，包含 <code>100000</code> 次扫掠，随后是包含 <code>100000</code> 次扫掠的测量阶段，以获取物理量。值得注意的是，磁场缺失，因此 <code>magmom_vector</code> 并不重要。</p>
<p>使用创建的 <code>mcconfig</code>，可以如下启动蒙特卡罗模拟：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(states_over_env, norm_mean_mag_over_env, susceptibility_over_env, specific_heat_over_env) = </span><br><span class="line">    Sym4state.MC.mcmc(mcconfig, backend=Sym4state.MC.CPU(), progress_enabled=<span class="literal">false</span>, log_enabled=<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>参数 <code>backend</code> 可以配置为使用 <a target="_blank" rel="noopener" href="https://github.com/JuliaGPU/CUDA.jl"><code>CUDABackend()</code></a> 提供的 GPU 加速，或任何其他由 <a target="_blank" rel="noopener" href="https://github.com/JuliaGPU/KernelAbstractions.jl"><code>KernelAbstractions.jl</code></a> 支持的后端，以提高性能。</p>
<p><code>MCConfig</code> 还可以存储到 <code>.toml</code> 文件中：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd(<span class="string">&quot;CrI3&quot;</span>) <span class="keyword">do</span></span><br><span class="line">    Sym4state.MC.save_config(<span class="string">&quot;CrI3.toml&quot;</span>, mcconfig)</span><br><span class="line"><span class="keyword">end</span> <span class="comment"># 隐藏</span></span><br></pre></td></tr></table></figure>

<p>或者也可以通过以下方式恢复：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd(<span class="string">&quot;CrI3&quot;</span>) <span class="keyword">do</span></span><br><span class="line">    mcconfig = Sym4state.MC.load_config(<span class="string">&quot;CrI3.toml&quot;</span>)</span><br><span class="line"><span class="keyword">end</span> <span class="comment"># 隐藏</span></span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><code>reduce_interact_mat_for_a_pair</code></li>
<li><code>supercell_check</code></li>
<li><code>pre_process</code></li>
<li><code>post_process</code></li>
<li><code>rm(&quot;CrI3&quot;, recursive=true)</code></li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>Xiang, H. J., et al. “Predicting the spin-lattice order of frustrated systems from first principles.” Physical Review B 84.22 (2011): 224429. <a href="#user-content-fnref-1-8f7d6183a295783803aaf3f6284a47b5">↩</a></li>
<li>Šabani, D., C. Bacaksiz, and M. V. Milošević. “Ab initio methodology for magnetic exchange parameters: Generic four-state energy mapping onto a Heisenberg spin Hamiltonian.” Physical Review B 102.1 (2020): 014457. <a href="#user-content-fnref-2-8f7d6183a295783803aaf3f6284a47b5">↩</a></li>
<li>Xiang, Hongjun, et al. “Magnetic properties and energy-mapping analysis.” Dalton Transactions 42.4 (2013): 823-853. <a href="#user-content-fnref-3-8f7d6183a295783803aaf3f6284a47b5">↩</a></li>
</ol>
<h2 id="SAXIS"><a href="#SAXIS" class="headerlink" title="SAXIS"></a>SAXIS</h2><p><strong>默认值</strong>: <code>SAXIS = (0, 0, 1)</code></p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>设置全局自旋量子化轴相对于笛卡尔坐标系的方向。</p>
<p>SAXIS 指定由泡利矩阵生成的自旋子空间的相对方向。默认情况下，<code>SAXIS</code> 为 <code>(0, 0, 1)</code>，即自旋量子化轴沿 z 轴方向。</p>
<h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>在包含自旋轨道耦合时（<code>LSORB</code> &#x3D; True），自旋量子化轴的相对方向与真实空间的关系变得重要。所有由 VASP 写入或读取的磁矩和类自旋量子数都以自旋子空间的基底表示。</p>
<h3 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h3><p><img src="https://www.vasp.at/wiki/images/thumb/5/56/Saxis-angles.png/300px-Saxis-angles.png" alt="坐标系统"></p>
<p>图 1. 欧拉角 $\alpha$ 和 $\beta$ 的定义。</p>
<p>默认方向为 $\sigma_1&#x3D;\hat x$，$\sigma_2&#x3D;\hat y$，$\sigma_3 &#x3D; \hat z</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/09/18-47-20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/09/18-47-20/" class="post-title-link" itemprop="url">7.1 磁性计算1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-09 18:47:20" itemprop="dateCreated datePublished" datetime="2024-05-09T18:47:20+08:00">2024-05-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-18 16:26:53" itemprop="dateModified" datetime="2024-11-18T16:26:53+08:00">2024-11-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="vasp磁性参数"><a href="#vasp磁性参数" class="headerlink" title="vasp磁性参数"></a>vasp磁性参数</h1><p>设置ISPIN和MAGMOM参数，详见vasp官网。关闭对称性：ISYM&#x3D;0.一般有的采用先做非磁结构优化，再打开自旋和磁性设置做磁基态计算。确定磁性体系可以直接做磁性计算。磁性计算一般属于过渡金属，要进行DFT+U计算。对于考虑LDAU的情况一般推荐增加参数 LMAXMIX。</p>
<p>INCAR中的参数设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LORBIT = 11</span><br><span class="line">LDAU = .TRUE. 打开LDAU</span><br><span class="line">LDAUTYPE =2 LDAU类型LDAUTYPE=2： 只考虑U-J的值；LDAUTYPE=1： 同时考虑U和J，J基本为常数1 eV</span><br><span class="line">LDAUL = 2 -1 库伦排斥的轨道</span><br><span class="line">LDAUU = 2.8 0 库伦排斥的大小</span><br><span class="line">LDAUJ = 0 0 stoner 交换参数大小</span><br><span class="line">LMAXMIX = 4 mix轨道</span><br></pre></td></tr></table></figure>
<p>如果进行非线性计算，LNONCOLLINEAR &#x3D; .TRUE. MAGMOM &#x3D; x y z . . . … 可以读前一步的CHGCAR，进行非线性自洽计算（不用结构优化），也可以直接进行非线性计算。为了避免以上报错，增<br>加mix参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LMAXMIX = 4</span><br><span class="line">AMIX = 0.2</span><br><span class="line">BMIX = 0.00001</span><br><span class="line">AMIX_MAG = 0.8</span><br><span class="line">BMIX_MAG = 0.00001</span><br></pre></td></tr></table></figure>
<p>提交任务要使用vasp_ncl版本的程序</p>
<p>自旋轨道耦合<br>默认 SAXIS &#x3D; 0 0 1<br>加入磁矩参数<br>MAGMOM &#x3D; x y z … … </p>
<p>一般接口wannier90还需要<br>ISYM&#x3D;-1<br>NPAR &#x3D;1 或者将这个开关删除<br>##</p>
<p>铁磁半导体相对好收敛，遇到不收敛问题，可尝试降低 AMIX，增加 BMIX<br>尝试更换不同的ISMEAR，比如加电场时，会遇到矩阵不厄密。<br>call to ZHEGV failed 问题可能是</p>
<ol>
<li>结构不合理</li>
<li>优化时优化到一个不合理的结构： 尝试改变弛豫算法IBRION ，减小步长POTIM &#x3D; 0.1或者更小</li>
<li>对角化算法不稳定 ： ALGO &#x3D; Normal&#x2F;Fast</li>
<li>尝试关掉对称性</li>
</ol>
<h1 id="磁基态"><a href="#磁基态" class="headerlink" title="磁基态"></a>磁基态</h1><p>得出体系的具体磁基态：比较三个计算无磁，铁磁，反铁磁的能量，能量更低的为体系的磁基态。构建不同磁基态有可能需要扩胞。</p>
<p>得出体系原子的具体磁矩：用vi编辑器打开OUTCAR或其他方式打开，从最后往前翻动，第一个magnetization (x)开头的表格就是原子的磁矩大小。需要打开LORBIT&#x3D;11</p>
<p>磁矩分布画图：使用chgsplit.sh（可以向组内师兄师姐寻找）。磁性测试输出CHGCAR后，运行命令.&#x2F;chgsplit.sh CHGCAR得到cf1和cf2文件，把cf2文件重命名为CHGCAR-mag，与CONTCAR一起拖入VESTA中画图即可。</p>
<h1 id="磁耦合"><a href="#磁耦合" class="headerlink" title="磁耦合"></a>磁耦合</h1><p>对于磁性体系的第一性原理计算结果，能量部分可以分<br>为两个部分E &#x3D; E_0 （非磁项） + E_s （磁性相关能量）<br>对比磁性耦合产生的能量，不能够用磁性态的能量跟非<br>磁的去对比<br>E_s 包含交换耦合以及单离子各向异性能（SOC）<br>一般来说，磁性相关的能量可以用下面的公式来表示</p>
<ol>
<li>磁性态的构造<br>为了求磁耦合强度，我们需要构造出不同磁构型哈密顿，通过求解这些哈密顿方程<br>组来得到磁耦合参数。例如对于一个体系，我们需要求解最近邻J1和次<br>近邻J2，那么体系能量中有三个未知量H0, J1, J2。这样我们需要构造三个线性独立的方程来求解。<br>磁耦合参数</li>
</ol>
<p>四态法</p>
<p>接下来，我们以一个例子来看四态法<br>是如何用来求磁耦合的。</p>
<ol>
<li>构建超胞<br>这里我们以二维六角晶格为例，原胞<br>中有两个磁性原子，我们构建一个<br>8<em>8</em>1的超胞，目标是求下图中A、B<br>之间的磁耦合作用。<br>构建四个磁性态 ，分别<br>为<br>其中第一项是DFT中的非磁项，联立这四个方程组就<br>可以求解<br>注意这里的超胞大小，只要满足这个8*8的超胞里的A、<br>B与周期外的A、B格点之间没有作用或者作用可忽略就<br>可以。</li>
</ol>
<p>单离子各向异性，对于沿Z轴具有三重四重六重旋转对称性的体系，只需要计算一个Azz  − Axx 。</p>
<h1 id="居里温度"><a href="#居里温度" class="headerlink" title="居里温度"></a>居里温度</h1><p>对于铁磁有序材料，当温度达到某一临界值之后，在没有外磁场的情况下，材料会变成<br>顺磁态，这个温度点便是居里温度（Curie temperature: Tc）<br>铁磁是一种铁性材料，所谓铁磁是指在外场作用下，极化随着外场的翻转会有一个滞后，<br>自旋极化随着外场的变化曲线形成磁滞回线。对于反铁磁有序材料，当温度达到某一临界值之后，在没有外磁场的情况下，材料同样会变成<br>顺磁态，这个温度点便是奈尔温度（Neel temperature: TN）</p>
<p>对于反铁磁有序材料，一般可以使用测试磁化率来判断其相变温度，磁化率满足居里外斯定律</p>
<ol>
<li>平均场近似</li>
<li>自旋波方法详细推导见文件夹mean-field-theory</li>
<li>Monte Carlo方法</li>
</ol>
<p>居里温度的Monte Carlo 模拟</p>
<ol>
<li>撒点，给初始磁矩</li>
<li>计算哈密顿<br>3 尝试随机反转一个格点的磁矩，计算能量<br>4判断，如果能量变低，则翻转，如果能量变高，那么<br>如果 则翻转，否则不翻转<br>5 先进行充足的MC步骤至平衡，然后在进行充足的步骤采样，取平均磁矩。<br>每一个温度点做一次1-5步骤，即每一个温度点有一个平均磁矩，磁矩下降最快的点（斜率绝对值最大）即为<br>居里温度。<br>反铁磁需要计算奈尔温度，那么平均磁矩会一直是0，有两种办法，算其中一个格点的平均磁矩，或者看磁比<br>热</li>
</ol>
<h2 id="mcsolver计算XY模型的一个例子。"><a href="#mcsolver计算XY模型的一个例子。" class="headerlink" title="mcsolver计算XY模型的一个例子。"></a>mcsolver计算XY模型的一个例子。</h2><p>在学习的过程中，我发现参数设置非常重要，也比较难，但网上并没有给出一个详细的教程说明，结合网上已有说明和朋友讨论，以下给出我的一点见解，希望大家相互讨论学习，有错误欢迎批评指正。</p>
<p>1.lattice晶格常数</p>
<p>关于晶格常数的设置，这步比较简单。</p>
<p>晶格常数需要采用归一化后的晶格常数，a1、a2、a3分别归一化，例如a1&#x3D;（3，4，0）归一化后就是（0.6，0.8，0）。</p>
<p>sc（supercell）表示使用的超胞规模，一般情况下尽可能的大，例如16<em>16</em>1或32<em>32</em>1（在二维情况下）。</p>
<p>2.Orbital list</p>
<p>这一步是对原胞中不等价磁性原子的设置。</p>
<p>ID是对设置的原子的编号，在可视化界面中，这一项不用手动设置，程序会自动根据我们的设置进行从0开始的编号。</p>
<p>type表示原胞中磁性原子的种类，根据具体情况进行设置，如果只有一种磁性原子，都设置成0就可以。</p>
<p>init spin表示自旋磁矩的设置，比如你用VASP计算出来得到的磁矩是3，那么这一项需要设置为1.5（需要除以一个2，换算成玻尔磁子）。</p>
<p>pos对磁性原子的位置坐标进行设置，这里最好是采用分数坐标（如果是笛卡尔坐标建议转换成分数坐标进行计算）。（更正：应该是相对于a1、a2、a3的分数坐标，也就是相对于斜的平行四边形的而言的，以其两条邻边为晶格矢量，例如CrI3是0.333   0.666667    0，如果是直角坐标系下的分数坐标的话第一个值应该是负的才对）</p>
<p>Ani表示单离子在xyz方向上的各向异性系数或单离子磁晶各向异性能(在Ising模型中是无用的，在XY模型中只使用前两个）。对自己的结构做一个易磁化轴位置的判断。一般为Z方向就在DZ处添加。同时，注意各向异性的单位是开尔文。 （1meV&#x3D;11.604609K）</p>
<p>至此，我们已经完成了第二步Orbital list的设置。</p>
<p>3.Bond list</p>
<p>设置第二步里面的磁性原子之间的交换耦合系数，在你的计算中，一共考虑到了多少个相互作用就要添加多少个。比如，对于CrI3来说，考虑到了最近邻、次近邻和第三近邻相互作用，分别有3个、6个和3个，那么你一共就需要添加12条信息。</p>
<p>对于每一项来说，设置方法如下：</p>
<p>ID是相互作用的编号，如同第二步一样，系统会从0开始自动编号。</p>
<p>J是磁性原子之间的交换耦合系数，一个J有九个矩阵元素，分别包括Jxx、Jyy、Jzz、Jxy、Jxz、Jyz、Jyx、Jzx、Jzy。每个元素描述了自旋的两个分量之间的耦合。对于Ising模型，由于只考虑一维自选变数，即只存在自旋向上或自旋向下，因此只使用第一个元素Jxx。对于XY模型也一样，自旋的朝向由up和down解放到了XY平面的任意朝向，因此只使用Jxx、Jyy、Jxy、Jyz。而对于heisenberg模型来说，三个自旋方向都存在相互作用，因此Jxx、Jyy、Jzz、Jxy、Jxz、Jyz、Jyx、Jzx、Jzy九个矩阵元素都需要设置。（对于模型的设置在后面的Model处进行选择。）对于前Ising和XY模型来说，即便你设置了九个矩阵元素，有效输入的也只是对应的起作用的元素，因此选好模型很关键。</p>
<p>s，t和over lat.表示我们考虑哪两个磁性原子之间的相互作用，s和t要选择我们在第二步中设置的原胞中磁性原子的ID，over lat.的三个元素指代一个晶格矢量，这个晶格矢量表示：在晶格中，你考虑的原子（在该中心原胞平移该晶格矢量后的原胞的t原子），和中心s原子之间的相互作用。（这里比较难，为了便于理解，建议读者找个例子琢磨琢磨或者自己多动手尝试一下）</p>
<p>注意所有的能量单位都是开尔文（1meV&#x3D;11.604609K）</p>
<p>至此，我们已经完成了第三步Bond list的设置。</p>
<p>现在，我们可以在Structure viewer里面看到超胞里磁性原子的分布和相互作用示意图。大家可以根据右上角的图查看自己添加的是否正确。一定要多加尝试。</p>
<p>4.Other settings其他设置</p>
<p>关于一些其他参数的设置。</p>
<p>T start&amp;end表示起始和结束温度，也就是温度的取值范围，total points表示温度插值次数（用于温度扫描），也就是总取点数，一般来说点越多图形越精确。示例给出的0.9,1.2和8只是为了快速计算得到结果，真实输入的时候要视实际情况而定。</p>
<p>同理，H start&amp;end表示外加磁场的取值范围，total points表示采样次数（用于磁场扫描）。</p>
<p>nthermal是使系统进入平衡状态的总步骤，nsweep是测量所涉及的总步骤，tau表示每一步的MC更新。</p>
<p>xAxis表示右边Result viewer的x轴上的物理量，可以是T(表示M-T曲线)或H(表示迟滞回线)。</p>
<p>Model可以选择Ising模型、XY模型或Heisenberg模型。</p>
<p>Algorithm选择相应的算法（支持Wolff，Metropolis，Swedsen-Wang）。</p>
<p>Measure corr. si&amp;sj设置spin＿i和spin＿j以及它们之间的晶格矢量，用于相关拼接。（如果spin＿i&#x3D;spin＿j并且overLat&#x3D;0 0 0，那么你将得到spin＿i的磁化率）。</p>
<p>nFrame是输出自旋构型的数目，用于说明在平衡或非平衡状态下的自旋构型。</p>
<p>core设置并行计算的核心资源。</p>
<p>至此，所有参数都设置完毕。</p>
<p>5.最后</p>
<p>save可以选择保存当前参数到文件，以便下一次找到。</p>
<p>单击StartMC启动计算。</p>
<p>等待右面板中的关系图更新。之后，你可以在mcsolver的根目录下找到一个result.txt文件，其中有许多有用的信息，包括平均自旋(在步骤5中定义的spin＿i和j上)，spin＿i和j之间的相关性，内能，比热容量和Binder累积量U4等。如果你处理有多个核心的模拟，那么结果可能不会根据温度排序，但是，每一行的对应关系都是可以的。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46679797/article/details/134455309">https://blog.csdn.net/qq_46679797/article/details/134455309</a></p>
<h1 id="MAE"><a href="#MAE" class="headerlink" title="MAE"></a>MAE</h1><p>磁晶各向异性 magnetic anisotropic energy (MAE) 是指自旋方向在不同方向上的能量差。MAE跟体系对称性有关。<br>对于简单体二维系，易磁化轴可能在面内或者垂直于面，我们可以选择计算不同方向的某一磁性态能量对比来求MAE<br>比如CrI3， 我们可以计算沿着x方向的FM能量Ex，然后计算沿着z方向的FM能量Ez。<br>MAE &#x3D; (Ex -Ez)&#x2F;2<br>对于对称性较低的体系，需要每个面去计算MAE。在vasp中，三维体系研究MAE，可以在高对称轴上算能量差</p>
<p>三步：结构优化，共线计算磁性并输出CHGCAR,读取CHGCAR改为非线性计算不同方向的能量。</p>
<p>晶体磁各向异性能量由按不同方向旋转所有自旋决定。首先，必须在基态下进行精确（PREC&#x3D;精确，LREAL&#x3D;.False.）共线计算（使用vasp_std版本）。接下来，考虑自旋轨道耦合（LSORBIT&#x3D;.True.，使用vasp_ncl版本）对几种自旋取向进行非自洽计算（ICHARG&#x3D;11）。在大多数情况下，能量变化非常小（有时约为微电子伏）。与共线相比，必须将NBANDS加倍。</p>
<p>为了修改晶体中自旋的取向，我们考虑这里描述的第二种方法。对于MAGMOM标签，根据z方向编写总局部磁矩（必要时，x和y方向均为0）。自旋取向（𝑢，𝑣，𝑤）由笛卡尔坐标系中的SAXIS标签定义。通过使自旋朝不同方向取向计算晶体磁各向异性能量和以下方程式</p>
<p>𝐸MAE&#x3D;𝐸（𝑢，𝑣，𝑤）−𝐸0</p>
<p>其中 𝐸0 是最稳定自旋方向的能量。更多细节请查看SAXIS和LSORBIT页面。</p>
<p>练习：通过将自旋沿以下路径定向，确定NiO的非自洽方式下的晶体磁各向异性能量：(2,2,2) –&gt; (2,2,1) –&gt; (2,2,0) –&gt; … –&gt; (2,2,-6)。与自洽方法进行比较。</p>
<p>INCAR:</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NiO</span> <span class="variable constant_">MAE</span></span><br><span class="line">  <span class="variable constant_">SYSTEM</span>    = <span class="string">&quot;NiO&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="title class_">Electronic</span> minimization</span><br><span class="line">  <span class="variable constant_">PREC</span> = <span class="title class_">Accurate</span></span><br><span class="line">  <span class="variable constant_">ENCUT</span>         = <span class="number">450</span></span><br><span class="line">  <span class="variable constant_">EDIFF</span>         = <span class="number">1E-7</span></span><br><span class="line">  <span class="variable constant_">LORBIT</span>        = <span class="number">11</span></span><br><span class="line">  <span class="variable constant_">LREAL</span>         = .<span class="property">False</span>.</span><br><span class="line">  <span class="variable constant_">ISYM</span>          = -<span class="number">1</span></span><br><span class="line">  <span class="variable constant_">NELMIN</span>        = <span class="number">6</span></span><br><span class="line">  #  <span class="variable constant_">ICHARG</span> = <span class="number">11</span></span><br><span class="line">  #  <span class="variable constant_">LCHARG</span> = .<span class="property">FALSE</span>.</span><br><span class="line">  #  <span class="variable constant_">LWAVE</span> = .<span class="property">FALSE</span>.</span><br><span class="line">  #  <span class="variable constant_">NBANDS</span> = <span class="number">52</span></span><br><span class="line">  #  <span class="variable constant_">GGA_COMPAT</span> = .<span class="property">FALSE</span>.</span><br><span class="line">    </span><br><span class="line"><span class="variable constant_">DOS</span></span><br><span class="line">  <span class="variable constant_">ISMEAR</span>    = -<span class="number">5</span></span><br><span class="line">    </span><br><span class="line"><span class="title class_">Magnetism</span></span><br><span class="line">  <span class="variable constant_">ISPIN</span>     = <span class="number">2</span></span><br><span class="line">  <span class="variable constant_">MAGMOM</span> = <span class="number">2.0</span> -<span class="number">2.0</span> <span class="number">2</span>*<span class="number">0.0</span></span><br><span class="line">  # <span class="variable constant_">MAGMOM</span>    = <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">2</span> <span class="number">6</span>*<span class="number">0</span> # <span class="title class_">Including</span> <span class="title class_">Spin</span>-orbit</span><br><span class="line">  # <span class="variable constant_">LSORBIT</span>       = .<span class="property">True</span>.</span><br><span class="line">  # <span class="variable constant_">SAXIS</span> = <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> # <span class="title class_">Quantization</span> axis used to rotate all spins <span class="keyword">in</span> a direction defined <span class="keyword">in</span> the (O,x,y,z) <span class="title class_">Cartesian</span> frame</span><br><span class="line">    </span><br><span class="line"><span class="title class_">Orbital</span> mom.</span><br><span class="line">  <span class="variable constant_">LORBMOM</span> = T</span><br><span class="line">    </span><br><span class="line"><span class="title class_">Mixer</span></span><br><span class="line">  <span class="variable constant_">AMIX</span>      = <span class="number">0.2</span></span><br><span class="line">  <span class="variable constant_">BMIX</span>      = <span class="number">0.00001</span></span><br><span class="line">  <span class="variable constant_">AMIX_MAG</span>  = <span class="number">0.8</span></span><br><span class="line">  <span class="variable constant_">BMIX_MAG</span>  = <span class="number">0.00001</span></span><br><span class="line">    </span><br><span class="line"><span class="variable constant_">GGA</span>+U</span><br><span class="line">  <span class="variable constant_">LDAU</span>      = .<span class="property">TRUE</span>.</span><br><span class="line">  <span class="variable constant_">LDAUTYPE</span>  = <span class="number">2</span></span><br><span class="line">  <span class="variable constant_">LDAUL</span>     = <span class="number">2</span> -<span class="number">1</span></span><br><span class="line">  <span class="variable constant_">LDAUU</span>     = <span class="number">5.00</span> <span class="number">0.00</span></span><br><span class="line">  <span class="variable constant_">LDAUJ</span>     = <span class="number">0.00</span> <span class="number">0.00</span></span><br><span class="line">  <span class="variable constant_">LDAUPRINT</span> = <span class="number">1</span></span><br><span class="line">  <span class="variable constant_">LMAXMIX</span>   = <span class="number">4</span> </span><br></pre></td></tr></table></figure>
<h2 id="vaspkit"><a href="#vaspkit" class="headerlink" title="vaspkit"></a>vaspkit</h2><p>  先执行结构优化计算（略），之后使用以下INCAR参数并选择991 K点进行自旋极化静态计算，运行vasp_std得到CHGCAR文件。</p>
<p>  MAE的INCAR：</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#<span class="title class_">General</span></span><br><span class="line"><span class="variable constant_">PREC</span> = <span class="variable constant_">ACCURATE</span></span><br><span class="line"><span class="variable constant_">ISTART</span>= <span class="number">0</span></span><br><span class="line"><span class="variable constant_">ICHARG</span>= <span class="number">11</span></span><br><span class="line"><span class="variable constant_">ENCUT</span> = <span class="number">520</span></span><br><span class="line"><span class="variable constant_">EDIFF</span> = <span class="number">1E-8</span></span><br><span class="line"><span class="variable constant_">EDIFFG</span> = -<span class="number">0.001</span></span><br><span class="line"><span class="variable constant_">LREAL</span> = .<span class="property">F</span>.</span><br><span class="line"><span class="variable constant_">NPAR</span> = <span class="number">4</span></span><br><span class="line"><span class="variable constant_">NSW</span>= <span class="number">0</span></span><br><span class="line"><span class="variable constant_">IBRION</span> = -<span class="number">1</span></span><br><span class="line"><span class="variable constant_">ISIF</span> = <span class="number">2</span></span><br><span class="line"><span class="variable constant_">ISMEAR</span> = -<span class="number">5</span></span><br><span class="line"><span class="variable constant_">SIGMA</span> = <span class="number">0.05</span></span><br><span class="line"><span class="variable constant_">LCHARG</span> = .<span class="property">F</span>.</span><br><span class="line"><span class="variable constant_">LWAVE</span> = .<span class="property">F</span>.</span><br><span class="line"><span class="variable constant_">POTIM</span> = <span class="number">0.5</span></span><br><span class="line"><span class="variable constant_">NEDOS</span> = <span class="number">2001</span></span><br><span class="line"><span class="variable constant_">NBANDS</span> = <span class="number">144</span>        # 修改为上一步静态计算<span class="variable constant_">NBANDS</span>数值的<span class="number">2</span>倍</span><br><span class="line"></span><br><span class="line">#<span class="title class_">Magnetic</span> properties</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">MAGMOM</span> = <span class="number">18</span>*<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="variable constant_">NELMIN</span> = <span class="number">6</span></span><br><span class="line"><span class="variable constant_">LORBIT</span> = <span class="number">11</span></span><br><span class="line"><span class="variable constant_">ISYM</span> = <span class="number">0</span></span><br><span class="line"><span class="variable constant_">LSORBIT</span> = .<span class="property">True</span>.</span><br><span class="line"><span class="variable constant_">LMAXMIX</span> = <span class="number">4</span>  ! <span class="keyword">for</span> d-elements increase <span class="variable constant_">LMAXMIX</span> to <span class="number">4</span>, f-<span class="attr">elements</span>: <span class="variable constant_">LMAXMIX</span> = <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>和VPKIT.in</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1                              ! 1为预处理, 2为后处理</span><br><span class="line">0 360 12                       ! Phi, Spherical coordinate system</span><br><span class="line">0 180 12                       ! 0&lt;= theta &lt;=180, 90 degree means in x-y plane</span><br></pre></td></tr></table></figure>

<p>VPKIT.in说明：<br>第一行：在第二步计算前使用1，第二步计算完后设置为2；</p>
<p>第二行：三维球坐标系下矢量在xy面投影与x轴正方向的夹角方位角φ，由起始角度0°到终止角度360°(0°)，最后是分割角度的个数；</p>
<p>第三行：三维球坐标系下矢量与z轴的夹角θ，由起始角度0°到终止角度180°，最后是分割角度的个数(注意包含180°在内需要＋1，所以是7)；</p>
<p>其中和分别为方位角和极角，其值变化范围分别是从0°到180°和从0°到360°，这里方位角和极角各取12个离散点（共计144个计算作业）。如果计算资源允许，可以选取更小间隔。调用vaspkit-621命令产生如下所示的一系列计算作业。理论上要生成144个计算作业，考虑到一部分相等无需计算，实际上共生成了122个计算作业。预处理时VASPKIT会自动在每个计算作业文件夹里的INCAR后根据公式(1)追加SAXIS &#x3D; </p>
<p>接下来可使用以下脚本模板批量提交vasp_ncl作业。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># just for reference</span><br><span class="line">path=`pwd`</span><br><span class="line">for c in *.*</span><br><span class="line">do</span><br><span class="line">   cd $path/$c</span><br><span class="line">   echo `pwd`</span><br><span class="line">   qsub vasp_job_soc.sh   ! vasp_job_soc.sh为vasp_ncl作业脚本</span><br><span class="line">  cd $&#123;path&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>待vasp_ncl计算完成后，把INPUT.in文件中的第一行修改2，然后再次运行vaspkit-621得到MAE.dat文件。我们可利用vaspkit&#x2F;examples&#x2F;MAE文件夹中的MATLAB脚本mae_3D_plot_matlab.m进行可视化。</p>
<ul>
<li>如果想得到xy二维平面内的MAE，INPUT.in可设置为:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1                              ! 1为预处理, 2为后处理</span><br><span class="line">0 360 12                       ! Phi, Spherical coordinate system</span><br><span class="line">90 90 1                        ! xy平面内theta始终等于90°</span><br></pre></td></tr></table></figure></li>
<li>如果想得到xz二维平面内的MAE，INPUT.in可设置为:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1                              ! 1为预处理, 2为后处理</span><br><span class="line">0 0 1                      ! Phi, Spherical coordinate system</span><br><span class="line">0 180 12                       ! </span><br></pre></td></tr></table></figure>
tips:</li>
</ul>
<p>根据提示我们需要先执行一步sta，然后读取WAVECAR和CHGCAR进行Nocollinear的计算，当读取WAVECAR进行测试的时候，计算是一定会报错的，因为俩步计算电子的自由度是不同。这时候VASP一定会提示：ERROR: while reading WACECAR,plane wave coefficidents changed</p>
<p>那么继续根据官网的操作手册</p>
<ul>
<li><p>我们第一步只计算无磁性基态的CHGCAR,第二步去读取CHGCAR进行计算。<br>这里只比对了x方向和z方向的结果：发现计算的结果是一模一样的，无法区分。</p>
</li>
<li><p>接下来不读取之前的CHGCAR进行计算，还是依照之前的设置.这时候发现计算的结果是有区分的。方向不同。</p>
</li>
<li><p>还有一种计算方式是读取写入磁基态的CHGCAR，再进行自旋轨道耦合的计算。这样计算的结果是，无论选择量子化轴在哪个方向，计算的结果都是在Z轴方向，但是能量有所差距。但是根据以上俩种结果去推断Cr原子的磁晶各向异性能，发现这种计算的结果跟文献的600-800eV的结果更为接近。 所以姑且认为进行计算是合理的结果。</p>
</li>
</ul>
<h1 id="电子结构分析"><a href="#电子结构分析" class="headerlink" title="电子结构分析"></a>电子结构分析</h1><p>磁性一般来自于d、f轨道的半占据电子，下面以d轨道为例介绍电子结构的分析</p>
<ol>
<li>磁矩约等于非成对的电子数，但是电子的占据方式并不仅仅由洪特规则来决定。<br>以一个Mn2+为例，最外层5个电子，按照洪特规则Mn磁矩应该是5，但是在晶体场的作用下，它有可能呈现高自旋、<br>中自旋、低自旋态。</li>
</ol>
<p>如何查找结构晶体场：</p>
<ol>
<li>确定点群 运行vaspkit</li>
<li>查表<br><a target="_blank" rel="noopener" href="http://gernot-katzers-spice-/">http://gernot-katzers-spice-</a> pages.com&#x2F;character_tables&#x2F;index.html</li>
<li>判断能及大小</li>
</ol>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/09/18-48-23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/09/18-48-23/" class="post-title-link" itemprop="url">6.1 USPEX</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-09 18:48:23" itemprop="dateCreated datePublished" datetime="2023-11-09T18:48:23+08:00">2023-11-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-17 14:56:40" itemprop="dateModified" datetime="2023-12-17T14:56:40+08:00">2023-12-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、USPEX-简介"><a href="#一、USPEX-简介" class="headerlink" title="一、USPEX 简介"></a>一、USPEX 简介</h1><p>USPEX: Universal Structure Predictor: Evolutionary Xtallography. USPEX 代码能够通过仅仅只知道材料的化学成分来预测具有任意 P-T 条件的晶体结构。在全世界有6000多名研究人员使用它，它的出现极大的促进了相关领域的发展。而它的发明者：Oganov教授，通过这个软件做出了一系列漂亮的结果。</p>
<p>而 CALYPSO 的主要是由吉林大学的马琰铭教授主导开发的。</p>
<h1 id="二、-下载安装"><a href="#二、-下载安装" class="headerlink" title="二、 下载安装"></a>二、 下载安装</h1><ol>
<li><p>浏览器进入：<a target="_blank" rel="noopener" href="https://uspex-team.org/en/uspex/downloads%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%98%AF">https://uspex-team.org/en/uspex/downloads，这个是</a> USPEX 下载地址和官方手册。点击红色标记的 register 进行注册和登录即可免费下载。<br>USPEX-9.4.4 是 USPEX 最经典的版本，体积最小，而最新的版本的体积急剧膨胀，相对老的版本，最新版本是Oganov教授团队采用 Python 将 USPEX-9.4.4 (MATLAB)改写了一遍，无大的新功能增加，发布时间较短，质量无法得到保证。更主要的是，USPEX-9.4.4 有中文文档！</p>
</li>
<li><p>确保机器上有 MATLAB 或者Octave，假如都没有，并且机器与外网隔离的情况下，可以参考这个安装 MATLAB( https: &#x2F;&#x2F;blog.csdn.net&#x2F;pihuanwan3227&#x2F;article&#x2F;details&#x2F;84849969 ), 参考这个安装Octave (<a target="_blank" rel="noopener" href="https://www.cnblogs.com/freeweb/p/7124589.html)%E3%80%82">https://www.cnblogs.com/freeweb/p/7124589.html)。</a></p>
</li>
<li><p>接下进行安装: .&#x2F;install.sh，。接下来会提示让填写安装地址(如果机器里面 Octave 已经安装好，会显示 Octave。当然 MATLAB 安装好，也会显示 MATLAB)</p>
</li>
<li><p>接下来还有重要的最后三步（这个就是设置环境变量，能够当前用户能够直接调用 USPEX）：</p>
</li>
</ol>
<ul>
<li>vi  ~&#x2F;.bashrc  </li>
<li>export PATH&#x3D;$PATH: &#x2F;home&#x2F;xiaoming&#x2F;EDU&#x2F;USPEX  </li>
<li>export USPEXPATH&#x3D;&#x2F;home&#x2F;xiaoming&#x2F;EDU&#x2F;USPEX&#x2F;src</li>
</ul>
<p>其中&#x2F;home&#x2F;xiaoming&#x2F;EDU&#x2F;USPEX为USPEX安装目录。</p>
<h1 id="三、进行计算"><a href="#三、进行计算" class="headerlink" title="三、进行计算"></a>三、进行计算</h1><p>在上一步中已经成功安装好 USPEX 了，这时候可以使用 USPEX 进行计算了，本教程使用的是最主流的软件组合：USPEX+VASP，本教程需要 VASP 已安装好，至于 VASP 懂不懂并不影响本教程的使用。</p>
<h2 id="3-1-准备输入文件"><a href="#3-1-准备输入文件" class="headerlink" title="3.1 准备输入文件"></a>3.1 准备输入文件</h2><p>首先建立一个名为&#x2F;La-H&#x2F;0GPa的文件夹，进入这个文件之后，在终端输入命令： USPEX –g,然后查看文件夹 0GPa，会发现多了四个文件夹：AntiSeeds、Seeds、Specific、Submission。</p>
<p>其中，AntiSeeds 和 Seeds 文件夹中里面的存放的的是结构文件，由于本教程使用的是VASP进行计算，故这两个文件夹放的是 POSCARS 的文件（至于为什么是POSCARS，等下解释）。而 Specific 文件夹里面放的是 VASP 进行计算时，需要的和赝势文件，而 Submission 文件夹里面放的是 USPEX 各种方式提交任务的脚本。这 4 个文件夹是 USPEX 程序自动生成的，因而需要进入每个文件夹里面进行修改或者准备所需要的输入文件。接下来我们一个个文件来进行详细说明（划重点）。</p>
<p>a. AntiSeeds 文件夹，这个文件顾名思义，就是禁止 USPEX 生成的结构的种子文件，与 Seeds 文件夹作用相反，并且这个功能不常使用，本教程 AntiSeeds 文件夹就不设置，不用管它，直接考虑 Seeds 文件夹。</p>
<p>b. Seeds文件夹，这个文件夹就是USPEX计算时，需要种子文件存放的地方。好了，既然需要种子文件，那么我们来准备种子文件吧。本教程要进行搜索的是 La-H 体系，那么开始准备La、H结构文件吧。首先到日本晶体结构数据NIMS网站(<a target="_blank" rel="noopener" href="https://crystdb.nims.go.jp/crystdb/search-materials">https://crystdb.nims.go.jp/crystdb/search-materials</a>: 免费注册且免费下载，并且里面结构文件多数有其引用的相关文献)上找结构。</p>
<pre><code>1）、 把这两种元素的cif结构文件全部下载下来；

2）、用VESTA 
(http://www.jp-minerals.org/vesta/en/download.html：下载后解压即可使用，功能很强大的软件) 打开，另存为VASP5 格式的POSCAR文件；

3）、打包上传到机器上刚刚建立的/La-H/0GPa /Seeds文件下；

4）、包把La和H的POSCAR文件合并为一个文件，并命名为POSCARS (1、可以使用cat 命令合并，如：cat POSCAR_La* POSCAR_H &gt;&gt; POSCARS，2、建议查看一下POSCARS文件格式，假如有类似乱码的东西，dos2unix POSCARS百度了解一下)。
</code></pre>
<p>c. Specific文件夹,这个文件夹主要存放的是USPEX控制的VASP进行计算的输入文件，由于本教程是La-H体系在0 GPa的变组分结构搜索，主要是用VASP计算USPEX生成结构的能量，因而这个文件内主要是POSCAR进行结构优化的文件：<br>INCAR_1-5: 这样设置的主要原因：考虑有你的初始结构通常远离局部最小点，在这种情况下，</p>
<p>INCAR_1，2首先应该在保持体积固定的情况下（ISIF&#x3D;4）弛豫原子和晶胞形状，然后在INCAR_3，4中做完全弛豫（ISIF&#x3D;3），在INCAR_5中完成非常精确的单点计算（ISIF&#x3D;2，NSW&#x3D;0）（至于更具体的细节问题，手册上有详细的描述，请查看手册第3章第3.4小节）。值得注意的是：K点设置由USPEX自动生成了，无需考虑。</p>
<p>d. Submission文件夹, 这个文件夹主要是USPEX来提交计算任务和检查计算任务的情况的一些脚本。一般情况下，提交计算任务都是通过登陆到服务器上进行提交，那么这时候需要修改submitJob_local.m和checkStatus_local.m这两个脚本。</p>
<p>e. INPUT.txt</p>
<p>USPEX 自动生成的4个文件夹已经处理好了，那么接下来就是控制USPEX计算的输入文件：INPUT.txt  (固定名字的文件)，在&#x2F;La-H&#x2F;0GPa文件通过文本编辑器(vi INPUT.txt)，把上面的内容输入进去，并并保存，下面来解释每行代表的意思，这是超级重重点。</p>
<p>上图都是USPEX计算输入控制文件：INPUT.txt主要内容，棕黄色的数字标志是行数，只是为了显示方便，不是需要输入的内容。</p>
<pre><code>1-3行、为注释说明行。
第4行、为选择计算类型行，主要是选择什么样的计算方法进行不同类型的计算，目前USPEX支持四种计算方法分别为：USPEX、VCNEB、META、PSO等。但目前采用变组分结构搜索的话，选用其王牌类型，USPEX就行，其他方法请参阅手册
第5行、需要计算的结构类型、是否为分子和是否为变组分计算，301：3代表了三维块状结构，0代表了不是分子，1代表了采用变组分。
第6行、1是代表了进行结构搜索最稳定结构时采用了生成焓作为筛选标准，当然还有其他标准：体积，硬度，结构有序度等等，详情参阅手册。
第7行、1代表了设置允许系统自动进行进化的变分操作，这个设置能加快运算。
第9-11行、是设置需要计算的体系，本教程是La-H体系，所以在第10行输入La H, 当然你也可以在第10行输入 La H 的原子序数：57 1 ，这样也是被允许的。
第13-16行、设置上面你设置的体系原子的个数之比，表示着：LaxHy，也就是说任意x个La和任意y个H的结构都是可以生成的。假如需要生成任意x个La和任意2y个H的结构怎么设置？
第17-24行、设置关于生成结构的数目，第20行populationSize设置除了第一代，其余以后每代生成的结构的数目，第21行initialPopSize设置第一代生成的结构的数目，第22行numGenerations，设置总共计算的最大代数。第23行stopCrit设置多少代的最好结构结构都一样就停止USPEX计算。第24行是设置是否重新优化幸存的结构，默认是0，意思就是不重新优化。（需要注意的是，这里的设置的大小，大致上决定你需要优化的结构的数目）
第25-29行、设置允许生成LaxHy结构中8&lt;=x+y&lt;=18，这样设置能够更好锁定搜索结构的范围，当然越小计算量越少了，这个主要看个人选择了，但是minAt和maxAt不要相差太大，太大容易出错或者最后结果漏掉一些结构，手册上有推荐选择范围，自己参阅考虑。
第30-37行、设置遗传变分操作的具体细节的，主要设置各个操作的所占比例，fracGene:基因遗传占的比例，fracRand：随机生成的占比例，fracAtomsMut:原子摄动占的比例，fracTrans：晶格转变占的比例，fracLatMut：点阵摄动占的比例。注意：所有比例之和必须为1。
第39行、这行是设置体系的压强大小，单位是GPa, 0是不施加外压。当然了前面提到的文章，压力有150 GPa 和 300 GPa，在相应的压力下进行搜索时，应该此处改为150 或 300。
第41-46行、是设置调用的外部程序执行具体计算用的，1代表了调用VASP，1 1 1 1 1  跟Specific 文件夹里面INCAR_1、INCAR_2、INCAR_3、INCAR_4、INCAR_5遥相呼应，表示一个结构需要优化5次得到精确的能量值。
第48行、设置USPEX一次总共提交多少个任务，
第49行、设置提交任务方式，1设置为local，毕竟USPEX一般都是安装在服务器上面的。
第51-56行、设置重新启动USPEX运算，这个设置应该好好琢磨一下，尤其是第54行pickUpYN，0是不进行计算，1是进行重新计算，第55行pickUpGen根据你的结果文件夹results*里面的generation*的数目进行设置，第56行pickUpFolder是根据哪个结果文件夹results*进行重新计算，这3行一定要配合使用，是相关联的。当然本教程是进行新计算，都设置为0，即可，这个弄明白了，重新计算时，可以节省大量时间。
</code></pre>
<p>好了，La-H 体系不同压强下变组分结构搜索的INPUT.txt的主要设置内容介绍完毕。</p>
<p>f. 最后一项设置，就是提交整个USPEX的脚本了，很简单的shell脚本，任何一个机器上提交USPEX任务，都可以用这个，只是切记一定要把这个脚本命名好。如果在自己机器上使用了MATLAB把 –o 去掉就行了，-o的意思是使用octave。</p>
<h2 id="3-2-提交USPEX任务"><a href="#3-2-提交USPEX任务" class="headerlink" title="3.2 提交USPEX任务"></a>3.2 提交USPEX任务</h2><p>如果前面一切输入文件准备好了之后，那么我们可以开始了神奇的USPEX变组分结构搜索之旅了。终端输入命令：n nohup .&#x2F;uspex_Lah0.sh &gt;&gt; log &amp;（其中uspex_Lah0.sh就是1.f中提到的提交USPEX任务的脚本）。</p>
<h1 id="四、官方算例1（EX01-3D-Si-vasp）"><a href="#四、官方算例1（EX01-3D-Si-vasp）" class="headerlink" title="四、官方算例1（EX01-3D_Si_vasp）"></a>四、官方算例1（EX01-3D_Si_vasp）</h1><p>案例1，0 GPa下的Si( 一个晶胞里面8个原子)<br>我们先把案例1拷贝到当前目录下：USPEX –c 1</p>
<h2 id="1、输入文件"><a href="#1、输入文件" class="headerlink" title="1、输入文件"></a>1、输入文件</h2><p>其中reference里面是案例1的计算结果，属于参考答案，等下我们来分析一下里面的文件。现在我们先考虑一下，USPEX计算需要哪些文件夹？这里是不是还少了一些文件夹？少哪些了？答案很简单嘛：USPEX –g ，然后我们看看INPUT.txt，了解一下这个案例是做什么的。</p>
<pre><code>第5行、calculationMethod （计算方法）：USPEX（遗传演化算法，也就是遗传、变异遗传算法那套原理的改进版）。
第6行、calculationType（计算类型）：300 （3：三维、0：非分子、0：非变组分）
第7行、optType（优化类型）：1（焓值）
第8行、AutoFrac ？？：我也不记得了。。。不要怕，前面不是讲过怎么查看参数嘛！USPEX -p AutoFrac
第11行、Si：计算的体系的原子类型
第15行、8：计算的体系的原子类型的个数为8
第20行、populationSize (每代多少结构)：20
第21行、numGenerations（要计算多少代）：25 (这个代数，是最多要计算的代数，假如达到收敛的条件，可以在提前结束)
第22行、stopCrit（收敛的条件）：8 （单位：代。意思就是假如连续有8代的最优结构的优化类型（本例中为焓值）是一样，那么证明计算收敛了，可以停止计算了）
第23行、bestFrac（上一代用于生成下一代结构的比例）：0.6 （这个值默认值是0.7，在0.6-0.8之间是合理的）
第27行、fracGene（本代由遗传生产结构的比例）：0.5
第28行、fracRand（本代由晶体对称性随机产生结构的比例）：0.2
第29行、fracAtomsMut（本代由较小的突变产生结构的比例）：0.2
第30行、fracLatMut（本代由点阵突变产生结构的比例）：0.1
特别需要注意的是：fracGene+ fracRand+ fracAtomsMut+ fracLatMut = 1
第35行、计算总能软件的代码：1 1 1 1 1（VASP、采用5步优化，那么Specific应该有哪些文件了？请到入门教程找找）
第39行、计算总能的K点密度设置：0.13 0.11 0.10 0.08 0.06（这个值越低、K点越密集）具体描述如下：USPEX -p KresolStart 。不懂哪个参数就USPEX -p
第43行、运行总能计算软件的指令：一般建议不在这个设置这个参数，直接在Submission文件夹里面提交计算任务的脚本里面改就可以了。
第46行、whichCluster(采用什么计算方式)：一般采用1，同第43行原理。
第47行、numParallelCalcs（并行计算数）：10 (意思就是一次提交10个总能计算任务)
第48行、ExternalPressure（计算外压）：0.00001 (GPa、老朋友啦，不解释了)
</code></pre>
<p>把这个INPUT.txt读完以后，案例1就是搜索包含8个Si原子的晶胞在大气压最稳定的结构。</p>
<p>返回INPUT.txt目录，USPEX计算4大准备目录：AntiSeeds、Seeds、Specific、Submission和提交任务脚本EX01-3D_Si_vasp.sh。</p>
<pre><code>a、AntiSeeds文件夹没特别需要，不用理它；
b、Seeds文件夹，需要从NIMS下载所有稳定的Si结构，最后做成一个POSCARS，具体操作，读者需要自己动动手了，参考入门教程；
c、Specific文件夹本案例中已经准备好了；
d、Submission文件夹，读者需要自己动动手了，参考入门教程。
f、EX01-3D_Si_vasp.sh：本案例已经准备好了，需要注意的一点就是USPEX –r –o &gt;&gt; log / USPEX –r &gt;&gt;log : (Octave/ MATLAB用哪个自己修改)。
</code></pre>
<h2 id="2、计算"><a href="#2、计算" class="headerlink" title="2、计算"></a>2、计算</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./EX01-3D_Si_vasp.sh &gt;&gt; log &amp; </span><br></pre></td></tr></table></figure>

<p>在计算的过程中会出现一个重要的文件夹results1，results1里面放的就是计算结果，随着计算的时间的增长，里面会有文件夹generation1、generation2、generation3…，还有一些其他文件。但是肯定包括reference(参考答案)里面的文件，文件夹reference包含了计算结果，但是笔者先提醒一下，本次计算的目的：搜索8个Si原子的晶胞在大气压下最稳定的结构。<br>那么带着目的和INPUT.txt，我们来看一下计算结果。</p>
<h2 id="3、输出文件"><a href="#3、输出文件" class="headerlink" title="3、输出文件"></a>3、输出文件</h2><p>我们先来看最需要的答案：BESTgatheredPOSCARS和BESTIndividuals，这两个文件是定组分变胞计算的最最重要的文件，并且相互对应。</p>
<ul>
<li><p>先看看BESTIndividuals：顾名思义，这个文件里面存着每一代最稳定的结构！</p>
<p>  第1行标题，Gen是generation的缩写，USPEX计算时种群的代数；ID是USPEX计算时给每个结构做的标记，这个数值一般就是整个USPEX计算时产生第几个结构；Origin表示这个结构由什么遗传算法操作产生的；Composition成分；Enthalpy焓值；Volume、Density、KPOINTS这三个看字面意思就能明白了，SYMM代表空间群对称性，这个数字代表1-230个空间群代表；Fitness、Q_entr、A_order 、S_order这些都是代表晶胞有序度相关的量，都是根据fingerprint这篇文章里面定义的(doi:10.1107&#x2F;S0108767310026395)！</p>
</li>
<li><p>好了，我们把标题了解完了，来查看结果：焓值越低，结构越稳定！显然可见第13代（第15行）的ID301结构最稳定，而这个结构是从第12代ID276结构继承来（Origin: keptBest）,那么可以从这个文件里面看到USPEX计算过程中，最稳定的结构一代代遗传演化过程！</p>
</li>
<li><p>既然我们已经得到最稳定的结构的ID是301，那么它的具体原子坐标了？这时候该BESTgatheredPOSCARS出马了！从文件名字意思可以猜出这是最好的结构的原子坐标的集合，当然POSCAR这个就可以看出是以VASP的POSCAR形式存储的。既然我们有ID&#x3D;301这个目标，看一下这个结构在文件里面哪一行？</p>
<p>  <code>grep 301 -n BESTgatheredPOSCARS</code></p>
<p> 在文件里面的193行，现在我们打开文件，定位到这一行。</p>
</li>
<li><p>整个文件是VASP5格式的POSCAR集合，打开文件定位到这一行的时候，ID&#x3D;301这个结构是位于文件的最后，而上一个结构是EA276，上上一个结构是EA254…而EA301是第13代最稳定的结构，EA276是第12代最稳定的结构，EA254是第11代最稳定的结构。。。可以看出BESTgatheredPOSCARS的结构原子坐标和BESTIndividuals每一代的最稳定的结构是一一对应的，那么BESTgatheredPOSCARS里面的结构原子坐标也是一代代最稳定的结构步步演化过程。</p>
</li>
<li><p>把BESTIndividuals和BESTgatheredPOSCARS理解透彻了，其余的文件根据文件名字也能知道里面存放的具体数据是什么。比如文件Individuals里面放的是所有结构的焓值、体积、密度和有序度等信息，gatheredPOSCARS里面放的是所有的结构的原子坐标，Parameters.txt就是INPUT.txt的副本。余下的文件里面值得注意的就是OUTPUT.txt，这个文件是USPEX计算过程的软件自身的log文件。</p>
<p> 里面包含了对于整个USPEX计算的解释，随着每一代计算的结束，OUTPUT.txt。这个文件里面也会有对于这一代计算的总结，整个计算结束以后，USPEX也会做出总结。总而言之，OUTPUT.txt就是log文件，假如不明白USPEX怎么计算的，或者USPEX计算过程出错了，在这里都能找到原因。</p>
</li>
</ul>
<h1 id="五、官方算例2（2-8）"><a href="#五、官方算例2（2-8）" class="headerlink" title="五、官方算例2（2-8）"></a>五、官方算例2（2-8）</h1><h2 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h2><ul>
<li><p>主要目标：在100 GPa，MgAl2O4（28个原子的单胞）使用GULP(General Utility Lattice Program，<a target="_blank" rel="noopener" href="http://gulp.curtin.edu.au/gulp/%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%8A%9B%E5%9C%BA%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%9C%89%E5%BE%88%E5%A4%9A%E6%9C%89%E6%84%8F%E6%80%9D%E7%83%AD%E5%8A%9B%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%8A%9F%E8%83%BD%EF%BC%8C%E6%9C%89%E6%9C%BA%E4%BC%9A%E5%86%8D%E4%BB%8B%E7%BB%8D">http://gulp.curtin.edu.au/gulp/，使用力场方法进行计算的软件包，里面有很多有意思热力学计算功能，有机会再介绍</a>) -采用Buckingham势-进行变胞计算。这个案例直接揭示了地球内部物理现象，但是由于力场方法精确性不如DFT方法，所以想要更精确的结果，可以改用VASP一类的软件，同时计算时间会增长不少！</p>
</li>
<li><p>看完案例的简单介绍，我们来读一下INPUT.txt，复习一下定成分变胞计算怎么设置参数。</p>
<p>第4行、 calculationMethod （计算方法）：USPEX（遗传演化算法，也就是遗传、变异遗传算法那套原理的改进版）。<br>第5行、calculationType（计算类型）：300 （3：三维、0：非分子、0：非变组分）<br>第6行、optType（优化类型）：1（焓值）<br>第7行、AutoFrac：1（允许系统自动变异演化，比用户自定义的快2倍）。一般建议设置为1即可。<br>第10行、Mg  Al  O：计算的体系的原子类型<br>第14行、4  8  16：计算的体系的Mg、Al、O的个数分别为4、8、16，也就是体系的原子总数为28的MgAl2O4。<br>第19行、populationSize (每代多少结构)：40<br>第20行、numGenerations（要计算多少代）：60 (这个代数，是最多要计算的代数，假如达到收敛的条件，可以在提前结束)<br>第21行、stopCrit（收敛的条件）：30（单位：代。意思就是假如连续有30代的最优结构的优化类型（本例中为焓值）是一样，那么证明计算收敛了，可以停止计算了）<br>第22行、bestFrac（上一代用于生成下一代结构的比例）：0.6 （这个值默认值是0.7，在0.6-0.8之间是合理的）<br>第26行、fracGene（本代由遗传生产结构的比例）：0.5<br>第27行、fracRand（本代由晶体对称性随机产生结构的比例）：0.2<br>第28行、fracPerm（本代由置换产生结构的比例）：0.1<br>第29行、fracAtomsMut（本代由较小的突变产生结构的比例）：0.2<br>特别需要注意的是：fracGene+ fracRand+ fracPerm+ fracAtomsMut &#x3D; 1<br>第35行、计算总能软件的代码：3 3 3 3 （GULP、采用4步优化，那么Specific应该有哪些文件了？等下介绍）</p>
<p>以上就是USPEX所有用于结构优化的软件包<br>第39行、运行总能计算软件的指令：一般建议不在这个设置这个参数，直接在Submission文件夹里面提交计算任务的脚本里面改就可以了。<br>第43行、numParallelCalcs（并行计算数）：1(意思就是一次提交1个总能计算任务，计算效率太低，建议设置16个左右)。<br>第44行、whichCluster(采用什么计算方式)：一般采用1，同第43行原理。<br>第45行、ExternalPressure（计算外压）：100 (GPa)</p>
<p>把INPUT.txt读完以后，案例2和案例1计算类型和参数设置几乎都是一样，但是需要注意的这次是采用GULP来计算的，那么问题来了！</p>
<p><strong>问题1. Seeds 和AntiSeeds里面的种子文件采用的是GULP格式的吗？</strong></p>
</li>
</ul>
<p>答：不是！还是VASP5 格式的POSCARS。另外提醒一下，种子文件都是POSCARS的形式，跟采用何种结构优化软件包无关！</p>
<p>  <strong>问题2. Specific里面的文件怎么设置？</strong></p>
<ul>
<li><p>GULP计算时，ginput 和goptions一一对应，文件夹里面的文件还和INPUT.txt里面的4次结构优化对应。<br> 文件夹Submission的文件需要读者自己根据自己机器去修改了，然后假如读者机器里面有GULP的话，可以提交任务计算结果和reference对比一下。笔者在此不多说，直接看reference文件夹。</p>
<p>里面的文件和案例2的文件都是一样的，可见定成分变胞计算结果都是由这些文件组成的。现在我们看看结果文件BESTIndividuals和BESTgatheredPOSCARS，其余文件就不再介绍了。</p>
<p>从文件BESTIndividuals中可以看出到了第34代计算停止，之前30代的结构的焓值计算是一样，与INPUT.txt中stopCrit参数值30是对应的。既然有第34代最稳定结构的ID&#x3D;1562，那么根据ID&#x3D;1562去BESTgatheredPOSCARS中找结构，直接到文件最后找一下，另存ID&#x3D;1562的结构信息为一个文本文件，然后拖到VESTA，可以很直观的看到计算出的最稳定的结构究竟长什么样！</p>
</li>
</ul>
<h2 id="官方算例3"><a href="#官方算例3" class="headerlink" title="官方算例3"></a>官方算例3</h2><p>案例3：MgSiO3（每个单胞有20个原子）使用GULP(采用Buckingham势)在知道结构参数的条件下进行结构预测。这个结构的晶格参数和后钙钛矿一致。后钙钛矿的发现（Oganov &amp; Ono, Nature 2004; Murakami et al., Science 2004）在地球科学领域是一个重大突破。<br>我们直接来来读一下INPUT.txt：</p>
<pre><code>第11-13行、symmetries：16-74。第一次出现，设置生成结构的晶体对称性。三维晶体的取值范围：2-230。
第42-44行、Latticevalues：2.474 8.121 6.138 90.0 90.0 90.0 = b, c, alpha, beta, and gamma values。此参数仅用作初始猜测，仅影响第一代，USPEX计算的每个结构都经过充分优化，并采用与（自由）能量最小值相对应的晶体参数。INPUT.txt中其他的参数都在案例2中讲解过一次了，就不再解释了。下面我们来继续看一下结果！
</code></pre>
<p>可以看出，案例3总共计算20代，共626个结构，得到最稳定的结构的原子结构之后，可以去计算MgSiO3其他的性质。</p>
<h2 id="其他算例解释"><a href="#其他算例解释" class="headerlink" title="其他算例解释"></a>其他算例解释</h2><p><strong>案例4</strong>：预测16个C原子的最稳定的晶胞，但是使用LAMMPS优化结构计算能量，跟案例2、案例3基本上一样的，就不多介绍了!</p>
<p><strong>案例5</strong>：预测8个Si原子的最稳定的晶胞，但是ATK里面的tight binding近似方法来优化结构计算总能，不多解释啦！</p>
<p><strong>案例6</strong>：预测10 GPa下8个C原子的最稳定的晶胞，但是使用CASTEP优化结构计算能量，你懂的!</p>
<p><strong>案例7</strong>：预测8个Si原子构成的二维晶体在0 GPa下最稳定的结构。<br>这个案例有点不一样，我们来直接看一下INPUT.txt，再讲一下不一样的参数怎么构成不一样的计算。</p>
<pre><code>第5行、calculationType：-200。
这个为什么是-2，没这个维数取值呀？不懂直接USPEX –p calculationType！

可以看到2是表面结构，而-2是二维晶体结构，至于二维晶体和表面结构有什么区别？这个问题笔者不能很通俗易懂告诉大家，只能告诉你在USPEX中，二维晶体计算既不需要端点参考能也不需要衬底，而只需设置二维初始结构的厚度即可，而表面计算需要！

第7行、thicknessS：3.0。初始层厚度，最后一个是大写的S，因为是Start的缩写。


第10-12行、vacuumSize：8 9 10 12（20）？。设置真空层厚度，这是二维晶体和表面计算必须要设置的，不然的话，没有真空层，就会有作用力，计算的也就不是二维晶体。而这个参数，这里貌似设置错误了，少了1个参数。
</code></pre>
<p><strong>既然，我们读完INPUT.txt，那么有一个问题出来了：Seeds里面的文件怎么去设置了？还是POSCARS，里面还是放所有稳定的Si原子结构！</strong></p>
<p>我们现在来看一下结果！总共计算了13代共295个结构。那么最后一代稳定的结构长什么样了？显然POSCAR的原子坐标，根本看不出什么，而单胞结构示意图也看不出是二维晶体，做一个3x3x3的超胞，可以看出这就是一个二维晶体！USPEX多么神奇！</p>
<p><strong>案例8</strong>： 36个Mo原子的纳米粒子结构预测。使用Lennard-Jones对势函数的GULP进行结构优化。<br>这个案例值得看一下INPUT.txt。</p>
<pre><code>第5行、calculationType：000。纳米颗粒结构计算。

第36-38行、vacuumSize：10 10 11 12 12。真空厚度，案例7已经提到了，显然这个案例中真空层厚度值设置正确了。

这个计算结果，显示在第7代一下突然找到低焓值的结构，然后一直持续到了26代，总共有20代的最稳定的结构的焓值是一样。所以到了第26代计算结束了。而我们查看第26代最稳定的结构示意图如下，也真是纳米颗粒结构！
</code></pre>
<p><strong>总结</strong>：</p>
<pre><code>案例2：在100 GPa，MgAl2O4（28个原子的单胞）使用GULP采用Buckingham势-进行变胞计算。（calculationType：300）
案例3：MgSiO3（每个单胞有20个原子）使用GULP(采用Buckingham势)在知道结构参数的条件下进行结构预测。（calculationType：300）
案例4：预测16个C原子的最稳定的晶胞，但是使用LAMMPS优化结构计算能量。（calculationType：300）
案例5：预测8个Si原子的最稳定的晶胞，但是ATK里面的tight binding近似方法来优化结构计算总能。（calculationType：300）
案例6：预测10 GPa下8个C原子的最稳定的晶胞，但是使用CASTEP优化结构计算能量。（calculationType：300）
案例7：预测8个Si原子构成的二维晶体在0 GPa下最稳定的结构。（calculationType： -200）
案例8：36个Mo原子的纳米粒子结构预测。使用Lennard-Jones对势函数的GULP进行结构优化。（calculationType： 000）
</code></pre>
<p>其实可以看出，USPEX刚开始开发的时候，主要是用于定组分变胞的三维晶体最稳定的结构预测，后来功能慢慢的扩展开来，能够预测二维晶体、纳米粒子结构以及后面要讲案例中有关分子结构的预测、进化准动力学方法、表面结构预测、三元变组分结构预测方面的内容。</p>
<h1 id="六、官方算例（9-13）"><a href="#六、官方算例（9-13）" class="headerlink" title="六、官方算例（9-13）"></a>六、官方算例（9-13）</h1><p><strong>案例9</strong>：预测有4个甲烷分子的单胞在20 GPa下最稳定结构，结构优化采用的是VASP。<br>分子？这个我们还是第一次遇到，现在来看看怎么一回事？</p>
<p>可以看到案例9多出一个MOL_1的文件，现在我们先看看这个MOL_1文件有些什么：<br>这个文件在手册里面第5章里面有介绍，也可以在线观看（<a target="_blank" rel="noopener" href="https://uspex-team.org/online_utilities/uspex_manual_release/ChineseVersion/uspex_manual_chinese_V10.2/sect0029.html%EF%BC%89%EF%BC%8C%E9%87%8C%E9%9D%A2%E8%BF%98%E4%BB%8B%E7%BB%8D%E6%80%8E%E4%B9%88%E9%80%9A%E8%BF%87XYZ%E5%9D%90%E6%A0%87%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%A5%E5%88%9B%E5%BB%BAUSPEX%E4%BD%BF%E7%94%A8%E7%9A%84MOL%E6%96%87%E4%BB%B6%E3%80%82%E6%89%8B%E5%86%8C%E4%B8%8A%E9%9D%A2%E8%BF%99%E5%9D%97%E8%AE%B2%E7%9A%84%E6%8C%BA%E9%BA%BB%E7%83%A6%E7%9A%84%EF%BC%8C%E8%AE%A9%E7%AC%94%E8%80%85%E6%91%B8%E4%B8%8D%E7%9D%80%E5%A4%B4%E8%84%91%EF%BC%8C%E6%AF%95%E7%AB%9F%E7%AC%94%E8%80%85%E5%AF%B9%E4%BA%8E%E5%88%86%E5%AD%90%E6%8E%A5%E8%A7%A6%E7%9A%84%E5%B0%91%E3%80%82%E4%BD%86%E6%98%AF%E4%BB%8E%E6%9C%B1%E5%BC%BA%E5%8D%9A%E5%A3%AB%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E4%B8%AD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AF%BB%E5%88%B0%E8%BF%99%E4%B8%AA%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A%E5%9C%A8USPEX%E4%BA%A7%E7%94%9F%E5%88%86%E5%AD%90%E7%BB%93%E6%9E%84%E7%9A%84%E6%97%B6%E5%80%99%E8%BF%9B%E8%A1%8C%E7%BA%A6%E6%9D%9F%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%A4%A7%E5%A4%A7%E9%99%8D%E4%BD%8E%E6%90%9C%E7%B4%A2%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%87%8F%E5%B0%91%E8%AE%A1%E7%AE%97%E9%87%8F%EF%BC%9B%E5%85%B6%E6%AC%A1%EF%BC%8C%E4%BB%BB%E4%BD%95%E5%88%86%E5%AD%90%E7%9A%84%E8%83%BD%E9%87%8F%E5%80%BC%EF%BC%8C%E9%83%BD%E8%A6%81%E6%AF%94%E5%85%B6%E5%88%86%E8%A7%A3%E4%B8%BA%E6%B0%B4%E5%92%8C%E7%9B%90%E7%9A%84%E5%8C%96%E5%90%88%E7%89%A9%E7%9A%84%E8%83%BD%E9%87%8F%E5%80%BC%E4%BD%8E%E3%80%82">https://uspex-team.org/online_utilities/uspex_manual_release/ChineseVersion/uspex_manual_chinese_V10.2/sect0029.html），里面还介绍怎么通过XYZ坐标格式的文件来创建USPEX使用的MOL文件。手册上面这块讲的挺麻烦的，让笔者摸不着头脑，毕竟笔者对于分子接触的少。但是从朱强博士相关论文中，可以读到这个文件设置的作用：在USPEX产生分子结构的时候进行约束，这样大大降低搜索空间，减少计算量；其次，任何分子的能量值，都要比其分解为水和盐的化合物的能量值低。</a></p>
<p>进行分子结构预测时的INPUT.txt又需要注意哪些呢？</p>
<pre><code>第5行、calculationType：310 三维分子定组分。
第14行、numSpecies：1 4，这个官方案例有点问题，少了一个1，知道为啥不？
第35-38行、IonDistances，设置不同原子类型之间的最小原子间距离矩阵，而低于离子距离低于这个距离都被认为没有物理意义的，将被忽略！这里只有两种原子，所以只设置两行就行！第36行的2.0，表示C原子和C原子之间的最小距离，1.7表示C原子和H原子之间的最小距离；第37行的0.7表示H原子和H原子之间的最小距离。这些值都要比真实健值要小！

第40-42行、MolCenters，设置分子中心之间最小距离的矩阵，而任何低于这值的距离都表明分子有很大的重叠，是没有物理意义的，将被严格避免！第41行的2.8表示CH4的最小距离，单位为埃。进行分子结构预测时，这个必须设置！

INPUT.txt其余的参数在前面的案例中，已经介绍了。可以看出结构优化时，计算CH4结构的能量采用的是VASP，那么Specific文件夹里面就是INCAR五部曲和C、H原子的赝势！当然进行计算时，Seeds文件夹依旧是POSCARS，里面放的是C、H原子的最稳定的结构！可以看到除了多了MOL_1文件和INPUT.txt部分参数不一样外，分子结构预测跟其他晶体预测设置不一样？
</code></pre>
<p>下面我们来看看参考结果的reference文件夹：</p>
<p>里面也有MOL_1文件，这个是从之前的那个MOL_1拷贝过来的。其余的文件格式和内容与之前介绍的定成分计算的文件格式和内容都是一样！</p>
<p>案例9总共计算了9代197个结构，其中最稳定的结构也是这个对称性最低的CH4。</p>
<p><strong>案例10</strong>：预测有8个甲烷分子的单胞在常压下最稳定结构，结构优化采用的是DMACRYS；跟案例9类似，就不介绍了！</p>
<p><strong>案例11</strong>：预测有2个尿素分子的单胞在常压下最稳定结构，结构优化采用的是TINKER；跟案例9、10类似，就不介绍了！</p>
<p><strong>案例12</strong>：预测Mo-B二元体系常用最稳定的结构，变组分的结构预测，结构优化是采用Lennard-Jones对势的GULP做的。<br>案例12跟入门教程的La-H二元体系变组分结构预测是相似的，只是结构优化软件的软件包是不一样的，所以INPUT.txt就不介绍了。而在La-H二元变组分结构预测中，没来得及对计算结果进行分析，这次就在本教程对变组分的结果进行详细讨论。</p>
<p>我们先看参考答案reference文件夹里面有哪些文件：</p>
<p>这次文件夹里面有很多文件，又有些文件和定组分不同，但是对于变组分结构预测而言，只有extended_convex_hull、extended_convex_hull_POSCARS、extendedConvexHull.pdf和OUTPUT.txt这四个文件最重要，彻底掌握了这四个文件就掌握了变组分结构预测的结果分析。</p>
<p>下面先来看看老朋友OUTPUT.txt，看一下Mo-B变组分运算过程的信息：</p>
<p>可以看到总共计算了60代共5287个结构，最后列出来最稳定的成分，也就是凸包线点：Mo4、B6、MoB14、Mo4B8、Mo4B4、Mo2B6。（ps: 凸包线上稳定的单胞）。那么现在读者肯定很想知道凸包线是什么？直接打开extendedConvexHull.pdf！</p>
<p>图中绿色的点就是本次计算的结构的，而最下面的那条黑色就是凸包线，位于这条线上的点就是热力学上稳定的结构。在本图中从左到右总共有6个落在线上的点，和OUTPUT.txt里面的6个稳定的成分是相对应的。读者应该知道能够很清楚的知道X轴代表什么意思，怎么计算的。而Y轴形成焓（Enthalpy of formation，eV&#x2F;atom）是由下面公式计算出来的：<br>Y &#x3D; (E(AxBy)-x<em>E(A)-y</em>E(B))&#x2F;(x+y)<br>在案例12中，x: Mo原子的个数，y:B原子的个数。</p>
<p>而凸包线画法麻烦一点，先从两个端点开始，连接焓值最低点，然后找到端点到焓值最低点这段直线中下方最远的点，连线。迭代下去，直到没有一个点位于凸包线下面！<br>这条线的做法决定了稳定的结构都位于凸包线上。 假如有一个稳定的点在凸包线上方，那么它很容易分解为距离这个点最近的凸包线上的两个稳定点，有点类似直线方程的意思。</p>
<p>读者需要仔细体会上面一段内容，因为理解了上面的观点也就明白了变组分结构预测中凸包线的意思，那么一大堆相关论文也就会明白了。<br>既然我们得到知道稳定的成分，那么它们具体的结构是什么了？先看一下extended_convex_hull文件：</p>
<p>这个文件有些意思，第1-4行解释了extended_convex_hull文件的X、Y和Fitness这些标题的含义，其中X、Y和extendedConvexHull.pdf中X、Y轴是一一对应的，而Fitness这个就是结构离凸包线的距离，值为0意思就是在凸包线上，而值大于0就是在为凸包线上方，那么一个小小的思考题来了：为什么这个文件中没有Fitness值小于0的？（提示：思考凸包线的画法）</p>
<p>现在我们把注意放在第7-12行，因为它们Fitness的值为0，也就是说它们就是凸包线上的点。再看一下它们的Compositions和Enthalpies值，与OUTPUT.txt里面的值是一一对应的，综合以上信息，可以确定以上6个结构就是我们要找的稳定结构。从第13行往后就是根据Fitness从小到大排下去的，也可以认为这是根据稳定性排下去的，当然大部分情况下，这些结构都是不需要考虑的！既然我们知道要找到的稳定结构，那么怎么找到这些结构的原子坐标？这就需要看看extended_convex_hull_POSCARS了：</p>
<p>整个文件就是POSCAR的集合，并且每个结构的表头和之前的BESTgatheredPOSCARS是一样的，再加上第1行和第25行的ID，与extended_convex_hull里面前两个稳定结构的ID是一一对应的，那么显而易见extended_convex_hull_POSCARS文件和extended_convex_hull文件里面的结构是一一对应的。</p>
<p>既然知道这些预测出的稳定新结构了，就可以继续通过DFT计算它们的性质，然后得到数据，发Paper了，这还不简单？<br>这就是变组分结构预测需要了解和处理的文件：extended_convex_hull、extended_convex_hull_POSCARS、extendedConvexHull.pdf和OUTPUT.txt。除了凸包线画法需要用心体会，其余很简单吧！</p>
<p><strong>案例13</strong>：USPEX能很容易地找到最无序的合金结构。这个案例只是为了演示TixCo(1-x)O。您需要在&#x2F;Seeds&#x2F;POSCARS中指定初始结构，并且只使用置换突变操作。（在这种情况下，不需要使用任何外部代码。在这个例子中，我们优化（最小化）结构有序度（Oganov and Valle（2009）；Lyakhov Oganov Valle（2010））而不需要进行结构优化（abinitioCode&#x3D;0）。种子结构（Ti-Co-O结构的超级细胞）中的Ti原子和Co原子被置换，以寻找具有最小的有序度。在这种情况下最小化有序度，我们得到了“特殊准随机结构”的广义形式。）</p>
<p>这个案例的说明比较饶舌，还是直接看INPUT.txt吧：</p>
<pre><code>第6行、optType: -4，寻找有序最小的结构！因为4是寻找有序度最大的结构，所以-4是相反的意思。
第30行、howManySwaps：15，设置为这个值，是因为在第29行设置本次计算的子代结构都是通过交换父代结构中的原子产生的。本次计算的Co16Ti16O64的单胞，总共有96个原子，这个值占比15%左右。

第32-34行、specificSwaps：

1 2，指明只有Co、Ti原子能进行置换。
</code></pre>
<p>其余没有什么新鲜的参数要介绍了，不过读者可能会注意到，本次并没有进行结构优化，或者说是调用外部软件进行计算。都是USPEX通过自己的Fingerprint算法来计算有序度，这个具体是怎么一回事？可以参考这个在线网址(<a target="_blank" rel="noopener" href="https://uspex-team.org/online_utilities/fingerprints2/)%E3%80%82">https://uspex-team.org/online_utilities/fingerprints2/)。</a></p>
<p>好了，再把Seeds&#x2F;POSCARS文件准备好：放入Co、Ti、O原子所有稳定的结构信息进去就OK了。至于计算，本地计算就可以。我们先来看看结果吧（由于这次是300计算，结果只是需要关注BESTIndividuals、BESTgatheredPOSCARS、OUTPUT.txt），先看一下BESTIndividuals文件：</p>
<p>可见BESTIndividuals文件还是跟以前，到文件末尾总共有50代 (本图志截取到19代 )，那么问题又来了，我们需要预测的结构长什么样了？我们接着打开BESTgatheredPOSCARS文件：可以看出这个结构还是比较复杂的，有点无序的感觉，有点高熵合金的感觉。</p>
<p><strong>总结</strong>：</p>
<pre><code>案例9：预测有4个甲烷分子的单胞在20 GPa下最稳定结构，结构优化采用的是VASP。310
案例10：预测有8个甲烷分子的单胞在常压下最稳定结构，结构优化采用的是DMACRYS； 310
案例11：预测有2个尿素分子的单胞在常压下最稳定结构，结构优化采用的是TINKER； 310
这三个都是分子结构预测：310类型的，所以只详细的介绍了310。

案例12：预测Mo-B二元体系常用最稳定的结构，变组分的结构预测，结构优化是采用Lennard-Jones对势的GULP做的。301
这个案例主要是介绍了结果分析，其中关于凸包线的那段值得读者思考一下，弄明白了，很多Paper都能理解了。

案例13：预测最无序的TixCo(1-x)O合金结构。300
这个案例主要介绍无序结构预测，有点准随机的感觉，目前笔者感觉其在高熵合金方面有潜在用途。
</code></pre>
<h1 id="七、官方案例讲解（14-15）"><a href="#七、官方案例讲解（14-15）" class="headerlink" title="七、官方案例讲解（14-15）"></a>七、官方案例讲解（14-15）</h1><p><strong>案例14</strong>：通过进化准动力学(Evolutionary metadynamics)预测下常压下Si的低能亚稳结构，结构优化采用的是VASP。<br>这个案例就是为了展示Evolutionary Metadynamics强大的威力，其实最近为了演示水分子结晶问题这一科学热点问题，Metadynamics出了很大一把力。下面还是闲话少说，我们来看看怎么设置计算和分析结果的。<br>先看一下INPUT.txt</p>
<pre><code>第1行、calculationMethod: META，第一次看到不是USPEX，而是META(Evolutionary metadynamics)。
第8行、minVectorLength: 2.0，设置生成的子代结构最短的健长

第9行、maxVectorLength：8.0，这个值是Evolutionary metadynamics独有的，是设置最大的健长，假如在进化准动力学计算中，单胞的健长没有处在最小健长和最大健长之间，那么在计算时，软件会自动校正，使晶胞进入正常的范围。


第15行、mutationDegree：3.0、设置软模突变(softmutation)的程度，单位为埃。简单一点的意思就是设置晶格某个原子位置方向的突变距离。在Evolutionary metadynamics算法中，晶胞都是通过软模突变生成子代结构的。


第16行、：GaussianHeight：250.0，进化准动力学专门的参数，用来促进晶胞相变，具体的值跟晶格常数和剪切模量相关。

第17行、GaussianWidth：0.3。有高斯高度，那么肯定会有一个高斯宽度了！作用和GaussianHeight一样，但是这个参数只和晶胞最小长度有关。

第18行、FullRelax：2，metadynamics原理是晶胞在某个方向上，长度发生变化，然后进行固定体积结构优化。而这个FullRelax就是设置结构优化的程度，可以理解为精度，0：精度最低，1：精度一般，2：精度可靠，大部分计算都采用2。
</code></pre>
<p>好了，进化准动力学参数介绍就介绍了到这里了。但是读者可能会有点好奇，这里为什么我们没有设置体系？ 因为不需要！META计算类型，计算很特别的:</p>
<p>不需要设置Seeds&#x2F;POSCARS文件，因为计算时一般采用POSCAR_1作为初始结构，然后通过软模突变(softmutation)生成子代结构，然后结构优化，选择最稳定结构迭代下去，另一个需要注意的是这个计算截止条件是INPUT.txt里面设置的代数。</p>
<p>好了我们来处理一下结果，这里需要提一句的就是，进化准动力学是寻找跟初始结构相差不是很大的亚稳结构，因而每一代焓值最低的结构都要考虑。我们来看一下参考文件夹reference</p>
<p>这里面有很多文件很熟悉，看着名字也能猜出文件里面放的是什么，那么META(进化准动力学) 最重要的文件就是BESTIndividuals_relaxed 和BESTgatheredPOSCARS_relaxed这两个文件，不过我们先看一下BestEnthalpy.pdf</p>
<p>这个图片，绿色的点连成的红色虚线是未完全弛豫的最好结构的焓值，而蓝色的线则是完全弛豫结构的焓值。<br>接着打开BESTIndividuals_relaxed，熟悉的味道：</p>
<p>打开BESTgatheredPOSCARS_relaxed也还是熟悉的味道，就不多解释了。</p>
<p>不过这样打开展示结果并不是一个很好的方式，也许在BestEnthalpy.pdf的图片中添加亚稳结构的示意图会更有意思，更直观，但是不在这个教程演示了，会在案例21：EX21-META_MgO_gulp里面展示，并总结一下META方法和USPEX方法之间的对比。</p>
<p>BESTgatheredPOSCARS_relaxed就是案例9计算最后得到的亚稳结构，在研究中，所有的这些结构都需要考虑。也许有人会感觉这个META方法有点鸡肋，但是在研究相变的时候，尤其是水分子结晶过程，这个方法很有用！</p>
<p><strong>案例15</strong>：通过VCNEB (variable-cell nudged elastic band)预测下常压下Ar的fcc-hcp的转变过程，结构优化采用的是GULP，并采用Lennard-Jones对势。<br>闲话少说，我们先看看INPUT.txt是怎么一回事：</p>
<pre><code>第18行、vcnebType：111，指定VCNEB计算的类型。此变量由三个指标组成：计算选项（1：VCNEB方法，2：没有VCNEB计算的结构优化模式）、虚像结构数目的可变性（0：VCNEB虚像结构的数目是固定的，1：VCNEB虚像结构的数目是固定的是可变的）和弹簧常数的可变性（0：固定的弹性常数，1：可变的弹性的常数）；111，一般是推荐在重构相变（reconstructive phase transitions）上使用。重构相变：在热力学上，重构相变在相变压力/温度下呈现出焓和体积 “跳跃”变化的特征，其中，由于原子位置的变化，自由能一阶导数（熵和体积）存在不连续性。

第19行、numImages：15，执行VCNEB的初始虚像的结构的数目。
第20行、numSteps：500，执行VCNEB计算相变路径优化时的最大步数，由于VCNEB计算的过程收敛比较慢，所以一般推荐设置为500。
第21行、optimizerType：1，结构优化采用的算法：1、最速下降法，2、FIRE (Fast Inertial Relaxation Engine)。
第22行、optReadImages：2，虚像结构文件（Images）类型读取选项：0，文件中包含了所有的虚像结构，1，文件中只包含初始和最后的虚像结构，2，文件包含了初始、最后和特别指定中间虚像结构。其中选项1，2其余的虚像结构都是通过线性插值获得。
第23行、optRelaxType：3，结构优化的模式，选项：1，晶胞固定只优化原子位置，经典的NEB的方法；2，只优化晶胞点阵大小（仅仅用作测试）；3，晶胞点阵大小和原子位置都优化（变胞优化）。
第24行、dt：0.25，结构优化的时间步，设置的值太小时收敛很慢，设置很大的时候经常产生没意义的相变路径。
第25行、ConvThreshold：0.003，整个VCNEB计算收敛的标准：RMS（Root Mean Square forces）。
第29行、VarPathLength：0.3，变虚像结构方法的虚像结构的路径长度批判准则。当两个相邻虚像结构之间的长度大于VarPathLength的1.5倍时，将使用线性插值方法在两个虚像结构之间添加一个新虚像结构；当长度小于该值的0.5时，将删除第二个虚像结构。
第30行、K_min：3，单位：eV/A^2，最小的弹性常数，只在变弹性常数的VCNEB中使用。
第31行、K_max：6，单位：eV/A^2，最大的弹性常数，只在变弹性常数的VCNEB中使用。
第32行、optFreezing：0，达到收敛标准时，虚像结构是否还变动，0：变，1：不变。
第33行、optMethodCIDI：0，是否采用Climbing-Image (CI)/ Downing-Image (DI)方法，推荐使用0：CI/DI方法不采用。具体讲解如下：
</code></pre>
<p>到此案例15的VCNEB计算参数介绍也算完成了，VCNEB就是用来研究固体相变和反应路径的，比NEB更高级一点。<br>设置完了INPUT.txt，就可以准备计算了，但是需要注意VCNEB计算不需要设置种子文字Seeds，需要设置一个Images的文件，也就是虚像结构文件，包括初始虚像结构和最终虚像结构，（VCNEB就是计算初始结构和最终结构之间的相变路径的），其采用的是VASP4的POSCAR形式，如下图所示：</p>
<p>计算完之后，我们来看看结果!</p>
<p>里面有很多文件，我们不认识，但是没关系的，很多文件通过文字名字也能了解很多，我们一般只熟悉EnergyBarrier.pdf和transitionPath_POSCARs即可，因为EnergyBarrier.pdf里面放的是反应路径中虚像结构和能量的图，而transitionPath_POSCARs则是这个反应路径中对应的虚像结构的POSCAR文件。综合EnergyBarrier.pdf和transitionPath_POSCARs这两个文件，可以得到如下漂亮的结果：</p>
<p>图中，展示了初始、最终和中间鞍点的Ar结构，其余结构就没多做演示了。但是从这个这个图可以看出VCNEB计算相变路径的强大的能力。但是为什么选择这个路径了？从计算结果文件里面查看PATH这个文件夹内容，就会发现有500个相变路径（和INPUT.txt的参数numSteps对应），但是最后还是找到EnergyBarrier的反应路径（step 434），因为这个是实际情况最接近了，也可以从SelectedEnergyBarrier.pdf文件里面直观看出来为什么选择step 434：</p>
<p>从初始的fcc-Ar结构怎么变成了最后的hcp-Ar结构了？VCNEB给出最佳路径和中间反应的一系列的结构是不是真实的？从这个方法的程序编写者钱博士（虽然他现在不从事科研，去做人工智能创业）的PPT中可以看到VCNEB还是比较有用的：</p>
<p>上面讲了很多VCNEB在USPEX程序中的参数设置和简单的结果的文件分析，但是这个VCNEB方法跟NEB有什么区别了？或者说它的原理是什么了？可以看出在Update Images这个过程当中使用的进化算法进行迭代，其余过程和NEB计算过程都差不多。还有一个特别值得一提的是：VCNEB能够给出一个相对可靠的相变路径，但是结合TPS（Transition Path Sampling）方法，能够给出更可靠的相变路径，这是这个方法存在的意义！</p>
<p><strong>总结</strong>：</p>
<pre><code>案例14：通过进化准动力学(Evolutionary metadynamics)预测下常压下Si的一系列低能亚稳结构，结构优化采用的是VASP。
案例15：通过VCNEB (variable-cell nudged elastic band)预测下常压下Ar的fcc-hcp的相变路径，结构优化采用的是GULP，并采用Lennard-Jones对势。
</code></pre>
<p>这两个案例比较特殊，分别介绍了META、VCNEB两个计算方法，虽然目前这两个方法用的人比较少，但是笔者相信，这两个方法对于某些工作绝对是一个有力的工具。</p>
<h1 id="八、官方案例讲解（16-18）"><a href="#八、官方案例讲解（16-18）" class="headerlink" title="八、官方案例讲解（16-18）"></a>八、官方案例讲解（16-18）</h1><p><strong>案例16</strong>：变胞定组分预测SrTiO3（50 原子&#x2F;单胞 ）0 GPa下稳定的结构，结构优化采用的是GULP（采用Buckingham势）。（这个案例存在的意义就是为了吊打XtalOpt：也是遗传算法的结构预测软件，USPEX大体系的成功率大于90%，而XtalOpt只有7-12%）。<br>案例16是300类型，我们的老朋友了，就不介绍INPUT.txt了，直接来看结果吧。300类型的计算，结果需要看哪些文件了？BESTIndividuals和BESTgatheredPOSCARS！</p>
<p>从BESTIndividuals可以看到本次计算了42代结构，计算了大概1400多个结构，最后得到如下的稳定结构：</p>
<p>可见对于单胞50个原子这么大的结构，USPEX也能很快得到稳定的结果，而其中执行结构优化的GULP也功不可没呐。</p>
<p><strong>案例17</strong>：以最高德拜温度为目的变胞定组分预测单胞8个C原子的稳定结构，结构优化采用VASP软件包。</p>
<p>案例17还是300类型的计算，但是这次是预测具有最高德拜温度的温度结构，那么也只需要在optType参数中，将我们通用的以焓值为优化目的改为以德拜温度为目的就行了。其余的话，参数设置和一般300类型类似。但是这次需要对Specific文件里面的INCAR做一次了解，因为根据INCAR也能猜测出USPEX究竟怎么计算的。</p>
<p>Specific文件里面有5个INCAR，可以看出第一次和第二次是定体积的结构优化，而第三次和第四次结构优化是变体积的，经过这四步结构优化得到最小能量和相应的构型，最后才做弹性常数计算，因为德拜温度和弹性常数计算相关（当然这些计算是在VASP当中完成的）。</p>
<p>从OUT.txt中可以看出USPEX总共计算了15代共351个结构，这样计算量并不大，因为这个案例是作为演示用的，INPUT.txt里面设置的代数和每代个数并不多。</p>
<p>300计算类型的还需要看的就是BESTIndividuals和BESTgatheredPOSCARS这两个文件。先来看看BESTIndividuals这个文件：</p>
<p>由于这次是根据德拜温度为目标进行稳定结构预测，那么就是根据Fitness大小程度来筛选德拜温度最高的稳定结构，Fitness负的越大的结构，德拜温度更高，接下来我们来看看这个德拜温度最高的稳定结构长什么样？</p>
<p>可以看出只需要在optType参数里面修改优化参数就能获得具有相应特殊性质的稳定结构，这些特殊性质包括：</p>
<p><strong>案例18</strong>：三元体系Zn-O-H的变成分结构预测，结构优化还是采用GULP软件进行的。</p>
<p>由于变组分结构预测这方面非常非常重要，我们前面也介绍过两次了，但是这次准备继续再一次仔细介绍一下，因为大部分USPEX文章都是靠这个变组分结构预测方法产生。先来看看INPUT.txt文件：</p>
<pre><code>第4-17行是设置整个大的计算类型和体系，也就是让软件知道采用USPEX方法进行301计算，以焓值最低为目的进行优化（焓值越低越稳定）。而计算哪个体系？Zn-O-H，这三个元素以任意比例构成的结构。
第21-25行是设置USPEX遗传算法种群大小和代数。
第29-33行是设置遗传算法的产生子代结构的具体操作。
第37-46行是设置外挂的第一性原理软件。
</code></pre>
<p>USPEX的参数设置总结起来就是，先设置体系和类型，再设置种群和遗传操作，最后设置外挂的第一性原理软件，当然从官方案例拷贝一个类型的INPUT.TXT修改一下就行，不懂的参数USPEX –p xxx，就这么简单。</p>
<p>前面介绍过二元体系的变组分结构预测的结果处理，强调了凸包线的原理和作用，而此次是三元体系的变组分结构预测，还是凸包线吗？想想也是不可能，只能往三元金字塔相图那边想，预测结果最直观的展示就是打开compositionStatistic.pdf文件：</p>
<p>当然看到这个图，肯定会有点懵逼的感觉了，这个图要表达什么意思，这个Stable的结构到底是哪个了？不要着急，这个只是展示结构分布的图，具体的稳定的结构从OUTPUT.txt可以得到的：</p>
<p>这里需要抱怨一下USPEX开发者吧，这里数据并没有处理，三元体系的稳定的结构的成分为三种元素构成，前两个是整数，后一个为啥是小数了？虽然最后一位是小说看起来很别扭，但是这些结构都是我们的指路明灯，有些这些结构我们就能很有针对性和目标性的处理extended_convex_hull和extended_convex_hull_POSCARS这两个重要的文件。</p>
<p>先来看看extended_convex_hull这个文件，这个和二元体系有什么区别，其实是没多大区别的，但是二元体系里面的数据能够生动的和凸包线结合在一起，二元体系里面前面的几行的数据和OUTPUT.txt里面总结出来的稳定结构一一对应，也就是说都是凸包线上的点。而三元体系的数据有点让人摸不着头脑的感觉，看看前面几行的数据和OUTPUT.txt得到的稳定结构对应不上，只能根据OUTPUT.txt得到的稳定结构的成分来搜索。比如想找Zn1O5H10这个成分的稳定结构，直接<br><code>grep &quot;1  5 10&quot; extended_convex_hull</code><br>一下子就能extended_convex_hull找到好几个成分为Zn1O5H10的结构，当然是焓值最低的结构最稳定，那么ID为9219的结构最稳定了，既然知道了稳定的结构的ID，那么它的原子坐标信息也就好办了，直接上extended_convex_hull_POSCARS搜索一下就行：<br>grep -n EA9219 extended_convex_hull_POSCARS</p>
<p>很简单一个命令就能找到ID为9219的原子坐标信息所在的行数，那么知道行数以后，直接去extended_convex_hull_POSCARS找。</p>
<p>当然这只是一个结构的处理，OUTPUT.txt那么多稳定的结构还等待读者去处理。当然可以一个个手工去处理，也可以写一个简单脚本去处理。接下来请稍微深入的思考一下：三元体系变组分的有了这么一个初步的结果，怎么把这些结果变成paper了？下面一篇文章能够得到很好答案。<br>doi: 10.1038&#x2F;srep18347 (2015)</p>
<p>对于三元变组分结构预测，笔者还有一些需要说道一下：三元变组分搜索的计算巨大，比二元变组分计算量大的不只是一点点，并且准确率还是一个值得考虑的问题，所以一般并不建议采用这个三元体系去计算，除非计算资源很大，并不考虑投入产出的问题，存粹只是为了科研。</p>
<p>就拿Zn-O-H这三元体系计算来说，问题还是比较大的，总共计算了9339种结构，并且每种结构计算了5次，这就是差不多5W次计算，服务器跑起来至少一个月左右。再对结果进行进一步的处理，一个月左右的时间又过去了。这仅仅是一个压强下的结果，而实际上还需要计算不同压强的情况。此外有时候为了更好的处理三元体系的结果，还需要从三元体系里面找一些二元体系进行计算，这是一个庞大的工作。笔者在这里只是想强调三元体系计算变组分并不容易，如果准备三元体系计算变组分还需要做好心理准备。</p>
<p><strong>总结</strong></p>
<pre><code>案例16：变胞定组分预测SrTiO3（50 原子/单胞 ）0 GPa下稳定的结构，结构优化采用的是GULP（采用Buckingham势）。300
案例17：以最高德拜温度为目的变胞定组分预测单胞8个C原子的稳定结构，结构优化采用VASP软件包。300
案例18：三元体系Zn-O-H的变成分结构预测，结构优化还是采用GULP软件进行的。301
</code></pre>
<p>这三案例都是老朋友，前面都讲过很多次，但还是有些不一样的地方，所以这次教程比较详细的介绍了不同的地方：大体系定组分稳定结构预测、以德拜温度为目的进行定组分结构预测、计算量惊人的三元体系的变组分结构预测。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/09/18-47-22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/09/18-47-22/" class="post-title-link" itemprop="url">5.2 分子动力学2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-09 18:47:22" itemprop="dateCreated datePublished" datetime="2023-09-09T18:47:22+08:00">2023-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-18 14:19:28" itemprop="dateModified" datetime="2024-06-18T14:19:28+08:00">2024-06-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>参考官网：<br><a target="_blank" rel="noopener" href="https://www.vasp.at/wiki/index.php/Machine_learning_force_field_calculations:_Basics">https://www.vasp.at/wiki/index.php/Machine_learning_force_field_calculations:_Basics</a></p>
<p><a target="_blank" rel="noopener" href="https://www.vasp.at/wiki/index.php/Best_practices_for_machine-learned_force_fields">https://www.vasp.at/wiki/index.php/Best_practices_for_machine-learned_force_fields</a></p>
<p><a target="_blank" rel="noopener" href="https://www.vasp.at/wiki/index.php/Machine_learning_force_field:_Theory">https://www.vasp.at/wiki/index.php/Machine_learning_force_field:_Theory</a></p>
<h1 id="vasp6自带的机器学习"><a href="#vasp6自带的机器学习" class="headerlink" title="vasp6自带的机器学习"></a>vasp6自带的机器学习</h1><p>on-the-fly训练是基于分子动力学(MD)模拟来采样训练结构。逐步自动组装数据集，并在可行时用于生成MLFF。相反，在每个时间步骤中，当前力场预测能量、力和相应的贝叶斯误差估计。简单来说，如果误差超过一定阈值，将执行另一个从头开始的计算，并将参考能量和力添加到训练数据集中。相反的情况下，从头开始的步骤将被省略，系统将通过MLFF预测进行传播。随着轨迹上力场的改善，许多从头开始的步骤可以被避免，MD模拟将显著加速。最终，现场训练会产生一个准备投入生产的MLFF，即以预测模式运行MD模拟。以下步骤概述了从开始到生产运行的路径：</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="1、准备"><a href="#1、准备" class="headerlink" title="1、准备"></a>1、准备</h3><p>准备POSCAR、POTCAR、KPOINTS和AIMD的INCAR文件。</p>
<h3 id="2、从零开始-on-the-fly训练"><a href="#2、从零开始-on-the-fly训练" class="headerlink" title="2、从零开始 on-the-fly训练"></a>2、从零开始 on-the-fly训练</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ML_LMLFF = .TRUE.  #开启机器学习</span><br><span class="line">ML_MODE = train    #训练模式</span><br></pre></td></tr></table></figure>
<p>将会生成几个重要的文件：</p>
<p>ML_LOGFILE The log file for all MLFF-related details; training status, current errors and other important quantities can be extracted from here.(search err)</p>
<p>ML_ABN This file contains the collected training structures and a list of selected local reference configurations.</p>
<p>ML_FFN A binary file containing the current MLFF.</p>
<h3 id="3、重复训练（可选）"><a href="#3、重复训练（可选）" class="headerlink" title="3、重复训练（可选）"></a>3、重复训练（可选）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp ML_ABN ML_AB</span><br><span class="line">cp CONTCAR POSCAR</span><br></pre></td></tr></table></figure>

<p>也可以重复2步骤完全重新训练。INCAR和其他文件保持不变。如果读取上一步的力场，可以修改POSCAR以完成结构的变化，比如吸附、表面等。</p>
<p>将 ML_MODE 设置为 train 不变，然后重新启动 VASP。日志文件将包含一个描述现有数据集的部分，以及在生成力场之后，常规的即时程序将继续进行。最终，ML_ABN 将包含来自两个即时运行的训练结构。类似地，ML_FFN 文件是一个合并的力场。在存在 ML_AB 文件的情况下，train 模式将始终执行一个续集运行。如果想重新开始，只需从执行目录中删除 ML_AB 文件。</p>
<h3 id="4、refit快速预测"><a href="#4、refit快速预测" class="headerlink" title="4、refit快速预测"></a>4、refit快速预测</h3><p><code>cp ML_ABN ML_AB</code></p>
<p>INCAR修改：</p>
<p><code>ML_MODE = refit</code></p>
<p>会生成新的 ML_FFN。官网提示这一步是必要的。在即时训练成功且结果符合你对适用性和剩余误差的期望时，在力场应用于仅预测的 MD 运行之前还有最后一步需要完成：为快速预测模式重新拟合。再次将最终数据集拷贝到 ML_AB 文件中：</p>
<p>cp ML_ABN ML_AB<br>同时，在 INCAR 文件中设定：</p>
<p>ML_MODE &#x3D; refit<br>运行 VASP 将会创建一个新的 ML_FFN 文件，最终可以用于生产。</p>
<p>重要提示：尽管在技术上可能直接进行第5步，但强烈不建议这样做。没有重新拟合步骤，VASP 无法启用具有大约 20 到 100 倍加速的快速预测模式。你可以检查 ML_FFN 文件的 ASCII 头部信息，确保其中的力场支持快速预测。</p>
<h3 id="5、运行机器学习MD"><a href="#5、运行机器学习MD" class="headerlink" title="5、运行机器学习MD"></a>5、运行机器学习MD</h3><p><code>cp ML_FFN ML_FF</code></p>
<p>INCAR修改：</p>
<p><code>ML_MODE = run</code></p>
<p>选择这个设置后，VASP 将仅使用来自 MLFF 的预测结果，不进行从头算的计算。与相应的从头算运行相比，每个时间步的执行时间将降低几个数量级。</p>
<p>提示：MLFF 可以应用于更大的系统尺寸，即，你可以复制模拟盒以获得改进的统计数据。由于这种方法与原子数呈线性关系，因此你可以轻松估计对计算需求的影响。</p>
<p>ML_MODE参数见：<br><a target="_blank" rel="noopener" href="https://www.vasp.at/wiki/index.php/ML_MODE">https://www.vasp.at/wiki/index.php/ML_MODE</a></p>
<h3 id="建议："><a href="#建议：" class="headerlink" title="建议："></a>建议：</h3><p>即时学习可能比单点电子计算要复杂得多，因为它结合了 VASP 的多个特征。每个部分都需要通过可用的 INCAR 标签进行适当设置。如果计算的某个部分配置错误，可能会严重影响生成的 MLFF 的质量。在最坏的情况下，成功的训练甚至可能不可能实现。更具体地说，即时学习需要控制以下方面：</p>
<p>一致的收敛性<br>需要确保通过即时学习收集的所有从头算参考数据在单点电子计算设置方面是一致且收敛良好的。注意分子动力学运行中针对不同温度和密度的目标。一个 MLFF 只能再现单一的势能景观！<br>正确设置分子动力学模拟<br>考虑热力学集合的选择、恒温器和恒压器设置以及适当的时间步长。<br>正确设置机器学习力场参数<br>注意系统相关参数，如截断半径或原子环境描述符分辨率。<br>通过即时学习控制数据集生成<br>监控和控制通过自动贝叶斯阈值确定和稀疏化收集多少从头算参考数据。<br>质量控制<br>建立对剩余训练误差的合理期望。通过将预测与已知量（从从头算中）进行比较来评估生成的力场的质量。<br>提示：在尝试从头开始生成 MLFF 之前，首先要彻底熟悉系统的纯从头算计算。一旦你有信心控制收敛性，可以继续进行一次简短的 MD 模拟，不使用机器学习辅助。验证结果是否符合预期的值，如守恒原理等。只有在这样做之后，才能继续进行计算的机器学习方面。</p>
<ul>
<li>熟悉第一性原理计算，机器学习之前先进行简短的MD模拟以验证结构是否符合预期。</li>
<li>为了结果的准确性，要注意动态训练收集的参考数据与单点电子计算设置保持一致且收敛良好。注意 MD 运行中针对的不同温度和密度。MLFF只能再现单一的势能！</li>
<li>选择MD过程合适的系综、时间步长等参数</li>
</ul>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>使用机器学习力场方法，VASP可以基于第一性原理模拟来构建力场。在构建、测试、重新学习和应用力场时，必须仔细考虑许多方面。这里列出了一些最佳实践，但请注意，这个列表并不全面，这种方法尚未被应用到大量系统中。因此，我们建议进行常规严格的监测，这对所有研究项目都是必要的。机器学习力场（MLFF）培训所需的基本步骤可以在机器学习力场计算的基础页面上找到。</p>
<p>要开始训练运行，请将 ML_MODE &#x3D; TRAIN。取决于在执行 VASP 的文件夹中是否存在有效的 ML_AB，将自动选择两种模式中的一种：没有 ML_AB 文件：训练算法将从零开始。存在 ML_AB 文件：基于现有结构数据库将继续训练。在这种操作模式下，将从现有数据库（ML_AB 文件）生成一个力场，然后从指定的 POSCAR 文件中继续进行 MD 运行。这种模式用于从材料的相空间中选择额外的结构。但也可以用于通过首先训练块材料，然后在 POSCAR 文件中向表面添加分子并继续训练来检查表面。<br>如果有几个相同种类的原子应该由机器学习算法进行不同处理，重要的是在 POSCAR 文件中给它们不同的名称。例如，如果在块材料中有氧原子并且在表面的分子中也有氧原子，建议在 POSCAR 中将氧原子分成两组，并分别命名为 O1 和 O2。不可能在POSCAR文件中给不同的原子组相同的名称，名称限制为两个字符。训练模式要求VASP执行从头算计算，因此第一步是建立电子最小化方案。</p>
<p>警告：非常重要的一点是在从头开始训练和继续训练之间不要更改INCAR文件中的从头参数设置。同样，在恢复训练时不允许更改POTCAR文件。</p>
<h3 id="第一性原理计算部分"><a href="#第一性原理计算部分" class="headerlink" title="第一性原理计算部分"></a>第一性原理计算部分</h3><ul>
<li>先进行自洽计算，不要设置 MAXMIX&gt;0 </li>
<li>一般可以先单胞，然后应用到超胞。</li>
<li>自洽计算检查K点、截断能等收敛情况。</li>
<li>(ISYM&#x3D;0)对于标准的MD</li>
<li>NPT等不固定体积的ENCUT要比固体体积大30%。</li>
</ul>
<p>通常，VASP DFT 计算适用的一切也适用于这里。电子最小化的准则可用于为即时学习设置从头算部分。另外，我们强烈建议在即时学习期间遵循以下关于从头算计算的准则：<br>当使用用于机器学习的力场时，请不要设置 MAXMIX&gt;0。在机器学习过程中，常常会跳过第一原理计算数百甚至数千个离子步骤，而离子在第一原理计算之间可以有明显的移动。在这些情况下，使用 MAXMIX 往往会导致电子结构不收敛或在自洽循环中出现错误。<br>通常可以在较小的单元胞上训练力场，然后将其应用于较大的系统。务必选择一个足够大的结构，以便声子或集体振荡“适应”到超晶格中。<br>学习准确的力很重要。为此，必须检查电子最小化是否收敛。这些检查可能包括 KPOINTS 文件中的 k 点数目、平面波极限（ENCUT）、电子最小化算法等。<br>关闭标准分子动力学运行的对称性（ISYM&#x3D;0）。<br>对于没有固定网格（NpT）的模拟，平面波截断 ENCUT 必须设置得比固定体积计算高出至少 30%。此外，经常重新启动（ML_MODE&#x3D;TRAIN，工作目录中存在现有的 ML_AB 文件）以重新初始化 KS 轨道的 PAW 基函数并避免 Pulay 应力。</p>
<h3 id="MD部分"><a href="#MD部分" class="headerlink" title="MD部分"></a>MD部分</h3><ul>
<li>有轻原子要减小POTIM或增大轻原子的POMASS，氢原子不超过0.7 fs 氧原子不超过 1.5 fs。</li>
<li>TEEND要大于TEBEG，且大于目标温度30%。</li>
<li>最好NPT，或者NVT+ Langevin thermostat，避免NVE。</li>
</ul>
<p>通过Hellmann-Feynman定理从电子最小化获得力之后，VASP必须传播离子以在相空间中获得新的构型。对于分子动力学部分，熟悉设置分子动力学运行是有利的。此外，在分子动力学部分，我们建议以下设置：</p>
<p>如果系统中含有轻元素，请减小积分步长（POTIM），或者在INCAR或POTCAR文件中增加轻元素质量（POMASS）。作为一个经验法则，时间步长不应超过氢元素和含氧化合物分别为0.7 fs和1.5 fs。然而，对于重元素（如硅），3 fs的时间步长可能效果更好。<br>如果可能的话，通过温度梯度逐渐加热系统（将TEEND设置得高于TEBEG）。从一个较低的温度（不是零度）开始，并逐渐增加到所需应用温度的30%以上。这将有助于“实时”训练探索相空间的更大部分，并将导致更稳定的力场。<br>如果可能的话，更倾向于在NpT集合中进行分子动力学训练（ISIF&#x3D;3）。额外的晶胞波动可以提高所得到的力场的稳健性。但是，对于流体，只允许超晶胞的体积变化，否则晶胞可能“崩溃”，即极端倾斜，使系统成为一层原子。这可以通过ICONST在这里和这里来实现。有关约束晶胞形状的示例输入，请参阅ICONST页面或本页面的末尾。NVT集合（ISIF&#x3D;2）对于训练也是可以接受的，但使用随机热浴恒温器，因为它非常适合相空间采样（遍历性）。<br>我们应该尽可能地探索材料相空间的更多部分。因此，应始终避免在NVE集合中训练。</p>
<h3 id="训练部分"><a href="#训练部分" class="headerlink" title="训练部分"></a>训练部分</h3><ul>
<li>分步训练：比如表面吸附分子，先训练晶体，然后表面、单独分子和整个系统。</li>
<li>给定结构，温度、压力越大，误差越大，</li>
</ul>
<p>ML_MODE&#x3D;TRAIN已经为机器学习中的即时训练设置了广泛使用的默认值。尽管如此，我们仍然想为设置单独的机器学习参数提供以下指导：</p>
<p>如果系统包含不同组件，首先要分别训练它们。例如，如果系统由一个晶体表面和与该表面结合的分子组成。先训练主要的晶体，然后是表面，可能是孤立的分子，最后是整个系统（如果您不需要描述孤立的分子，可以跳过对该分子的训练）。通过这种方式，可以避免在计算密集型的复合系统中进行大量的从头算计算。</p>
<p>如果在训练过程中没有足够的参考配置（在ML_ABN中可以看到），则应该调整ML_EPS_LOW的默认值，以稀疏使用从ML_AB中提取的局部参考配置。这可以改善训练好的力场的性能。但是，这也可能会降低准确性。</p>
<p>注意：超参数优化应始终从默认值开始。对于流体，减少ML_LMAX2&#x3D;2和ML_RCUT2&#x3D;4可能会导致更好的拟合结果。</p>
<h2 id="准确性"><a href="#准确性" class="headerlink" title="准确性"></a>准确性</h2><p>力场的可实现准确性取决于许多因素，例如物种、温度、压力、电子收敛、机器学习方法等。在我们实现的核岭回归中，随着本地参考构型数量的增加，力场的准确性也会提高。这种增加并非是线性的，同时计算成本也会线性增加。在生成机器学习力场时，总是存在准确性和效率之间的权衡。</p>
<p>以下是一些经验指南：</p>
<p>对于给定的结构，随着温度和压力的增加，误差也会增加。因此，力场不应该在与目标条件相距太远的条件下进行训练。例如，对于在 300 K 下的生产运行，最好是在这个温度以上（450-500 K）学习，以捕获可能在生产运行中出现的更多结构，但是在比如 1000 K 下学习同一相位并不有益，因为这可能会降低力场的准确性。<br>液体通常需要更多的训练结构和本地参考构型才能达到与固体类似的准确性。要达到大约 30 meV&#x2F;埃的误差，液体通常需要 2000-4000 个本地参考构型，而对于简单的周期体积系统，500-1000 个参考构型可能就足够了。<br>一般来说，能量的拟合误差应该小于 1 meV&#x2F;原子，而在 300-1000 K 之间的温度下，力的误差应该在 30-100 meV&#x2F;埃之间。略高于这些值的错误可能是可以接受的，但是这些计算应该仔细检查准确性。</p>
<p>准确的力场:<br>控制学习和采样的默认参数被选择为在准确性和效率之间提供良好的权衡。特别是，ML_EPS_LOW 的默认设置倾向于在稀疏化步骤中去除本地参考构型，从而限制了准确性。然而，进一步降低 ML_EPS_LOW 至 1.0E-11 以下的值并不会提高准确性，因为在贝叶斯回归中求解的正则化正规方程的条件数大约与在稀疏化过程中考虑的 Gram 矩阵的条件数的平方成正比（见此处）。因此，如果 Gram 矩阵的条件数为 1E9，那么正规方程的条件数就为 1E18，这意味着在解正规方程时会发生精度损失。</p>
<p>要获得保留更多本地参考构型的高度准确的力场，必须使用以下两步过程：</p>
<p>首先，进行完全的即时学习：</p>
<p>ML_IALGO_LINREG&#x3D;1; ML_SION1&#x3D;0.3; ML_MRB2&#x3D;12<br>这可以由许多不同的训练步骤组成，包括所有所需的结构。将 ML_MRB1 从 8 增加到 12，并将 ML_SION1 从 0.5 减少到 0.3，可以将 Gram 矩阵的条件数提高约 10 倍，并允许稀疏化步骤保留更多本地参考构型（通常约 2 倍）。当然，这会在一定程度上减慢力场计算的速度。</p>
<p>如果无法进行完全的重新训练，还可以尝试仅增加本地参考计算的数量，就像上面描述的那样，通过使用 ML_MODE&#x3D;SELECT 并选择一个为 ML_CTIFOR 值，以获得令人满意的本地参考构型数量。</p>
<p>其次，使用 ML_MODE&#x3D;REFIT 对力场进行重新调整。</p>
<p>使用 SVD 而不是求解正则化正规方程可以避免问题的平方化，因此设计矩阵的条件数而不是它的平方变得重要。根据我们的经验，使用默认值 ML_SION1&#x3D;0.5 进行 SVD 调整总是会提高力场的准确性。</p>
<h2 id="动态调节参数"><a href="#动态调节参数" class="headerlink" title="动态调节参数"></a>动态调节参数</h2><p>如果选择了太多或太少的训练结构和本地参考配置，可以调整一些动态参数（关于学习和阈值算法的概述，请参考这里）：</p>
<p>ML_CTIFOR：为每个原子的贝叶斯力误差定义学习阈值。在继续运行中，它可以设置为先前运行的ML_CTIFOR的最后一个值。这样可以跳过计算开始时不必要的采样。然而，当从一个结构转移到另一个结构时，此标记应该非常小心设置。ML_CTIFOR取决于物种和系统。例如，低对称结构，比如液体，通常比同一化合物的高对称固体具有更高的误差。如果首先学习液体，并且使用液体的最后一个ML_CTIFOR用于对应的固体，则此ML_CTIFOR对于固体而言太大，所有预测的错误都将低于阈值。因此，在固体上不会进行任何学习。在这种情况下，最好从ML_CTIFOR的默认值开始。ML_CTIFOR的典型可达值约为0.02在300-500 K左右，约为0.06在1000-2000 K左右，因此取决于温度，也取决于系统。</p>
<p>ML_CX：它涉及阈值的计算，ML_CTIFOR &#x3D;（历史上存储的贝叶斯错误的平均值）*（1.0 + ML_CX）。此标记影响选择训练结构和本地参考配置的频率。ML_CX的正值导致更少的采样（因此更少的自始至终的计算），负值导致相反的结果。ML_CX的典型值介于-0.3和0之间。对于使用加热的训练运行，默认通常会导致平衡良好的机器学习力场。当在固定温度下进行训练时，通常希望将ML_CX减小至-0.1，增加第一性原理计算的数量，从而增加训练集的规模（默认值可能导致训练数据太少）。</p>
<p>ML_MHIS：设置用于更新ML_CTIFOR的先前贝叶斯错误数量（从ML_ICRITERIA的默认学习步骤）。如果在初始阶段之后，阈值更新之间出现贝叶斯错误的强烈变化，并且每次更新后阈值也会发生强烈变化，则可以降低此标记的默认值10。</p>
<p>ML_SCLC_CTIFOR：仅在选择本地参考配置时缩放ML_CTIFOR。与ML_CX相比，此标记不会影响采样的频率（自始至终的计算）。较小的值意味着选择更多的本地参考配置；较大的值意味着选择更少的本地参考配置。</p>
<p>ML_EPS_LOW：控制选定的贝叶斯错误估计本地参考配置数量的稀疏化。增加ML_EPS_LOW会增加删除的本地参考配置数量，减少则相反。此标记也不会影响学习频率，因为在选定新结构的本地参考配置之后才执行稀疏化。我们不建议将阈值增加到大于1E-7的值。在该值以下，此标记可以很好地控制本地参考配置的数量，但是对于多组分系统，稀疏化算法往往会导致不同物种的本地参考配置数量出现明显不平衡。</p>
<p>ML_LBASIS_DISCARD：控制在任何物种的最大本地参考配置数量ML_MB达到之后是否继续计算。先前的默认行为是ML_LBASIS_DISCARD&#x3D;.FALSE.：当任何物种的本地参考配置数量达到ML_MB时，计算将停止并要求增加ML_MB。在多组分系统中，对于一种物种，稀疏表示很快超过ML_MB，而其他物种的本地参考配置尚未被确定地描述，并且仍远低于限制ML_MB。因此，目前的默认值是ML_LBASIS_DISCARD&#x3D;.TRUE.：在这种情况下，代码在达到阈值时处置本地参考配置。它是根据物种而不同的。</p>
<h2 id="实时学习监控"><a href="#实时学习监控" class="headerlink" title="实时学习监控"></a>实时学习监控</h2><p>你的学习监控可以分为两部分：</p>
<h3 id="分子动力学-x2F-系综相关数量："><a href="#分子动力学-x2F-系综相关数量：" class="headerlink" title="分子动力学&#x2F;系综相关数量："></a>分子动力学&#x2F;系综相关数量：</h3><p>通过视觉方式监测结构。这意味着查看带有结构&#x2F;轨迹查看器的CONTCAR或XDATCAR文件。很多时候，当出现问题时，可以立即追溯到不希望或非物理形变。</p>
<p>OUTCAR、XDATCAR和CONTCAR文件中的体积和晶格参数。确认平均体积保持在期望范围内是很重要的。在恒温恒压运行中，如果平均体积随时间发生强烈变化，表明可能存在相变或未适当平衡系统。特别麻烦的是在单个VASP运行期间发生强烈的剪切：由于VASP保持平面波基组固定并最初使用球形截断球，截断球实际上变成一个椭球。也就是说，截断球在某些倒易格子方向上变小。在单次运行中，晶格矢量的变化超过10%必须避免。相关的数据文件（ML_AB）不适合继续训练（将你的计算分批进行）。</p>
<p>OUTCAR和OSZICAR文件中的温度和压力。计算开始时温度和压力与期望值存在较大偏差，表明起始位置未适当平衡。如果期望特征发生强烈振荡，可以使用块平均值来监测它们（有关块平均值的更多信息，请参见下文中的“应用”）。<br>成对关联函数（PCDAT）。</p>
<h3 id="ML-LOGFILE文件中的机器学习特定量："><a href="#ML-LOGFILE文件中的机器学习特定量：" class="headerlink" title="ML_LOGFILE文件中的机器学习特定量："></a>ML_LOGFILE文件中的机器学习特定量：</h3><p>每核所需内存估计。这在分配之前写在ML_LOGFILE的开头（见这里）。非常重要的一点是，如果所需内存超过物理可用内存，计算不会立即在静态数组分配时崩溃，因为许多系统使用懒惰分配。在内存不足之前，计算可能运行很长时间。因此，必须在启动后始终检查内存估计。<br>状态：显示每个分子动力学步骤发生的情况。当状态为“学习&#x2F;关键”时，状态“力场”被更新。从一开始就经常监测这个变量（在ML_LOGFILE.1中搜索“状态”ML_LOGFILE.1|grep -E ‘learning|critical’|grep -v“#”）。如果经过50次迭代后计算仍然在每步更新“力场”，这表明计算中有严重问题。如果计算在几步后停止学习并且以后仅进行力场步骤，那么将不会得到有用的力场。在理想的学习中，力场更新频率一开始很高，然后持续降低，直到算法只是间歇性地学习。需要注意的是，由于贝叶斯错误的近似预测，学习频率永远不会降到零。如果在分子动力学运行的后期阶段学习频率突然增加，通常表示正在探索当前力场未知的新相空间。但在训练结束时学习步骤的突然增加也可能表明系统发生了不希望的变形，这需要仔细研究。</p>
<p>LCONF：每个学习步骤的本地配置数。</p>
<p>ERR：关于从头计算数据对于所有训练结构到当前分子动力学步骤的预测能量、力和应力<br>${\displaystyle \Delta O&#x3D;{\sqrt {\sum \limits <em>{N}(O</em>{\mathrm {AI} }-O_{\mathrm {MLFF} })^{2}&#x2F;N}}}$. 这里<br>N遍历所有训练结构的能量，逐元素遍历每个训练结构，乘以每个结构中每个原子的个数乘以三个笛卡尔方向的力，逐元素遍历每个训练结构，乘以张量的九个成分的每个张量组分力。</p>
<p>BEEF：能量、力和应力的估计贝叶斯错误（列3-5）。力的最大贝叶斯误差ML_CTIFOR的当前阈值在列6上。</p>
<p>THRUPD：ML_CTIFOR的更新。</p>
<p>THRHIST：用于ML_CTIFOR的贝叶斯错误历史。</p>
<p>力的真实误差（ERR的第4列）、贝叶斯误差（BEEF的第4列）和阈值（BEEF的第6列）的典型演变如下所示：</p>
<h2 id="ICONST"><a href="#ICONST" class="headerlink" title="ICONST"></a>ICONST</h2><p>在ICONST文件中定义了几何参数，然后在分子动力学模拟中进行监控或控制。例如，两个位置之间的距离可以通过偏差势的作用来约束或影响。最后，VASP将输出写入REPORT文件。</p>
<h3 id="In-case-of-primitive-coordinates"><a href="#In-case-of-primitive-coordinates" class="headerlink" title="In case of primitive coordinates"></a>In case of primitive coordinates</h3><p>flag &#x3D; R: interatomic distance between atoms item(1) and item(2).</p>
<p>flag &#x3D; A: angle defined by atoms item(1), item(2) and item(3) (with the atom item(2) being the apex).</p>
<p>flag &#x3D; T: torsional angle defined by atoms item(1), item(2), item(3) and item(4).</p>
<p>flag &#x3D; M: distance between atom item(1) and the center of bond between atoms item(2) and item(3).</p>
<p>flag &#x3D; B: distance between the center of bond between atoms item(1) and item(2) and the center of bond between atoms item(3) and item(4)</p>
<p>flag &#x3D; P: ratio of length of the bond between atoms item(1) and item(2) and the length of the bond between atoms item(3) and item(4)</p>
<p>flag &#x3D; W: function<br>${\displaystyle {\frac {1-\left(R&#x2F;c\right)^{M}}{1-\left(R&#x2F;c\right)^{N}}}}$ wit with<br>𝑅 being the bond length (in Å) between the atoms item(1) and item(2),<br>𝑐 is the reference bond length specified as item(3), and the exponents 𝑀 and 𝑁 are defined as item(4) and item(5), respectively.</p>
<p>flag &#x3D; X, Y, and Z: fractional (direct) coordinates linked with the lattice vectors<br>𝑎, 𝑏, and 𝑐.</p>
<p>flag &#x3D; cX, cY, and cZ: Cartesian coordinates<br>𝑥, 𝑦, and 𝑧.</p>
<p>flag &#x3D; LR: length of lattice vector item(1)</p>
<p>flag &#x3D; LA: angle between lattice vectors item(1) and item(2)</p>
<p>flag &#x3D; LV: cell volume (no item(i) is defined in this case)</p>
<h3 id="complex-coordinates"><a href="#complex-coordinates" class="headerlink" title="complex coordinates"></a>complex coordinates</h3><p>flag &#x3D; S: simple linear combination of primitive coordinates, i.e., $\left(\xi &#x3D;\sum <em>{ {i&#x3D;1} }^{ {M} }c</em>{i},q_{i}\right)$.</p>
<p>flag &#x3D; C: norm of the vector of primitive coordinates, which reads<br>$\left(\xi &#x3D;{\sqrt  {\sum <em>{ {i&#x3D;1} }^{ {M} },(c</em>{i},q_{i})^{2}}}\right)$.</p>
<p>flag &#x3D; D: coordination number[1], i.e.,<br>$\left(\xi &#x3D;\sum <em>{ {i&#x3D;1} }^{ {M} }{\frac  {1-\left(q</em>{ {i} }&#x2F;c_{ {i} }\right)^{9} }{1-\left(q_{ {i} }&#x2F;c_{ {i} }\right)^{ {14} }}}\right)$.</p>
<p>flag &#x3D; IS: path-based coordinate[2] measuring progress along discretized path represented by<br>${\displaystyle {\tilde {q}}(j)}$ predefined in file IRCCAR, i.e.,<br>${\displaystyle \xi &#x3D;{\frac {1}{N-1}}{\frac {\sum <em>{i&#x3D;1}^{N}(i-1)\exp \left(-\sum <em>{j&#x3D;1}^{M}c</em>{j}(q</em>{j}-{\tilde {q}}<em>{j}(i))^{2}\right)}{\sum <em>{i&#x3D;1}^{N}\exp \left(-\sum <em>{j&#x3D;1}^{M}c</em>{j}(q</em>{j}-{\tilde {q}}</em>{j}(i))^{2}\right)}}}$</p>
<p>flag &#x3D; IZ: path-based coordinate[2] measuring orthogonal distance from the path ${\displaystyle {\tilde {q}}}$ predefined in file IRCCAR, i.e.,<br>${\displaystyle \xi &#x3D;-{\frac {1}{c_{1}}}\log \sum _{i&#x3D;1}^{N}\exp \left(-\sum <em>{j&#x3D;1}^{M}c</em>{j}(q-{\tilde {q}}(i))^{2}\right)}$ with 𝑁 as defined above The complex coordinates are functions defined in the space spanned by the primitive coordinates.</p>
<p>Mind: 所有复杂坐标都必须在最后一个基本坐标之后定义。一旦定义了复杂坐标，基本坐标只是它们定义的基础，它们的状态就会被忽略。</p>
<h3 id="Settings-for-item-i"><a href="#Settings-for-item-i" class="headerlink" title="Settings for item(i)"></a>Settings for item(i)</h3><p>它取决于标志的设置。在大多数情况下，item(i)是一个整数，指定原子的位置或晶格矢量在POSCAR文件中的位置。请注意，需要两个原子来定义键长，需要三个原子来定义键角等等。在标志W的特殊情况下，还通过item(i)定义一些额外的参数，即参考键长（通常是一个浮点数）和用于定义的指数（整数）。请查看相应标志的描述信息。</p>
<h3 id="Settings-for-status"><a href="#Settings-for-status" class="headerlink" title="Settings for status"></a>Settings for status</h3><p>status &#x3D; 0: the coordinate is constrained.</p>
<p>status &#x3D; 4: the coordinate is affected by a Fermi-type step function</p>
<p>status &#x3D; 5: the coordinate defines the collective variable in metadynamics</p>
<p>status &#x3D; 7: the coordinate is monitored</p>
<p>status &#x3D; 8: the coordinate is affected by a harmonic potential</p>
<h3 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R 1 6 0</span><br><span class="line">R 1 5 0</span><br><span class="line">S 1 -1 0</span><br></pre></td></tr></table></figure>
<p>第一行代表原子1和6的距离，末尾0代表状态为约束。同样第二行代表原子1和5的距离，状态约束。</p>
<p>第三行代表复合坐标调节，S代表原始坐标的简单结合；后面代表两个键长的差值。</p>
<p>无论复合坐标调节何时定义都要以原始坐标为基础，因此尽管键长状态是0，但它受第三行控制。假如要固定第一个键长和复合坐标调节，应该设置为例2。</p>
<h3 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R 1 6 0</span><br><span class="line">R 1 5 0</span><br><span class="line">S 1 -1 0</span><br><span class="line">S 1 0 0</span><br></pre></td></tr></table></figure>
<p>如果1-6距离是1.1 Å，1-5是1.5 Å，可以用两种方式调节。</p>
<p>（1） 用复杂调节参数D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R 1 6 0</span><br><span class="line">R 1 5 0</span><br><span class="line">D 1.1 1.5 0</span><br></pre></td></tr></table></figure>
<p>在这种情况下，出现在定义 D 的公式的分子和分母中的指数分别固定为值 9 和 14。</p>
<p>(2) 使用 W 原始和 S 复杂坐标来固定相同的配位数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">W 1 6 1.1 9 14 0</span><br><span class="line">W 1 5 1.5 9 14 0</span><br><span class="line">S 1 1 0</span><br></pre></td></tr></table></figure>
<p>这种格式的优势在于，可以为每个距离单独设置系数 M 和 N (请参阅上面 W 的定义)。此外，这种格式还允许简单直观地定义多个配位数的按比例总和和&#x2F;或差异，只需通过与 S 相关联的系数的合适选择即可，这些系数可以是正、负或零。</p>
<h3 id="例子3：约束体积或形状"><a href="#例子3：约束体积或形状" class="headerlink" title="例子3：约束体积或形状"></a>例子3：约束体积或形状</h3><ol>
<li>固定体积变形状<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LV 0</span><br></pre></td></tr></table></figure></li>
<li>固定基矢角度变长度<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LA 1 2 0</span><br><span class="line">LA 1 3 0</span><br><span class="line">LA 2 3 0</span><br></pre></td></tr></table></figure></li>
<li>固定形状立方晶系变体积</li>
</ol>
<p>Note that the S type constraints involving the lengths of the lattice vectors (𝑎𝑖−𝑎𝑗&#x3D;0) are chosen so as to preserve ratios 𝑎1:𝑎2:𝑎3&#x3D;1:1:1, as required by the cubic shape.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LA 1 2 0</span><br><span class="line">LA 1 3 0</span><br><span class="line">LA 2 3 0</span><br><span class="line">LR 1 0</span><br><span class="line">LR 2 0</span><br><span class="line">LR 3 0</span><br><span class="line">S  1  0  0  0  0  0 0</span><br><span class="line">S  0  1  0  0  0  0 0</span><br><span class="line">S  0  0  1  0  0  0 0</span><br><span class="line">S  0  0  0  1 -1  0 0</span><br><span class="line">S  0  0  0  1  0 -1 0</span><br><span class="line">S  0  0  0  0  1 -1 0</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>固定单斜晶系变体积</li>
</ol>
<p>Here, in order to fix ratios between the lengths of the lattice vectors (𝑎1:𝑎2:𝑎3), we define the constraints of the form 𝑐𝑖∗𝑎𝑖+𝑐𝑗∗𝑎𝑗&#x3D;0. For instance, if the cell vectors are such that the relative proportions of their lengths are 𝑎1:𝑎2:𝑎3&#x3D;1:1.5:2, the following ICONST can be used:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LA 1 2 0</span><br><span class="line">LA 1 3 0</span><br><span class="line">LA 2 3 0</span><br><span class="line">LR 1 0</span><br><span class="line">LR 2 0</span><br><span class="line">LR 3 0</span><br><span class="line">S  1  0  0  0      0    0 0</span><br><span class="line">S  0  1  0  0      0    0 0</span><br><span class="line">S  0  0  1  0      0    0 0</span><br><span class="line">S  0  0  0  1.5 -1.0  0.0 0</span><br><span class="line">S  0  0  0  2.0  0.0 -1.0 0</span><br><span class="line">S  0  0  0  0.0  4.0 -3.0 0</span><br></pre></td></tr></table></figure>

<h3 id="REPORT"><a href="#REPORT" class="headerlink" title="REPORT"></a>REPORT</h3><p>输出文件REPORT包含有关MD运行的信息，例如模拟中使用的参数列表，受控几何参数的值，与热浴（Andersen热浴）的碰撞次数，计算自由能梯度所需的数量等。</p>
<h3 id="监控几何参数"><a href="#监控几何参数" class="headerlink" title="监控几何参数"></a>监控几何参数</h3><p>仅适用NVT系综。在ICONST文件中，状态为7的几何参数在MD模拟期间进行监控。相应数值在每个MD步骤之后的Monit_coord字符串后的行中写入REPORT文件。</p>
<p>有时，如果所有监控参数的数值大于预定义的上限和&#x2F;或下限，终止模拟是可取的。用户可以通过VALUE_MAX和VALUE_MIN标签设置这些限制。</p>
<p>在MD运行期间监控几何参数：</p>
<ul>
<li>设置标准的MD相关标签：IBRION&#x3D;0，TEBEG，POTIM和NSW</li>
<li>设置MDALGO&#x3D;2，并选择适当的SMASS设置</li>
<li>在ICONST文件中定义几何约束，并将受约束坐标的状态参数设置为7</li>
<li>可选地，通过VALUE_MAX和VALUE_MIN标签分别设置坐标的上限和&#x2F;或下限。</li>
</ul>
<h3 id="Metadynamics"><a href="#Metadynamics" class="headerlink" title="Metadynamics"></a>Metadynamics</h3><p>仅适用NVT系综。<br>要运行带有Andersen热浴的元动力学，需要做到：</p>
<ul>
<li>设置标准的分子动力学相关标签：IBRION&#x3D;0，TEBEG，POTIM和NSW。</li>
<li>设置MDALGO&#x3D;1（或在VASP 5.x中为MDALGO&#x3D;11），并选择适当的ANDERSEN_PROB设置。</li>
<li>设置参数HILLS_H，HILLS_W和HILLS_BIN。</li>
<li>在ICONST文件中定义集体变量，并将集体变量的STATUS参数设置为5。</li>
<li>如果需要，在PENALTYPOT文件中定义偏置势。</li>
<li>实际的时间相关偏置势被写入HILLSPOT文件，在添加新的高斯函数后进行更新。在模拟开始时，VASP尝试从PENALTYPOT文件中读取初始偏置势。要继续进行元动力学运行，将HILLSPOT复制到PENALTYPOT中。每个MD步骤的所有集体变量的值都列在REPORT文件中，在字符串“Metadynamics”之后检查这些行。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/09/18-47-21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/09/18-47-21/" class="post-title-link" itemprop="url">5.1 分子动力学1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-09 18:47:21" itemprop="dateCreated datePublished" datetime="2023-09-09T18:47:21+08:00">2023-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-04 21:41:21" itemprop="dateModified" datetime="2024-06-04T21:41:21+08:00">2024-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>从头算分子动力学（ab initio molecular dYnamics, AIMD），又称为第一性原理分子动力学，为研究电子与原子核相互耦合系统的力学进动过程的理论方法。AIMD是在早期经验力场分子动力学基础上发展起来的理论方法。经验力场分子动力学中，针对原子核之间相互作用，均采用经验性的力场，这种力场往往是对相互作用，基于这些相互作用势场好处是计算量小，能够模拟的体系较大，模拟时长也比较长，统计数据也较多。</p>
<p>最初的AIMD为理想的Born-Oppenheimer分子动力学（BOMD），该理论将原子核-电子耦合体系的运动问题拆分为电子结构和分子动力学两部分，用密度泛函（DFT）等方法对特定原子核构型下的电子结构进行计算，得到K-S轨道及能量，在此基础上得到理想B-O势能面上原子核感受的势能和力，进而用经典力学来考察原子核在Born-Oppenheimer势能面上的运动。</p>
<p>为解决理想的BOMD所遇到计算瓶颈的问题，Reberto Car和Michele Parrinello于1985年提出了一种近似的BOMD方法- Car-Parrinello MD（简称CPMD）（Car, R., &amp; Parrinello, M，1985）。该方法首次使用了一个扩展的Lagrangian量来描述电子-原子核耦合体系的动力学问题，Lagrangian量引入了虚拟电子质量u，基于这个Lagrangian量可给出运动方程，通过原子核的经典运动来近似更新电子波函数，而不再需要每一步通过矩阵对角化对电子结构进行SCF计算，简化了电子结构计算，大幅降低了计算成本，使得AIMD在技术上首次具备了可操作性，开创了近几十年AIMD模拟的时代。</p>
<h1 id="第一性原理分子动力学（AIMD）结果分析"><a href="#第一性原理分子动力学（AIMD）结果分析" class="headerlink" title="第一性原理分子动力学（AIMD）结果分析"></a>第一性原理分子动力学（AIMD）结果分析</h1><p>与经典分子动力学不同，第一性原理分子动力学不需要提供力场参数，只需要提供原子初始结构，就能根据电子波函数正交化产生的虚拟力，求解牛顿运动方程。在运行优化任务时，VASP生成的XDATCAR记录的是优化步骤的离子构型；在运行AIMD任务时，记录的就是运动轨迹。而现阶段读取XDATCAR轨迹分析性质的后处理软件并不多，能读取的兼容性也并不好。__VASPKIT0.72版本之后支持了将XDATCAR转换成通用的多帧PDB文件的功能（504）以便可视化并进行后处理分析__。但是并没有提供后处理分析接口，因此我们开发了一个Python脚本XDATCAR_toolkit.py，除了实现了选择一定范围内的帧数转换成PDB文件的功能，还可以提取分子动力学模拟过程中的能量，温度并做出变化趋势图。这对判断动力学是否平衡很有帮助。另外本脚本预留了接口，可以调用读取每一帧的晶格信息和原子坐标，以便进行后续扩展编程。此脚本需要安装了numpy包的python环境，以及matplotlib包以便于画图。</p>
<p>在得到通用轨迹PDB文件后，就可以利用现用的分子动力学后处理软件进行处理分析，比如VMD，MDtraj，MD Analysis， Pymol等。__本教程将演示通过VMD和MD Analysis软件包分析RDF（径向分布函数）和RMSD（均方根偏差）__，前者可以用来分析结构性质，后者对判断结构是否稳定以及模拟是否平衡很有帮助。</p>
<p>将XDATCAR转换成PDB文件<br>以VASP官网中单个水分子的AIMD模拟为例。模拟的输入文件如下，模拟的步长是0.5fs，模拟步数1000步，模拟时间500fs。脚本和测试例子可以在Github仓库(<a target="_blank" rel="noopener" href="https://github.com/tamaswells/VASP_script/tree/master/XDATCAR_tookit)%E4%B8%8B%E8%BD%BD%E3%80%82">https://github.com/tamaswells/VASP_script/tree/master/XDATCAR_tookit)下载。</a></p>
<p>图1. 模拟的盒子<br>INCAR</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">PREC</span> = <span class="title class_">Normal</span>    ! standard precision </span><br><span class="line"><span class="variable constant_">ENMAX</span> = <span class="number">400</span>      ! cutoff should be set manually</span><br><span class="line"><span class="variable constant_">ISMEAR</span> = <span class="number">0</span> ; <span class="variable constant_">SIGMA</span> = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">ISYM</span> = <span class="number">0</span>         ! strongly recommened <span class="keyword">for</span> <span class="variable constant_">MD</span></span><br><span class="line"><span class="variable constant_">IBRION</span> = <span class="number">0</span>       ! molecular dynamics</span><br><span class="line"><span class="variable constant_">NSW</span> = <span class="number">1000</span>       ! <span class="number">1000</span> steps</span><br><span class="line"><span class="variable constant_">POTIM</span> = <span class="number">0.5</span>      ! timestep <span class="number">0.5</span> fs</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">SMASS</span> = -<span class="number">3</span>       ! <span class="title class_">Nose</span> <span class="title class_">Hoover</span> thermostat</span><br><span class="line"><span class="variable constant_">TEBEG</span> =  <span class="number">2000</span> ; <span class="variable constant_">TEEND</span> = <span class="number">2000</span> ! temperature</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">NBANDS</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>POSCAR</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">H2O</span> _2</span><br><span class="line"><span class="number">0.52918</span>   ! scaling parameter</span><br><span class="line"> <span class="number">12</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">12</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">12</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line">select</span><br><span class="line">cart</span><br><span class="line">      <span class="number">0.00</span>     <span class="number">0.00</span>     <span class="number">0.00</span> T T F</span><br><span class="line">      <span class="number">1.10</span>    -<span class="number">1.43</span>     <span class="number">0.00</span> T T F</span><br><span class="line">      <span class="number">1.10</span>     <span class="number">1.43</span>     <span class="number">0.00</span> T T F</span><br></pre></td></tr></table></figure>
<p>KPOINTS</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Gamma</span>-point only</span><br><span class="line"> <span class="number">1</span>        ! one k-point</span><br><span class="line">rec       ! <span class="keyword">in</span> units <span class="keyword">of</span> the reciprocal lattice vector</span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>  ! <span class="number">3</span> coordinates and weight</span><br></pre></td></tr></table></figure>
<p>模拟完成后将XDATCAR_toolkit.py上传到文件夹中（或者置于环境变量的路径文件夹中并赋予可执行权限即可直接调用命令XDATCAR_toolkit.py运行脚本），在shell环境中运行以下命令:</p>
<p><code>python XDATCAR_toolkit.py -p -t 0.5  --pbc</code><br>即可将XDATCAR的全部帧也就是0~499.5fs的轨迹转化成PDB格式。<strong>其中-p用于开启PDB转换功能，-t 0.5用于指定时间步为0.5fs，–pbc用于获取基于第一帧演变的连续轨迹。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Now reading vasp MD energies and temperature.</span><br><span class="line">Now reading vasp XDATCAR.</span><br><span class="line">Total frames 1000, NpT is False</span><br><span class="line">Finish reading XDATCAR.</span><br><span class="line">Selected time-range:0.0~499.5fs</span><br><span class="line">[debug] Now entering function plotfigure.....</span><br></pre></td></tr></table></figure>
<p>运行完成后，将会在文件夹内生成Temperature.dat，Energy.dat，ENERGY.png和XDATCAR.pdb四个文件，前面两个分别为温度和能量随着模拟时间的的变化数据，第三个是使用matplotlib绘制的趋势图（如下图），最后一个是转换得到的轨迹PDB文件，可以用于可视化轨迹，亦可用于后处理分析。</p>
<p>-b参数用于指定转换从哪一帧开始，-e参数用于指定转换到哪一帧结束。经刘锦程博士建议，增加一个–pbc的选项，用于处理周期性获取连续的轨迹。当分子穿过盒子边界时，记录真实的位置坐标（尽管它出了边界）而不是从盒子另一边穿入的ghost原子的坐标。这对于分析与时间相关性的量（比如RMSD）很有帮助。所谓连续指的是后面的轨迹都是从第一帧演变得到的真实坐标，但是并不能保证第一帧的分子是完整的，由于周期性的缘故，第一帧内摆放的分子可能分处于盒子两侧。李继存老师有篇博文(<a target="_blank" rel="noopener" href="http://jerkwin.github.io/2016/05/31/GROMACS%E8%BD%A8%E8%BF%B9%E5%91%A8%E6%9C%9F%E6%80%A7%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%A4%84%E7%90%86/)%E8%AE%B2%E7%9A%84%E5%BE%88%E6%98%8E%E7%99%BD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E3%80%82%E5%A6%82%E6%9E%9C%E5%8F%91%E7%8E%B0%E7%AC%AC%E4%B8%80%E5%B8%A7%E5%86%85%E5%88%86%E5%AD%90%E4%B8%8D%E5%AE%8C%E6%95%B4%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%B7%BB%E5%8A%A0%60-i">http://jerkwin.github.io/2016/05/31/GROMACS%E8%BD%A8%E8%BF%B9%E5%91%A8%E6%9C%9F%E6%80%A7%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%A4%84%E7%90%86/)讲的很明白，可以参考。如果发现第一帧内分子不完整，可以通过添加`-i</a> 1参数将分子向第一个原子靠近平移以获得完整的分子。如果发现不理想，可以通过调整-i&#96;的参数获得完整的分子。</p>
<p>图2. 温度和系统能量的变化趋势图<br>RDF径向分布函数分析</p>
<p>得到PDB文件后，可以使用VMD，MD Analysis等分子动力学后处理软件进行分析。</p>
<h3 id="使用VMD分析工具分析"><a href="#使用VMD分析工具分析" class="headerlink" title="使用VMD分析工具分析"></a>使用VMD分析工具分析</h3><p>打开VMD，将PDB文件拖入显示窗口，在主菜单VMD Main中选择</p>
<p>Extensions-Analysis-Radial Pair Distribution Function g(r)，选择分析H(type H)在O(type O)周围的概率分布。值得注意的是分析RDF时,横坐标也就是max r不能超过盒子最小边长的一半，也就是得满足最小映像约定。如图4所示，在计算RDF时，如果max r的取值大于盒子最小边长的一半，就有可能重复算到一个粒子和它的映像粒子，这使得程序的周期性判断失准。将生成的dat文件的第一列和第二列作图即可得到RDF图。</p>
<p>图3. VMD中计算RDF</p>
<p>图4. 最小映像约定示意图</p>
<h3 id="使用-MD-Analysis分析-RDF"><a href="#使用-MD-Analysis分析-RDF" class="headerlink" title="使用 MD Analysis分析 RDF"></a>使用 MD Analysis分析 RDF</h3><p>MD Analysis是一个成熟的分子动力学后处理软件，使用Python编写，开源。其教程不仅步骤详细还会给出背景理论知识。可以通过conda或者pip工具在线安装。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels conda-forge</span><br><span class="line">conda install mdanalysis</span><br><span class="line">#or</span><br><span class="line">pip install --upgrade MDAnalysis</span><br></pre></td></tr></table></figure>

<p>RDF分析的介绍和使用方法在网页(<a target="_blank" rel="noopener" href="https://www.mdanalysis.org/docs/documentation_pages/analysis/rdf.html#radial-distribution-functions-mdanalysis-analysis-rdf)%E4%B8%8A%E6%9F%A5%E7%9C%8B%E3%80%82%E4%BD%BF%E7%94%A8%E4%BB%A5%E4%B8%8B%E7%9A%84%E8%84%9A%E6%9C%AC%E5%BE%97%E5%88%B0%E5%9C%A8O%E5%8E%9F%E5%AD%90%E5%91%A8%E5%9B%B4%E6%89%BE%E5%88%B0H%E5%8E%9F%E5%AD%90%E7%9A%84%E6%A6%82%E7%8E%87%EF%BC%8C%E5%B9%B6%E8%B0%83%E7%94%A8%60matplotlib%60%E7%BB%98%E5%88%B6RDF%E5%9B%BE%E3%80%82%E5%9C%A81.0">https://www.mdanalysis.org/docs/documentation_pages/analysis/rdf.html#radial-distribution-functions-mdanalysis-analysis-rdf)上查看。使用以下的脚本得到在O原子周围找到H原子的概率，并调用`matplotlib`绘制RDF图。在1.0</a> Å<br> 处出现一个尖峰，也就是对应了O-H键的平衡键长（0.96$Å$）。</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MDAnalysis</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MDAnalysis</span>.<span class="property">analysis</span>.<span class="property">rdf</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.<span class="property">pyplot</span> <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">u = <span class="title class_">MDAnalysis</span>.<span class="title class_">Universe</span>(<span class="string">&#x27;XDATCAR.pdb&#x27;</span>, permissive=<span class="title class_">True</span>)</span><br><span class="line">g1= u.<span class="title function_">select_atoms</span>(<span class="string">&#x27;type O&#x27;</span>)</span><br><span class="line">g2= u.<span class="title function_">select_atoms</span>(<span class="string">&#x27;type H&#x27;</span>)</span><br><span class="line">rdf = <span class="title class_">MDAnalysis</span>.<span class="property">analysis</span>.<span class="property">rdf</span>.<span class="title class_">InterRDF</span>(g1,g2,nbins=<span class="number">75</span>, range=(<span class="number">0.0</span>, <span class="title function_">min</span>(u.<span class="property">dimensions</span>[:<span class="number">3</span>])/<span class="number">2.0</span>))</span><br><span class="line">           </span><br><span class="line">rdf.<span class="title function_">run</span>()</span><br><span class="line"></span><br><span class="line">fig = plt.<span class="title function_">figure</span>(figsize=(<span class="number">5</span>,<span class="number">4</span>))</span><br><span class="line">ax = fig.<span class="title function_">add_subplot</span>(<span class="number">111</span>)</span><br><span class="line">ax.<span class="title function_">plot</span>(rdf.<span class="property">bins</span>, rdf.<span class="property">rdf</span>, <span class="string">&#x27;k-&#x27;</span>,  label=<span class="string">&quot;rdf&quot;</span>)</span><br><span class="line"></span><br><span class="line">ax.<span class="title function_">legend</span>(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">ax.<span class="title function_">set_xlabel</span>(r<span class="string">&quot;Distance ($\AA$)&quot;</span>)</span><br><span class="line">ax.<span class="title function_">set_ylabel</span>(r<span class="string">&quot;RDF&quot;</span>)</span><br><span class="line">fig.<span class="title function_">savefig</span>(<span class="string">&quot;RDF_all.png&quot;</span>)</span><br><span class="line">#plt.<span class="title function_">show</span>()</span><br></pre></td></tr></table></figure>

<p>图5. RDF_O_H<br>RMSD均方根偏差分析</p>
<h3 id="VMD分析RMSD"><a href="#VMD分析RMSD" class="headerlink" title="VMD分析RMSD"></a>VMD分析RMSD</h3><p>确保使用了-pbc参数以获取连续的轨迹，将生成的XDATCAR.pdb文件拖入显示窗口。如图6右所示，第一帧内水的三个原子不在同一个镜像内，分子不完整。在进行RMSD分析时，尽管轨迹是连续的，但是在对齐分子时就会出现问题。因此在本例中需要选择第一个原子作为中心将分子平移完整，在图6左中，分子已经在同一个镜像中了。</p>
<p><code>python XDATCAR_toolkit.py -p -t 0.5  --pbc -i 1</code></p>
<p>图6. 完整和不完整的水分子<br>将重新生成的PDB文件拖入显示窗口，在主菜单VMD Main中选择Extensions-Analysis-Analysis-RMSD Trajectory Tool，在计算RMSD前必须先做Align（对齐），这会使得每一帧结构进行平移、旋转来与参考帧的结构尽可能贴近，从而使得RMSD最小化。刘锦程提到研究生物法分子的RMSD时需要对齐操作，而研究小分子时不需要对齐分子。</p>
<p>图7. VMD中计算RMSD</p>
<p>把左上角文本框里的默认的Protein改成all（代表所有原子都纳入考虑），然后把noh复选框的勾去掉（否则将忽略氢原子）。然后点右上角的ALIGN按钮，此时所有帧的结构就已经对齐了。本例中演示以模拟的第一帧为参考，分析氧原子位置的均方根偏差。因此在Reference mol那里选top作为参考结构，左上角文本框由all改为type O（代表计算O原子的RMSD），然后勾上Plot复选框，最后点击RMSD按钮即可得到O原子的RMSD图。在File菜单栏可以选择导出dat数据。</p>
<p>图8. VMD中未对齐轨迹计算的RMSD</p>
<p>图9. VMD中对齐了轨迹后计算的RMSD</p>
<h3 id="使用-MD-Analysis分析-RMSD"><a href="#使用-MD-Analysis分析-RMSD" class="headerlink" title="使用 MD Analysis分析 RMSD"></a>使用 MD Analysis分析 RMSD</h3><p>RMSD分析的介绍和使用方法在网页（<a target="_blank" rel="noopener" href="https://www.mdanalysis.org/docs/documentation_pages/analysis/rms.html?highlight=average%EF%BC%89%E4%B8%8A%E6%9F%A5%E7%9C%8B%E3%80%82">https://www.mdanalysis.org/docs/documentation_pages/analysis/rms.html?highlight=average）上查看。</a></p>
<p>使用以下的脚本可以分别得到所有原子，氢原子，氧原子的RMSD，并调用<code>matplotlib</code>绘制RMSD图。网页中有一段话（Note If you use trajectory data from simulations performed under periodic boundary conditions then you must make your molecules whole before performing RMSD calculations so that the centers of mass of the selected and reference structure are properly superimposed.）也就是在计算RMSD的时候选择的分子必须是完整的，不能分处于盒子的两边。这与我们之前的描述是一致的。MD Analysis默认对齐了分子。</p>
<p>使用以下脚本可以绘制对齐了轨迹后所有原子，氧原子和氢原子的RMSD。</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MDAnalysis</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MDAnalysis</span>.<span class="property">analysis</span>.<span class="property">rms</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.<span class="property">pyplot</span> <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">u = <span class="title class_">MDAnalysis</span>.<span class="title class_">Universe</span>(<span class="string">&#x27;XDATCAR.pdb&#x27;</span>, permissive=<span class="title class_">True</span>)</span><br><span class="line">ref = <span class="title class_">MDAnalysis</span>.<span class="title class_">Universe</span>(<span class="string">&#x27;XDATCAR.pdb&#x27;</span>, permissive=<span class="title class_">True</span>)     # reference (<span class="keyword">with</span> the <span class="keyword">default</span> ref_frame=<span class="number">0</span>)</span><br><span class="line">ref.<span class="property">trajectory</span>[<span class="number">0</span>] #use first frame <span class="keyword">as</span> reference</span><br><span class="line">R = <span class="title class_">MDAnalysis</span>.<span class="property">analysis</span>.<span class="property">rms</span>.<span class="title function_">RMSD</span>(u, ref,</span><br><span class="line">           select=<span class="string">&quot;all&quot;</span>,         # superimpose on whole backbone <span class="keyword">of</span> all atoms # align based on all atoms</span><br><span class="line">           groupselections=[<span class="string">&quot;type H&quot;</span>,<span class="string">&quot;type O&quot;</span>],</span><br><span class="line">           filename=<span class="string">&quot;rmsd_all.dat&quot;</span>,center=<span class="title class_">True</span>)#,   # <span class="variable constant_">CORE</span></span><br><span class="line">timestep=<span class="number">0.0005</span>  #<span class="number">0.</span>5fs <span class="keyword">from</span> fs to ps <span class="keyword">as</span> <span class="title class_">Reader</span> has no dt information, set to <span class="number">1.0</span> ps          </span><br><span class="line">R.<span class="title function_">run</span>()</span><br><span class="line">rmsd = R.<span class="property">rmsd</span>.<span class="property">T</span>   # transpose makes it easier <span class="keyword">for</span> plotting</span><br><span class="line">time = rmsd[<span class="number">1</span>]*timestep</span><br><span class="line"></span><br><span class="line">fig = plt.<span class="title function_">figure</span>(figsize=(<span class="number">5</span>,<span class="number">4</span>))</span><br><span class="line">ax = fig.<span class="title function_">add_subplot</span>(<span class="number">111</span>)</span><br><span class="line">ax.<span class="title function_">plot</span>(time, rmsd[<span class="number">2</span>], <span class="string">&#x27;k-&#x27;</span>,  label=<span class="string">&quot;all&quot;</span>)</span><br><span class="line">ax.<span class="title function_">plot</span>(time, rmsd[<span class="number">3</span>], <span class="string">&#x27;r--&#x27;</span>, label=<span class="string">&quot;type H&quot;</span>)</span><br><span class="line">ax.<span class="title function_">plot</span>(time, rmsd[<span class="number">4</span>], <span class="string">&#x27;b--&#x27;</span>, label=<span class="string">&quot;type O&quot;</span>)</span><br><span class="line">ax.<span class="title function_">legend</span>(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">ax.<span class="title function_">set_xlabel</span>(<span class="string">&quot;time (ps)&quot;</span>)</span><br><span class="line">ax.<span class="title function_">set_ylabel</span>(r<span class="string">&quot;RMSD ($\AA$)&quot;</span>)</span><br><span class="line">fig.<span class="title function_">savefig</span>(<span class="string">&quot;rmsd_md_analysis.png&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="应用python工具pymatgen，"><a href="#应用python工具pymatgen，" class="headerlink" title="应用python工具pymatgen，"></a>应用python工具pymatgen，</h1><p>可以直接得到MSD，diffusion，donductivity。</p>
<p><strong>得到XDATCAR后，需要首先配置pymatgen。</strong><br>需要用到conda命令，windows：可以安装anaconda3，通过spyder启动。<br>进入anaconda prompt中启动中断，配置conda environment:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create –name my_pymatgen python</span><br><span class="line">activate my_pymatgen</span><br></pre></td></tr></table></figure>

<p>linux环境下一个比较好的选择是安装miniconda3<br>wget <a target="_blank" rel="noopener" href="https://repo.anaconda.com/minico">https://repo.anaconda.com/minico</a> … -Windows-x86_64.exe</p>
<p><code>bash Miniconda3-latest-linux-x86_64.sh</code><br>如果原来在bashrc中配置了anaconda，则注释掉，重启terminal。<br>与windows下相同，需要设置一个pymatgen环境。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create –name my_pymatgen</span><br><span class="line">source activate my_pymatgen</span><br></pre></td></tr></table></figure>

<p><strong>在my_pymatgen环境下安装 pymatgen：</strong></p>
<p><code>conda install --channel conda-forge pymatgen</code></p>
<p><strong>安装好之后运行建立如下test.py脚本, 可以得到结果：</strong></p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pymatgen.<span class="property">core</span>.<span class="property">trajectory</span> <span class="keyword">import</span> <span class="title class_">Trajectory</span></span><br><span class="line"><span class="keyword">from</span> pymatgen.<span class="property">io</span>.<span class="property">vasp</span>.<span class="property">outputs</span> <span class="keyword">import</span> <span class="title class_">Xdatcar</span></span><br><span class="line"><span class="keyword">from</span> pymatgen <span class="keyword">import</span> <span class="title class_">Structure</span></span><br><span class="line"><span class="keyword">from</span> pymatgen.<span class="property">analysis</span>.<span class="property">diffusion_analyzer</span> <span class="keyword">import</span> <span class="title class_">DiffusionAnalyzer</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"># 这一步是读取 <span class="variable constant_">XDATCAR</span>，得到一系列结构信息</span><br><span class="line">traj = <span class="title class_">Trajectory</span>.<span class="title function_">from_file</span>(<span class="string">&#x27;XDATCAR&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># 这一步是实例化 <span class="title class_">DiffusionAnalyzer</span> 的类</span><br><span class="line"># 并用 from_structures 方法初始化这个类； <span class="number">300</span> 是温度，<span class="number">1</span>是<span class="variable constant_">POTIM</span> 的time step，<span class="number">1000</span>是间隔步数</span><br><span class="line"># 间隔步数（step_skip）不太容易理解，但是根据官方教程(这里具体怎么回事我不太清楚，好像potim*step_skip需要小于<span class="number">1000</span>，<span class="number">1000</span>为<span class="variable constant_">NSW</span>值，这是我没彻底弄清楚的地方):</span><br><span class="line"># dt = timesteps * self.<span class="property">time_step</span> * self.<span class="property">step_skip</span></span><br><span class="line"></span><br><span class="line">diff = <span class="title class_">DiffusionAnalyzer</span>.<span class="title function_">from_structures</span>(traj,<span class="string">&#x27;Li&#x27;</span>,<span class="number">300</span>,<span class="number">1</span>,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"># 可以用内置的 plot_msd 方法画出 <span class="variable constant_">MSD</span> 图像</span><br><span class="line"># 有些终端不能显示图像，这时候可以调用 <span class="title function_">export_msdt</span>() 方法，得到数据后再自己作图</span><br><span class="line">diff.<span class="title function_">plot_msd</span>()</span><br><span class="line">diff.<span class="title function_">export_msdt</span>(<span class="string">&quot;write_msd&quot;</span>)</span><br><span class="line"># 接下来直接得到 离子迁移率， 单位是 mS/cm，diffusity单位是 cm^<span class="number">2</span>/S</span><br><span class="line"></span><br><span class="line">C = diff.<span class="property">conductivity</span></span><br><span class="line">D = diff.<span class="property">diffusivity</span></span><br><span class="line"><span class="keyword">with</span> <span class="title function_">open</span>(<span class="string">&#x27;result.dat&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> <span class="attr">f</span>:</span><br><span class="line">    f.<span class="title function_">write</span>(<span class="string">&#x27;# AIMD result for Li-ion\n&#x27;</span>)</span><br><span class="line">    f.<span class="title function_">write</span>(<span class="string">&#x27;temp\conductivity\diffusivity\n&#x27;</span>)</span><br><span class="line">    f.<span class="title function_">write</span>(<span class="string">&#x27;%d\t%.2f  %.10f&#x27;</span> %(<span class="number">300</span>,C,D))</span><br></pre></td></tr></table></figure>

<p>在1.dat中是msd，conductivity和diffusivity会直接输出在result.dat中，模拟石墨烯表面Li的MD（excessive state）结果diffusivity为2*10-7 cm^2&#x2F;S，我觉得算出diffusivity后自己求conductivity比较好，请问应该怎么求？与文件对比，基本吻合（J. Phys. Chem. Lett. 2010, 1, 1176–1180；<a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/jp910134u%EF%BC%89%E3%80%82">https://pubs.acs.org/doi/10.1021/jp910134u）。</a><br>其它不对的地方，欢迎批评指正。<br>参考：<br><a target="_blank" rel="noopener" href="https://pymatgen.org/installation.html">https://pymatgen.org/installation.html</a><br><a target="_blank" rel="noopener" href="https://www.bigbrosci.com/2020/09/08/A18/">https://www.bigbrosci.com/2020/09/08/A18/</a></p>
<p><strong>VTST的脚本里有一个xdat2xyz.pl，可以直接把XDATCAR转化成movie.xyz文件。xdatcar可以通过ase转换成ms的xtd，也可以转ext-xyz，理论上支持xyz格式的程序也能打开。ase convert xdatcar xxx.xtd（注意会生成隐藏文件xxx.arc，如果要移动xtd，应该要使两个文件在相同的目录）。</strong></p>
<p>事实上，有xtd格式的话，如果你有MS的版权，有些针对xtd格式的分析其实可以直接在MS里面做。arc文件跟着xtd一块拷贝到相同目录。</p>
<h1 id="离子的电导率"><a href="#离子的电导率" class="headerlink" title="离子的电导率"></a>离子的电导率</h1><p>Pymatgen 是 python materials genomics 的缩写，它是一款基于 python 的、开源的、强大的材料分析软件（<a target="_blank" rel="noopener" href="https://pymatgen.org/%EF%BC%89%E3%80%82">https://pymatgen.org/）。</a></p>
<p>Pymatgen 包含一系列能够表示元素（Element）、位点（Site）、分子（Molecule）、和结构（Structure）的类（Class）。它具有为很多计算软件提供前处理和后处理的能力。这些计算软件包括VASP，ABINIT，exciting，FEFF，QCHEM，LAMMPS，ADF，AIIDA，ASE，Gaussian，Lobster，Phonopy，Shengbte，Pwscf，和Zeo++等等。它能实现科研狗的众多后处理需求，包括生成相图（Phase diagram）和布拜图（Pourbaix diagrams），分析态密度和能带等等。</p>
<p>Pymatgen 还提供了很多数据库（Materials Project REST API，Crystallography Open Database，and other external data sources）的接口，方便大家从数据库中查询结构和其他数据。</p>
<p>以下是Pymatgen官网提供的后处理的例子：</p>
<p>Top: (left) Phase and (right) Pourbaix diagram from the Materials API. Bottom left: Calculated bandstructure plot using pymatgen’s parsing and plotting utilities. Bottom right: Arrhenius plot using pymatgen’s DiffusionAnalyzer.</p>
<p><strong>本文就介绍一下如何使用 Pymatgen 的 DiffusionAnalyzer 类去计算锂离子固态电解质中锂离子电导率。</strong></p>
<h3 id="计算离子电导率的理论与公式"><a href="#计算离子电导率的理论与公式" class="headerlink" title="计算离子电导率的理论与公式"></a>计算离子电导率的理论与公式</h3><p>目前，比较准确的计算离子电导率的方法是先用NVT系综第一性原理分子动力学（AIMD，ab initio molecular dynamics）模拟材料中离子在不同温度下的运动，然后计算出离子的平均（average）均方位移（MSD，mean square displacement），再计算出自扩散系数（D<br>，self-diffusion coefficient），最后求得离子在某温度下的电导率（<br>，conductivity）。</p>
<h3 id="如何进行AIMD计算"><a href="#如何进行AIMD计算" class="headerlink" title="如何进行AIMD计算"></a>如何进行AIMD计算</h3><p>AIMD计算通常非常耗时，所以，为了减少计算成本，我们可以适当放宽计算精度。如果用 VASP 进行计算，具体的，大家可以</p>
<p>采用较小的截断能。氧化物用 400 eV，硫化物用 280 eV，硒化物用 270 eV<br>采用Gamma点作为K点设置，并使用gam版本的 VASP 进行计算<br>采用单胞计算，如果材料的单胞包含比较多的原子<br>采用合适的步长，比如2 fs，即 POTIM &#x3D; 2<br>后处理的基本公式<br>一旦AIMD计算完成，大家就可以着手计算离子电导率了。本文首先先介绍以下计算过程中使用的公式，方便有兴趣的同学自己开发脚本。</p>
<h3 id="平均均方位移（average-MSD）可以通过以下公式计算："><a href="#平均均方位移（average-MSD）可以通过以下公式计算：" class="headerlink" title="平均均方位移（average MSD）可以通过以下公式计算："></a>平均均方位移（average MSD）可以通过以下公式计算：</h3><p> 是第<br> 个离子在<br> 时刻的位移。</p>
<p>自扩散系数（<br>）可以通过以下公式计算：</p>
<p> 是离子在材料中的扩散维度（一般地，<br>），<br> 是离子扩散的时间。</p>
<p>最后，离子电导率（<br>）可以这样计算：</p>
<p> 是材料中的离子密度，<br> 是元电荷，<br> 是离子的价态，<br> 是玻尔兹曼常数，<br> 是温度。</p>
<p>电导率计算的例子<br>现在我们通过一个 Li_Sn_S 材料的例子来详细了解一下整个计算和处理的过程。该材料的结构显示如下：</p>
<p>本例中采用单胞做计算，INCAR 设置如下：</p>
<p>[test@ln0%tianhe2 li_sn_s]$ vi INCAR</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ISTART = 0</span><br><span class="line">ICHARG = 2</span><br><span class="line">IBRION = 0</span><br><span class="line">ISIF = 2</span><br><span class="line">NPAR = 8</span><br><span class="line">NSW = 30000</span><br><span class="line">TEBEG = 900 #还要设置成 1500K 等等</span><br><span class="line">PREC = N</span><br><span class="line">POTIM = 2</span><br><span class="line">SMASS = 0.0</span><br><span class="line">NELMIN = 4</span><br><span class="line">LWAVE = F</span><br><span class="line">LCHARG = F</span><br><span class="line">IALGO = 48</span><br><span class="line">LREAL = A</span><br></pre></td></tr></table></figure>
<p>AIMD 计算结束之后会得到 XDATCAR 文件。很多时候，由于超算的时间限制，一个完整的AIMD计算需要提交两三次，从而产生两三个 XDATCAR 文件，这时，我们只要把它们按顺序通过 cat 命令合并在一起就行。例如我们有三个 XDATCAR 文件，分别命名成 XDATCAR01，XDATCAR02，和 XDATCAR03。</p>
<p><code>[test@ln0%tianhe2 li_sn_s]$ cat XDATCAR01 XDATCAR02 XDATCAR03 &gt; XDATCAR </code><br>新得到的XDATCAR文件，注意删掉重复的与晶格信息相关的行，一般续算的次数也不多，在使用上面命令的时候，手动把XDATCAR02, XDATCAR03 中的删除即可。</p>
<p>Pymatgen 大显身手<br>安装pymatgen<br>首先让我们安装 pyamtgen，推荐大家参考官网，使用 anaconda 安装，否则会出现问题。安装好了anaconda之后，不管是 linux 还是 windows, 安装 pyamtgen 的指令是一样的。下面以吕梁天河超算为例：</p>
<p>[test@ln0%tianhe2 li_sn_s]$ conda install –channel conda-forge pymatgen<br>安装完成后，我们可以试着运行 python，导入 Pyamtgen 模块，如果像下面一样没有出错，就是安装成功了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[test@ln0%tianhe2 li_sn_s]$ python</span><br><span class="line">Python 3.7.3 (default, Mar 27 2019, 22:11:17) </span><br><span class="line">[GCC 7.3.0] :: Anaconda, Inc. on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import pymatgen</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure>
<p>查看 DiffusionAnalyzer 的类<br>大家可以通过官方文档（<a target="_blank" rel="noopener" href="https://pymatgen.org/pymatgen.analysis.diffusion_analyzer.html%EF%BC%89%E6%9F%A5%E7%9C%8B%E6%8E%A5%E4%B8%8B%E6%9D%A5%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B1%BB%EF%BC%8C%E7%86%9F%E6%82%89%E4%B8%80%E4%B8%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E7%94%A8%E6%B3%95%E3%80%82">https://pymatgen.org/pymatgen.analysis.diffusion_analyzer.html）查看接下来要使用的类，熟悉一下代码的用法。</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class DiffusionAnalyzer(MSONable):</span><br><span class="line">    def __init__(self, structure, displacements, specie, temperature,</span><br><span class="line">                 time_step, step_skip, smoothed=&quot;max&quot;, min_obs=30,</span><br><span class="line">                 avg_nsteps=1000, lattices=None):</span><br></pre></td></tr></table></figure>
<p>这段代码显示，运行这个类需要一系列的输入信息，包括材料结构（structure），位移（displacements），要研究的离子（specie），温度（temperature）等等。</p>
<p>但是这个类提供了很多方法让大家可以通过读取 XDATCAR 或者 vasprun 文件的方式来实例化，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@classmethod</span><br><span class="line">    def from_structures(cls, structures, specie, temperature,</span><br><span class="line">                        time_step, step_skip, initial_disp=None,</span><br><span class="line">                        initial_structure=None, **kwargs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Convenient constructor that takes in a list of Structure objects to</span><br><span class="line">        perform diffusion analysis.</span><br><span class="line">        Args:</span><br><span class="line">            structures ([Structure]): list of Structure objects (must be</span><br><span class="line">                ordered in sequence of run). E.g., you may have performed</span><br><span class="line">                sequential VASP runs to obtain sufficient statistics.</span><br><span class="line">        ... ...</span><br><span class="line">        &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>好了，废话不多说，直接上代码，开始进行后处理。</p>
<p>代码示例<br>新建一个文件，名字为li_conductivity.py</p>
<p>‘’’<br>分析AIMD结果，计算MSD 和 conductivity<br>‘’’</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">from pymatgen.core.trajectory import Trajectory</span><br><span class="line">from pymatgen.io.vasp.outputs import Xdatcar</span><br><span class="line">from pymatgen import Structure</span><br><span class="line">from pymatgen.analysis.diffusion_analyzer import DiffusionAnalyzer</span><br><span class="line">import numpy as np</span><br><span class="line">import pickle</span><br><span class="line"></span><br><span class="line"># 这一步是读取 XDATCAR，得到一系列结构信息</span><br><span class="line">traj = Trajectory.from_file(&#x27;XDATCAR&#x27;)</span><br><span class="line"></span><br><span class="line"># 这一步是实例化 DiffusionAnalyzer 的类</span><br><span class="line"># 并用 from_structures 方法初始化这个类； 900 是温度，2 是POTIM 的值，1是间隔步数</span><br><span class="line"># 间隔步数（step_skip）不太容易理解，但是根据官方教程:</span><br><span class="line"># dt = timesteps * self.time_step * self.step_skip</span><br><span class="line"></span><br><span class="line">diff = DiffusionAnalyzer.from_structures(traj,&#x27;Li&#x27;,900,2,1)</span><br><span class="line"></span><br><span class="line"># 可以用内置的 plot_msd 方法画出 MSD 图像</span><br><span class="line"># 有些终端不能显示图像，这时候可以调用 export_msdt() 方法，得到数据后再自己作图</span><br><span class="line">diff.plot_msd()</span><br><span class="line"></span><br><span class="line"># 接下来直接得到 离子迁移率， 单位是 mS/cm</span><br><span class="line">C = diff.conductivity</span><br><span class="line"></span><br><span class="line">with open(&#x27;result.dat&#x27;,&#x27;w&#x27;) as f:</span><br><span class="line">    f.write(&#x27;# AIMD result for Li-ion\n&#x27;)</span><br><span class="line">    f.write(&#x27;temp\tconductivity\n&#x27;)</span><br><span class="line">    f.write(&#x27;%d\t%.2f\n&#x27; %(900,C))</span><br></pre></td></tr></table></figure>
<p>在终端运行该文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[test@ln0%tianhe2 li_sn_s]$ python li_conductivity.py</span><br></pre></td></tr></table></figure>
<p>一段时间后就会得到MSD图像和离子电导率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[test@ln0%tianhe2 li_sn_s]$ vi result.dat</span><br><span class="line"></span><br><span class="line"># AIMD result for Li-ion</span><br><span class="line">temp	conductivity</span><br><span class="line">900	884.05</span><br></pre></td></tr></table></figure>
<p>可见，该材料在 900K 时的锂离子电导率为 884.05 mS&#x2F;cm。</p>
<p>例子下载：<br>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1WGzOVJBoe6Ym8mvR1uWanA">https://pan.baidu.com/s/1WGzOVJBoe6Ym8mvR1uWanA</a><br>提取码：jhc5</p>
<p>思考<br>简短几行代码就可以计算出离子电导率，那么如何得出材料在300K下的电导率呢？<br>如何计算离子在材料中的迁移势垒？<br>如何可视化离子在材料中的扩散路径？</p>
<h1 id="如何使用-Pymatgen-可视化离子的迁移概率密度。"><a href="#如何使用-Pymatgen-可视化离子的迁移概率密度。" class="headerlink" title="如何使用 Pymatgen 可视化离子的迁移概率密度。"></a>如何使用 Pymatgen 可视化离子的迁移概率密度。</h1><p>先举个例子，</p>
<p>在“Design principles for solid-state lithium superionic conductors”一文中（Wang et al., Nature Materials 2015, 14 , 1026–1031. ），作者用Ab Initio Molecular Dynamic （AIMD）计算了Li 离子在Li$\mathrm{_1}\mathrm{_2}，<br>\mathrm{_7}<br>\mathrm{_3}<br>\mathrm{_1}$$\mathrm{_1}，<br>\mathrm{_2}，和<br>\mathrm{_4}<br>\mathrm{_4}$ 四种材料中的迁移概率密度（Probability Density），结果如下图所示：</p>
<p>从图中可以看出Li离子在图a所示材料中主要沿c轴方向的通道迁移，而且由于这个通道连通得比较好，Li离子的迁移势垒会比较低（0.22<del>0.25 eV）。<br>Li离子在图b所示的材料的迁移路径形成了一个三维网格，而且由于这个概率密度比图b中的概率密度分布得更加均匀，Li离子的迁移势垒更低（0.18</del>0.19 eV）。<br>图b所示的材料就完全不行了，因为Li离子的概率密度仅分布在特定的位点附近，说明离子不能有效地移动。<br>Li离子在图d所示材料中也存在迁移局域化的行为。<br>作者总结说 “A general principle for the design of Li-ion conductors with low activation energy can be distilled from the above findings: all of the sites within the diffusion network should be energetically close to equivalent, with large channels connecting them.”<br>那么我们如何在自己的计算中画出这样的图呢？Pymatgen 举手说，它可以帮忙！</p>
<p>但是在开始之前，我们要安装Pymatgen的插件：Pymatgen-diffusion（<a target="_blank" rel="noopener" href="https://github.com/materialsvirtuallab/pymatgen-diffusion%EF%BC%89%E3%80%82">https://github.com/materialsvirtuallab/pymatgen-diffusion）。</a></p>
<p>安装 Pymatgen-diffusion<br>推荐大家使用最新版的Anaconda安装Pymatgen及其插件。点击上面的链接，进入官网后，点击最新版本链接，</p>
<p>我们可以下载.zip文件，</p>
<p>下载完成后，大家可以解压这个文件，得到 pymatgen-diffusion-2019.8.18文件夹。</p>
<p>我们把其中的 pymatgen_diffusion 文件夹放到 Anaconda的site-packages文件夹下，路径是 Windows 系统：……\Anaconda\Lib\site-packages；Linux系统：……&#x2F;anaconda3&#x2F;lib&#x2F;pythonx.x&#x2F;site-packages，就算安装好了。</p>
<p>接下来我们可以启动python，导入这个模块，如果不报错就没有问题了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[test@ln0%tianhe2 li_sn_s]$ python</span><br><span class="line">Python 3.8.3 (default, Jul  2 2020, 16:21:59) </span><br><span class="line">[GCC 7.3.0] :: Anaconda, Inc. on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import pymatgen_diffusion</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure>
<p>学习用法<br>我们可以在其github网站上通过例子学习这个模块的用法。</p>
<p>点击打开 probbility_analysis.ipynb 文件。</p>
<p>其内容如下（有所删减）：如果不想看的话可直接查看 开始作图 部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pymatgen.analysis.diffusion_analyzer import DiffusionAnalyzer</span><br><span class="line">from pymatgen_diffusion.aimd.pathway import ProbabilityDensityAnalysis</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">#ProbabilityDensityAnalysis object</span><br><span class="line">filename=&quot;/Users/iekhengchu/repos/pymatgen-diffusion/pymatgen_diffusion/aimd/tests/cNa3PS4_pda.json&quot;</span><br><span class="line"></span><br><span class="line">data = json.load(open(&quot;../pymatgen_diffusion/aimd/tests/cNa3PS4_pda.json&quot;, &quot;r&quot;))</span><br><span class="line">diff_analyzer = DiffusionAnalyzer.from_dict(data) # 初始化DiffusionAnalyzer类</span><br><span class="line"></span><br><span class="line">pda = ProbabilityDensityAnalysis.from_diffusion_analyzer(diff_analyzer, interval=0.5, </span><br><span class="line">                                                         species=(&quot;Na&quot;, &quot;Li&quot;)) #可以指定离子</span><br><span class="line">#Save probability distribution to a CHGCAR-like file</span><br><span class="line">pda.to_chgcar(filename=&quot;CHGCAR_new2.vasp&quot;) #保存概率密度文件</span><br></pre></td></tr></table></figure>
<p>开始作图<br>代码（test.py）如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pymatgen_diffusion.aimd.pathway import ProbabilityDensityAnalysis</span><br><span class="line">from pymatgen.core.trajectory import Trajectory</span><br><span class="line">from pymatgen.io.vasp.outputs import Xdatcar</span><br><span class="line">from pymatgen.analysis.diffusion_analyzer import DiffusionAnalyzer</span><br><span class="line"></span><br><span class="line">traj = Trajectory.from_file(&#x27;XDATCAR&#x27;)</span><br><span class="line">diff = DiffusionAnalyzer.from_structures(traj,&#x27;Li&#x27;,900,2,1)</span><br><span class="line">pda = ProbabilityDensityAnalysis.from_diffusion_analyzer(diff,interval=0.5,species=(&quot;Li&quot;))</span><br><span class="line">pda.to_chgcar(filename=&quot;pda.vasp&quot;) #保存概率密度文件</span><br></pre></td></tr></table></figure>
<p>此处理过程大概耗时8分钟，因机器而异。</p>
<p>在VESTA中可视化</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/11/18-47-24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/11/18-47-24/" class="post-title-link" itemprop="url">4.2 光学性质</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-11 18:47:24" itemprop="dateCreated datePublished" datetime="2023-05-11T18:47:24+08:00">2023-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-26 19:54:58" itemprop="dateModified" datetime="2023-12-26T19:54:58+08:00">2023-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="介电常数"><a href="#介电常数" class="headerlink" title="介电常数"></a>介电常数</h1><p>首先进行结构优化,参考官网： <a target="_blank" rel="noopener" href="https://www.vasp.at/wiki/index.php/Dielectric_properties_of_SiC">https://www.vasp.at/wiki/index.php/Dielectric_properties_of_SiC</a></p>
<h3 id="静态介电常数："><a href="#静态介电常数：" class="headerlink" title="静态介电常数："></a>静态介电常数：</h3><p>方法1：DFPT方法;<br> <figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">IBRION</span> = <span class="number">8</span></span><br><span class="line"><span class="variable constant_">NSW</span>=<span class="number">1</span></span><br><span class="line"><span class="variable constant_">LEPSILON</span> = .<span class="property">TRUE</span>.</span><br><span class="line"><span class="variable constant_">LRPA</span>=.<span class="property">TRUE</span>.#<span class="variable constant_">RPA</span>考虑局域场效应，默认关闭，即<span class="variable constant_">IP</span>近似</span><br><span class="line"><span class="variable constant_">LPEAD</span>=.<span class="property">TRUE</span>.#有限差分法</span><br></pre></td></tr></table></figure><br>方法2：Response to finite electric fields</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">LCALCEPS</span> = .<span class="property">TRUE</span>.</span><br><span class="line"><span class="variable constant_">IBRION</span>=<span class="number">6</span></span><br><span class="line"><span class="variable constant_">NFREE</span>=<span class="number">2</span></span><br><span class="line"><span class="variable constant_">ISMEAR</span> =  <span class="number">0</span></span><br><span class="line"><span class="variable constant_">SIGMA</span>  =  <span class="number">0.01</span></span><br></pre></td></tr></table></figure>
<p> 在OUTCAR中抓取：</p>
<figure class="highlight plaintext"><figcaption><span>STATIC DIELECTRIC TENSOR (including local field effects in DFT)``` 电子贡献或者</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">```MACROSCOPIC STATIC DIELECTRIC TENSOR (including local field effects in RPA (Hartree))```</span><br><span class="line">```MACROSCOPIC STATIC DIELECTRIC TENSOR IONIC CONTRIBUTION``` 离子贡献</span><br><span class="line">```BORN EFFECTIVE CHARGES (in e, cummulative output)```</span><br><span class="line">```ELASTIC MODULI IONIC CONTR (kBar)```</span><br><span class="line">```PIEZOELECTRIC TENSOR IONIC CONTR  for field in x, y, z        (C/m^2)```</span><br><span class="line">### 频率依赖介电函数：读取WAVECAR</span><br><span class="line">IPA：</span><br><span class="line"> ```javascript  &#123;.line-numbers&#125;</span><br><span class="line"> ALGO = Exact</span><br><span class="line"> NBANDS  = 64</span><br><span class="line"> LOPTICS = .TRUE. </span><br><span class="line"> CSHIFT = 0.100</span><br><span class="line"> NEDOS = 2000  </span><br><span class="line"> #and you might try with the following</span><br><span class="line"> #LPEAD = .TRUE.</span><br></pre></td></tr></table></figure>

<p><code>frequency dependent IMAGINARY DIELECTRIC FUNCTION (independent particle, no local field effects)</code><br>and<br><code>frequency dependent      REAL DIELECTRIC FUNCTION (independent particle, no local field effects)</code></p>
<p>Note：对于光学性质的计算，也就是计算材料的介电函数，需要足够多的空带和致密的K网格点，使其达到非常好的收敛状态，我们才可以得到合理的光学性质；因此通常计算中，一般设置NBANDS为默认值（可在自洽的OUTCAR中以关键字NBANDS查找到）的2-3倍，K网格点为自洽值或适当增加。<br>使用optics.sh脚本得到介电函数的实部和虚部</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># extract image and real parts <span class="keyword">of</span> dielectric <span class="keyword">function</span> <span class="keyword">from</span> vasprun.<span class="property">xml</span></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;i=1&#125; /&lt;imag&gt;/,\</span></span><br><span class="line"><span class="string">               /&lt;\/imag&gt;/ \</span></span><br><span class="line"><span class="string">                &#123;a[i]=$2 ; b[i]=$3 ; c[i]=$4; d[i]=$5 ; e[i]=$6 ; f[i]=$7; g[i]=$8; i=i+1&#125; \</span></span><br><span class="line"><span class="string">    END&#123;for (j=12;j&lt;i-3;j++) print a[j],b[j],c[j],d[j],e[j],f[j],g[j]&#125;&#x27;</span> vasprun.<span class="property">xml</span> &gt; <span class="variable constant_">IMAG</span>.<span class="property">in</span></span><br><span class="line">#awk <span class="string">&#x27;BEGIN&#123;i=1&#125; /imag/,\</span></span><br><span class="line"><span class="string">#                /\/imag/ \</span></span><br><span class="line"><span class="string">#                 &#123;a[i]=$2 ; b[i]=$3 ; c[i]=$4; d[i]=$5 ; e[i]=$6 ; f[i]=$7; g[i]=$8; i=i+1&#125; \</span></span><br><span class="line"><span class="string">#     END&#123;for (j=12;j&lt;i-3;j++) print a[j],b[j],c[j],d[j],e[j],f[j],g[j]&#125;&#x27;</span> vasprun.<span class="property">xml</span> &gt; <span class="variable constant_">IMAG</span>.<span class="property">in</span></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;i=1&#125; /&lt;real&gt;/,\</span></span><br><span class="line"><span class="string">               /&lt;\/real&gt;/ \</span></span><br><span class="line"><span class="string">                &#123;a[i]=$2 ; b[i]=$3 ; c[i]=$4; d[i]=$5 ; e[i]=$6 ; f[i]=$7; g[i]=$8; i=i+1&#125; \</span></span><br><span class="line"><span class="string">    END&#123;for (j=12;j&lt;i-3;j++) print a[j],b[j],c[j],d[j],e[j],f[j],g[j]&#125;&#x27;</span> vasprun.<span class="property">xml</span> &gt; <span class="variable constant_">REAL</span>.<span class="property">in</span></span><br></pre></td></tr></table></figure>
<p>vaspkit处理：<br><code>vaspkit-task 711  </code></p>
<h3 id="压电常数"><a href="#压电常数" class="headerlink" title="压电常数"></a>压电常数</h3><p>上面计算完介电常数后，一般正交晶系。<br><code>grep &quot;PIEZOELECTRIC TENSOR IONIC CONTR  for field in x, y, z        (C/m^2)&quot; OUTCAR  -A10 </code><br> &amp;<br><code>grep &quot;PIEZOELECTRIC TENSOR  for field in x, y, z        (C/m^2)&quot; OUTCAR -A10 </code></p>
<h1 id="极化强度"><a href="#极化强度" class="headerlink" title="极化强度"></a>极化强度</h1><ol>
<li>极化强度计算<br>首先选取极化相FE（PhaseB, P, 铁电相）和参考相NP（PhaseA, P&#x3D;0, 中心对称相），分别以下列INCAR计算，<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable constant_">SYSTEM</span> = <span class="variable constant_">FE</span></span><br><span class="line"> <span class="variable constant_">ENCUT</span> = <span class="number">600</span>  #铁电极化计算建议设置高精度</span><br><span class="line"> <span class="variable constant_">EDIFF</span> = <span class="number">1E-6</span></span><br><span class="line"> <span class="variable constant_">IBRION</span> = -<span class="number">1</span></span><br><span class="line"> <span class="variable constant_">POTIM</span> = <span class="number">0.3</span></span><br><span class="line"> <span class="variable constant_">NSW</span> = <span class="number">0</span></span><br><span class="line"> <span class="variable constant_">EDIFFG</span> = -<span class="number">5E-3</span></span><br><span class="line"> <span class="variable constant_">ISMEAR</span> = <span class="number">0</span></span><br><span class="line"> <span class="variable constant_">SIGMA</span> = <span class="number">0.05</span></span><br><span class="line"> <span class="variable constant_">PREC</span> = <span class="title class_">Accurate</span></span><br><span class="line"> <span class="variable constant_">ISIF</span> = <span class="number">2</span></span><br><span class="line"> #<span class="variable constant_">NPAR</span> = <span class="number">4</span></span><br><span class="line"><span class="variable constant_">LWAVE</span> = .<span class="property">FALSE</span>.</span><br><span class="line"><span class="variable constant_">LCHARG</span> = .<span class="property">FALSE</span>.</span><br><span class="line"><span class="variable constant_">LREAL</span> = .<span class="property">FALSE</span>. </span><br><span class="line"><span class="variable constant_">LDIPOL</span> = .<span class="property">T</span>.</span><br><span class="line"><span class="variable constant_">DIPOL</span> = <span class="number">0.2</span> <span class="number">0.2</span> <span class="number">0.2</span> #不要设置在原子及迁移路径上，设置在真空层的一边/质心</span><br><span class="line"><span class="variable constant_">LCALCPOL</span> = .<span class="property">TRUE</span>. #计算铁电极化开关 </span><br><span class="line"><span class="variable constant_">IPEAD</span>=<span class="number">4</span></span><br><span class="line"><span class="variable constant_">LPEAD</span>=.<span class="property">True</span>.</span><br></pre></td></tr></table></figure></li>
<li>收集结果：grep “Total electronic dipole momen” OUTCAR &amp; grep “Ionic dipole moment” OUTCAR，离子与电子相加即可，然后用NP相-铁电相即可得到极化强度P，注意单位换算。<br>首先要理清数据单位。VASP 计算得到的 dipole moment 的单位是 e*Å，它与库仑之间换算为:<br>$1e &#x3D;  1.602176634 * 10^{-19} C$<br>$1Å &#x3D; 10^{-10} m$<br>三维体系的极化强度： 极化值除以体积。单位为 $e&#x2F;Å^2$；二维体系的极化强度：极化值除以面积。单位为 e&#x2F;Å。</li>
</ol>
<h3 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h3><p>在铁电极化计算过程中经常会出现参考相为非半导体的情况，这种情况下可以：①镜像法：以FE以NP为参照中心，建立一个-FE相（PhaseB’, 即铁电极化方向相反）。然后按照上述方法计算极化，再以FE相的极化-（-FE相）的极化值，然后除以2即得到极化强度。可以理解为1-（-1）&#x3D;2，2&#x2F;2&#x3D;1；②线性插值法：在FE和NP相中间插入一系列中间过渡相（0%（FE）,10%,20%,30%….100%(NP)），计算它们的极化，然后可以用Origin做拟合，100%时即为NP相的极化。（100%-0%）则是极化强度P。</p>
<h2 id="线性插值法计算极化强度"><a href="#线性插值法计算极化强度" class="headerlink" title="线性插值法计算极化强度"></a>线性插值法计算极化强度</h2><p>原文链接:</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ghzhan/articles/16305679.html">https://www.cnblogs.com/ghzhan/articles/16305679.html</a></p>
<p>BaTiO3 是钙钛矿结构，它的铁电相结构和中心对称结构如图所示<img src="/gra/0401.png" alt="0401">，属于四方晶系。</p>
<ol>
<li><p>先构造 BaTiO3 两种极化方向的晶格结构，并用 VASP 进行结构优化得到 CONTCAR；</p>
</li>
<li><p>将上一步优化后的两个结构分别放入创建好的 ini, fin 文件夹。利用 NEB 的 nebmake.pl 命令产生这两种极化方向的中间过渡结构 (vtst下载地址: Download — Transition State Tools for VASP (utexas.edu))，具体命令为：</p>
<p> <code>nebmake.pl ini/CONTCAR fin/CONTCAR 32</code></p>
<p>这里的 ‘32’ 是表示产生中间过渡的 32 种结构。执行上述命令后，当前文件夹下会产生 00, 01, 02, …, 33 个文件夹，每个文件夹下有一个 POSCAR 文件。</p>
</li>
<li><p>对每个文件夹的结构进行一次 VASP 自洽运算，INCAR 文件里面需要额外设置 DIPOL 和 LCALPOL 参数。</p>
<p> DIPOL 参数可以选取任一坐标，但是保证同一体系采用相同值。 </p>
<p>LCALPOL 参数是打开 极化运算。</p>
<p>INCAR 文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SYSTEM=BaTiO3</span><br><span class="line">ISTART =0</span><br><span class="line">ICHARG =2</span><br><span class="line">PREC   =Accurate</span><br><span class="line">ENCUT  =520</span><br><span class="line">EDIFF  =0.1E-07</span><br><span class="line">ISMEAR = 0</span><br><span class="line">LWAVE=.FALSE.</span><br><span class="line">LCHARG = .FALSE.</span><br><span class="line">NELM = 200</span><br><span class="line">DIPOL = 0.5 0.5 0.5</span><br><span class="line">LCALCPOL=.TRUE</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算完成后运行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;dipole moment&#x27; OUTCAR|rev| awk &#x27;&#123;printf (&quot;%s &quot;, $4)&#125;&#x27;|rev|awk &#x27;&#123;printf (&quot;%f\n&quot;, $1+$2)&#125;&#x27; &gt;&gt; ../dipole_c.dat</span><br><span class="line"></span><br><span class="line">grep &#x27;free  energy   TOTEN&#x27; OUTCAR | awk &#x27;&#123;printf (&quot;%s\n&quot;,$5)&#125;&#x27; &gt;&gt; ../energy.dat</span><br></pre></td></tr></table></figure>
<p>这里通过 grep 命令产生的 dipole_c.dat 文件记录的是沿着 c 方向的极化值，这是因为 BaTiO3 是沿着 c 方向极化的。对于具体的情况需要自行修改。</p>
</li>
<li><p>处理和分析数据。</p>
<p>首先要理清数据单位。VASP 计算得到的 dipole moment 的单位是 e*Å，它与库仑之间换算为:</p>
<p> $1e &#x3D;  1.602176634 * 10^{-19} C$</p>
<p> $1Å &#x3D; 10^{-10} m$</p>
<p>三维体系的极化强度： 极化值除以体积。单位为 e&#x2F;Å2；二维体系的极化强度：极化值除以面积。单位为 e&#x2F;Å。</p>
<p>在这个例子中，BaTiO3 的体积为 64.3586 Å3。接下来，我们来处理数据。用energy.dat 文件 (单位为 eV)，这样，我们就得到每个中间结构 (image) 的总能：<img src="/gra/0402.png" alt="0402"><br>用dipole_c.dat 文件 (单位: e*Å):不同 image  的极化值如图所示<img src="/gra/0403.png" alt="0403"><br>可以发现，该极化强度不是连续的，这是和选取的原胞有关，需要考虑极化量子的影响。BaTiO3 沿着 c 方向极化，所以需要对该极化值加减整数倍的 c 方向的晶格常数。这样我们得到下图：<img src="/gra/0404.png" alt="0404"></p>
<p>选取最靠近中间极化强度为 0 的那条曲线，即为 BaTiO3 的极化强度曲线：<img src="/gra/0405.png" alt="0405"></p>
<p>除以体积并进行简单的单位换算后为:<img src="/gra/0406.png" alt="0406"><br>另外，我们也可以绘制极化值 P 与能量 E 曲线<img src="/gra/0407.png" alt="0407"><br>因此， BaTiO3 的极化强度大约为 0.248 C&#x2F;m2，与文献中的实验结果 0.26 C&#x2F;m2 吻合。（Physical Review, 99(4), 1161–1165, 1955 ）</p>
<p>拟合 Landau-Ginzburg 公式</p>
<p>$E&#x3D; \sum_{i} A&#x2F;2 * P_i^2 + B&#x2F;4 * P_i^4 + C&#x2F;6 * P_i^6 + D&#x2F;2 * \sum_{i,j}(P_i-P_j)^2$</p>
</li>
</ol>
<p>  拟合该多项式曲线，得到</p>
<p>   $E &#x3D; 6062.434883706029<em>P^6   +  2437.756598493882</em>P^4  +  -340.5806845162749*P^2   +  10.339600058315137$<br>   其中参数 A, B,  C 分别为</p>
<p>   $A &#x3D; -0.68116 eV *(m^2&#x2F;C)^2<br>   B &#x3D;  9.75103  eV *(m^2&#x2F;C)^4<br>   C &#x3D; 36.37461  eV *(m^2&#x2F;C)^6$<br>   <img src="/gra/0408.png" alt="0408"></p>
<ol start="6">
<li>绘制能量曲线的脚本<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="title function_">open</span>(<span class="string">&#x27;energy.dat&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> <span class="attr">f</span>:</span><br><span class="line">    content = f.<span class="title function_">readlines</span>()</span><br><span class="line">res = [<span class="title function_">float</span>(i.<span class="title function_">strip</span>(<span class="string">&#x27;\n&#x27;</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> content]</span><br><span class="line">minres = <span class="title function_">min</span>(res)</span><br><span class="line">res = [<span class="number">1e3</span>*(i-minres) <span class="keyword">for</span> i <span class="keyword">in</span> res]</span><br><span class="line"><span class="keyword">import</span> matplotlib.<span class="property">pyplot</span> <span class="keyword">as</span> plt</span><br><span class="line">plt.<span class="title function_">figure</span>()</span><br><span class="line">plt.<span class="title function_">plot</span>(res,<span class="string">&#x27;b.-&#x27;</span>)</span><br><span class="line">plt.<span class="title function_">xlabel</span>(<span class="string">&#x27;displacement&#x27;</span>)</span><br><span class="line">plt.<span class="title function_">ylabel</span>(<span class="string">&#x27;Energy ($meV$)&#x27;</span>)</span><br><span class="line">plt.<span class="title function_">show</span>()</span><br></pre></td></tr></table></figure></li>
</ol>
<p>绘制dipole曲线，以及考虑极化量子的脚本:</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="title function_">open</span>(<span class="string">&#x27;dipole_c.dat&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> <span class="attr">f</span>:</span><br><span class="line">    content = f.<span class="title function_">readlines</span>()</span><br><span class="line">res = [<span class="title function_">float</span>(i.<span class="title function_">strip</span>(<span class="string">&#x27;\n&#x27;</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> content]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.<span class="property">pyplot</span> <span class="keyword">as</span> plt</span><br><span class="line">plt.<span class="title function_">figure</span>()</span><br><span class="line">plt.<span class="title function_">xlabel</span>(<span class="string">&#x27;displacement&#x27;</span>)</span><br><span class="line">plt.<span class="title function_">ylabel</span>(<span class="string">&#x27;Polarization ($e*&#123;\AA&#125;$)&#x27;</span>)</span><br><span class="line">plt.<span class="title function_">xlim</span>([<span class="number">0</span>,<span class="number">32</span>])</span><br><span class="line">plt.<span class="title function_">plot</span>(res,<span class="string">&#x27;r.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 考虑极化量子</span><br><span class="line">c = <span class="number">4.0335000000000001</span></span><br><span class="line">tmp = []</span><br><span class="line">N = <span class="number">20</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="title function_">range</span>(N):</span><br><span class="line">    start = -N/<span class="number">2</span>+j</span><br><span class="line">    tmp1 = [i+start*c <span class="keyword">for</span> i <span class="keyword">in</span> res]</span><br><span class="line">    # <span class="title function_">print</span>(tmp1[<span class="number">0</span>])</span><br><span class="line">    tmp.<span class="title function_">append</span>(tmp1)</span><br><span class="line">plt.<span class="title function_">figure</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="attr">tmp</span>:</span><br><span class="line">    plt.<span class="title function_">plot</span>(i,<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">#plt.<span class="title function_">ylim</span>([-<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line">plt.<span class="title function_">xlabel</span>(<span class="string">&#x27;displacement&#x27;</span>)</span><br><span class="line">plt.<span class="title function_">ylabel</span>(<span class="string">&#x27;Polarization ($e*&#123;\AA&#125;$)&#x27;</span>)</span><br><span class="line">plt.<span class="title function_">xlim</span>([<span class="number">0</span>,<span class="number">32</span>])</span><br><span class="line"></span><br><span class="line">### 单位换算</span><br><span class="line">P = [-<span class="number">1.1965400000000006</span>, -<span class="number">1.1288099999999996</span>, -<span class="number">1.060039999999999</span>, -<span class="number">0.990219999999999</span>, -<span class="number">0.9193599999999993</span>, -<span class="number">0.8474299999999992</span>, -<span class="number">0.7744599999999995</span>, -<span class="number">0.7004900000000003</span>, -<span class="number">0.6255299999999995</span>, -<span class="number">0.5496499999999997</span>, -<span class="number">0.4728999999999992</span>, -<span class="number">0.3953799999999994</span>, -<span class="number">0.31716999999999906</span>, -<span class="number">0.2384000000000004</span>, -<span class="number">0.1591799999999992</span>,-<span class="number">0.11827</span>, <span class="number">0.0</span>, <span class="number">0.11827</span>, <span class="number">0.1591799999999992</span>, <span class="number">0.2384000000000004</span>, <span class="number">0.31716999999999906</span>, <span class="number">0.3953799999999994</span>, <span class="number">0.4728999999999992</span>, <span class="number">0.5496499999999997</span>, <span class="number">0.6255299999999995</span>, <span class="number">0.7004900000000003</span>, <span class="number">0.7744599999999995</span>, <span class="number">0.8474299999999992</span>, <span class="number">0.9193599999999993</span>, <span class="number">0.990219999999999</span>, <span class="number">1.060039999999999</span>, <span class="number">1.1288099999999996</span>, <span class="number">1.1965400000000006</span>]</span><br><span class="line">plt.<span class="title function_">figure</span>()</span><br><span class="line">P = [i*<span class="number">0.248945227832799346</span> <span class="keyword">for</span> i <span class="keyword">in</span> P]</span><br><span class="line">plt.<span class="title function_">xlabel</span>(<span class="string">&#x27;displacement&#x27;</span>)</span><br><span class="line">plt.<span class="title function_">ylabel</span>(<span class="string">&#x27;Polarization ($C/m^2$)&#x27;</span>)</span><br><span class="line">plt.<span class="title function_">xlim</span>([<span class="number">0</span>,<span class="number">32</span>])</span><br><span class="line">plt.<span class="title function_">plot</span>(P,<span class="string">&#x27;r.&#x27;</span>)</span><br><span class="line">plt.<span class="title function_">show</span>()</span><br></pre></td></tr></table></figure>
<p>绘制极化值 P 与能量 E 曲线的脚本:</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">E = [<span class="number">0.0035557599999975764</span>, <span class="number">0.0016252999999935014</span>, <span class="number">0.0004821100000000911</span>, <span class="number">0.0</span>, <span class="number">5.983999999870093e-05</span>, <span class="number">0.0005505999999968481</span>, <span class="number">0.0013690299999993272</span>, <span class="number">0.0024182999999950994</span>, <span class="number">0.003608839999998281</span>, <span class="number">0.004859239999994713</span>, <span class="number">0.006096989999996083</span>, <span class="number">0.007258279999994954</span>, <span class="number">0.008287759999994648</span>, <span class="number">0.009138139999997463</span>, <span class="number">0.00977216999999797</span>, <span class="number">0.010162939999993625</span>, <span class="number">0.010294929999993485</span>, <span class="number">0.010162939999993625</span>, <span class="number">0.00977216999999797</span>, <span class="number">0.009138139999997463</span>, <span class="number">0.008287759999994648</span>, <span class="number">0.007258279999994954</span>, <span class="number">0.006096989999996083</span>, <span class="number">0.004859239999994713</span>, <span class="number">0.003608839999998281</span>, <span class="number">0.0024182999999950994</span>, <span class="number">0.0013690299999993272</span>, <span class="number">0.0005505999999968481</span>, <span class="number">5.983999999870093e-05</span>, <span class="number">0.0</span>, <span class="number">0.0004821100000000911</span>, <span class="number">0.0016252999999935014</span>, <span class="number">0.0035557599999975764</span>]</span><br><span class="line">P = [-<span class="number">1.1965400000000006</span>, -<span class="number">1.1288099999999996</span>, -<span class="number">1.060039999999999</span>, -<span class="number">0.990219999999999</span>, -<span class="number">0.9193599999999993</span>, -<span class="number">0.8474299999999992</span>, -<span class="number">0.7744599999999995</span>, -<span class="number">0.7004900000000003</span>, -<span class="number">0.6255299999999995</span>, -<span class="number">0.5496499999999997</span>, -<span class="number">0.4728999999999992</span>, -<span class="number">0.3953799999999994</span>, -<span class="number">0.31716999999999906</span>, -<span class="number">0.2384000000000004</span>, -<span class="number">0.1591799999999992</span>,-<span class="number">0.11827</span>, <span class="number">0.0</span>, <span class="number">0.11827</span>, <span class="number">0.1591799999999992</span>, <span class="number">0.2384000000000004</span>, <span class="number">0.31716999999999906</span>, <span class="number">0.3953799999999994</span>, <span class="number">0.4728999999999992</span>, <span class="number">0.5496499999999997</span>, <span class="number">0.6255299999999995</span>, <span class="number">0.7004900000000003</span>, <span class="number">0.7744599999999995</span>, <span class="number">0.8474299999999992</span>, <span class="number">0.9193599999999993</span>, <span class="number">0.990219999999999</span>, <span class="number">1.060039999999999</span>, <span class="number">1.1288099999999996</span>, <span class="number">1.1965400000000006</span>]</span><br><span class="line"><span class="keyword">import</span> matplotlib.<span class="property">pyplot</span> <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">E = [<span class="number">1e3</span>*i <span class="keyword">for</span> i <span class="keyword">in</span> E]</span><br><span class="line">P = [i*<span class="number">0.248945227832799346</span> <span class="keyword">for</span> i <span class="keyword">in</span> P]</span><br><span class="line"></span><br><span class="line">plt.<span class="title function_">figure</span>()</span><br><span class="line">plt.<span class="title function_">plot</span>(P,E,<span class="string">&#x27;b.-&#x27;</span>)</span><br><span class="line">plt.<span class="title function_">xlabel</span>(<span class="string">&#x27;Polarization ($C/m^2$)&#x27;</span>)</span><br><span class="line">plt.<span class="title function_">ylabel</span>(<span class="string">&#x27;Energy ($meV$)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f1 = np.<span class="title function_">polyfit</span>(P, E, <span class="number">6</span>)</span><br><span class="line">poly = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="title function_">range</span>(<span class="title function_">len</span>(f1)):</span><br><span class="line">    poly += <span class="string">&#x27;&#123;&#125;*x^&#123;&#125;  +  &#x27;</span>.<span class="title function_">format</span>(f1[i],<span class="title function_">len</span>(f1)-i-<span class="number">1</span>)</span><br><span class="line"><span class="title function_">print</span>(poly)</span><br><span class="line"></span><br><span class="line">x = [ -<span class="number">0.35</span>+<span class="number">0.7</span>*i/<span class="number">99</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="title function_">range</span>(<span class="number">100</span>)]</span><br><span class="line"><span class="title class_">Eval</span> = np.<span class="title function_">polyval</span>(f1,x)</span><br><span class="line">plt.<span class="title function_">figure</span>()</span><br><span class="line">plt.<span class="title function_">plot</span>(x,<span class="title class_">Eval</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.<span class="title function_">plot</span>(P,E,<span class="string">&#x27;r*&#x27;</span>)</span><br><span class="line">plt.<span class="title function_">xlabel</span>(<span class="string">&#x27;Polarization ($C/m^2$)&#x27;</span>)</span><br><span class="line">plt.<span class="title function_">ylabel</span>(<span class="string">&#x27;Energy ($meV$)&#x27;</span>)</span><br><span class="line">plt.<span class="title function_">show</span>()</span><br></pre></td></tr></table></figure>
<h1 id="拉曼计算"><a href="#拉曼计算" class="headerlink" title="拉曼计算"></a>拉曼计算</h1><p>VASP中计算拉曼谱主要使用vasp_raman.py这个脚本，见github：<br>  <a target="_blank" rel="noopener" href="https://github.com/raman-sc/VASP">https://github.com/raman-sc/VASP</a></p>
<p>使用raman-sc有几个注意的地方：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/354651066">https://zhuanlan.zhihu.com/p/354651066</a></p>
<p>作者这里提供了一个算例。供大家参考链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1dTCP_0bRcRo0uIy0rBGttQ">https://pan.baidu.com/s/1dTCP_0bRcRo0uIy0rBGttQ</a><br>提取码：4vp8</p>
<ol>
<li>这个代码已经年代久远，使用python2写的，对大部分新学vasp的同学来说可能装的anaconda3，既使用的是python3，与python2代码是不兼容的，作者这里对vasp_raman.py进行了改写，方便python3环境运行这段代码。下载见附件。</li>
<li>raman.sub既提交代码的脚本，需要根据自己的软件环境进行更改，我这里给出我的提交脚本供大家参考:<br>export VASP_RAMAN_RUN&#x3D;’mpirun -np 64 &#x2F;public&#x2F;home&#x2F;wangxiaohui&#x2F;vasp&#x2F;vasp.5.4.4&#x2F;bin&#x2F;vasp_std &amp;&gt; job.out ‘意思是运行vasp的命令，找一下vasp_std所在路径</li>
</ol>
<p>python &#x2F;public&#x2F;home&#x2F;wangxiaohui&#x2F;WORKSPACE&#x2F;Ti3C2Li2&#x2F;raman&#x2F;zhenraman&#x2F;vasp_raman.py &gt; vasp_raman.out这里是运行raman.py代码的意思，既raman.py代码所在路径</p>
<ol start="3">
<li>查看raman.py代码内容得知，POSCAR.phon和OUTCAR.phon是前一步计算的结果文件，不要被作者的例子给坑了。并且POSCAR.phon，OUTCAR.phon和INCAR等文件放在同一个文件夹下。</li>
</ol>
<h3 id="按照脚本VASP需要计算两步："><a href="#按照脚本VASP需要计算两步：" class="headerlink" title="按照脚本VASP需要计算两步："></a>按照脚本VASP需要计算两步：</h3><p>第一步，计算Gamma点声子。用有限位移方法或者DFPT方法。</p>
<p>第一步结束后，执行，</p>
<p> cp POSCAR POSCAR.phon</p>
<p> cp OUTCAR OUTCAR.phon</p>
<p>第二步，计算宏观介电常数的导数。用vasp_raman.py 脚本。</p>
<p>DFPT: LEPSILON&#x3D;.TRUE.</p>
<p>频率依赖的介电矩阵: LOPTICS&#x3D;.TRUE.</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">#<span class="variable constant_">PBS</span> -l select=<span class="number">1</span>:ncpus=<span class="number">32</span>:mpiprocs=<span class="number">32</span></span><br><span class="line">#<span class="variable constant_">PBS</span> -l walltime=<span class="number">01</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">#<span class="variable constant_">PBS</span> -q debug</span><br><span class="line">#<span class="variable constant_">PBS</span> -j oe</span><br><span class="line">#<span class="variable constant_">PBS</span> -N <span class="title class_">Example</span></span><br><span class="line">#<span class="variable constant_">PBS</span> -V</span><br><span class="line"></span><br><span class="line">cd $PBS_O_WORKDIR</span><br><span class="line"></span><br><span class="line">ulimit -s unlimited  # remove limit on stack size</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">VASP_RAMAN_RUN</span>=<span class="string">&#x27;mpirun -n 12 /u/afonari/vasp.5.3.2/vasp.5.3/vasp &amp;&gt; job.out&#x27;</span>   #a按照自己路径更改</span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">VASP_RAMAN_PARAMS</span>=<span class="string">&#x27;01_10_2_0.01&#x27;</span>  #b按照自己材料更改</span><br><span class="line"></span><br><span class="line">python27 vasp_raman.<span class="property">py</span> &gt; vasp_raman.<span class="property">out</span></span><br></pre></td></tr></table></figure>

<p>a. VASP_RAMAN_RUN设置调用VASP的命令</p>
<p>b. VASP_RAMAN_PARAMS&#x3D;01_10_2_0.01</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FIRST_MODE - 整数, 第一个计算的振动模</span><br><span class="line">LAST-MODE - 整数, 最后一个计算的振动模</span><br><span class="line">NDERIV - 整数, 有限位移的策略选择，目前只有2这一种选择</span><br><span class="line">STEPSIZE - 浮点数, 有限位移步长，单位是Angstroms，一般选默认就可以</span><br></pre></td></tr></table></figure>
<p>注意：以上这种设置格式允许我们并行计算大体系拉曼，我们可以在计算大体系的时候将Γ点的振动频率分为很多段分别计算，这样会大大提高我们计算大体系的效率。</p>
<p>在多段计算的时候。具体细节上要把每一段计算的OUTCAR.000n.-1.out和OUTCAR.000n.-1.out文件拷贝到同一个文件夹下，然后注释掉vasp_raman.py脚本中的运行VASP的命令。运行python2.7 vasp_raman.py &gt; vasp_raman.out 即可得到整段的数据。</p>
<p>vasp_raman.py文件中执行VASP的行为331行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">else: # run VASP here</span><br><span class="line">                  print &quot;[__main__]: Running VASP...&quot;</span><br><span class="line">                  os.system(VASP_RAMAN_RUN) #注释掉这一行</span><br></pre></td></tr></table></figure>
<h3 id="加展宽"><a href="#加展宽" class="headerlink" title="加展宽"></a>加展宽</h3><p>使用脚本broaden.py给出展宽谱，可以选择洛伦兹线型或者高斯线型。</p>
<p>$ python2 broaden.py result.txt<br>生成result.txt-broaden.dat文件，画图即可。</p>
<p>需要注意的是，broaden.py的第23和24行分别代表频率和强度所在列。其设置文件中对应的列。</p>
<pre><code>cm1 = hw[:,1]
int1 = hw[:,2]
</code></pre>
<h1 id="红外谱计算"><a href="#红外谱计算" class="headerlink" title="红外谱计算"></a>红外谱计算</h1><ol>
<li><p>红外谱主要是因为振动模在振动前后偶极矩发生变化，从而产生后外吸收。在振动过程中引起偶极矩改变的振动都具有红外活性。</p>
</li>
<li><p>根据上述原理，我们首先需要在计算过程中计算Gamma点的振动模，其次，我们需要计算伯恩有效电荷。</p>
</li>
</ol>
<p>有限位移方法INCAR关键参数：</p>
<p>IBRION &#x3D; 5<br>NWRITE &#x3D; 3<br>POTIM &#x3D; 0.015<br>LEPSILON &#x3D; .TRUE<br>DFPT方法INCAR关键参数：</p>
<p>IBRION &#x3D; 7<br>NWRITE &#x3D; 3<br>NSW &#x3D; 1<br>LEPSILON &#x3D; .TRUE.<br>NELMIN&#x3D;6</p>
<p>另外，建议进行k点测试直到伯恩有效常数收敛。</p>
<ol start="3">
<li><p>后处理</p>
<p> 计算得到OUTCAR，然后文件夹下运行脚本。运行结果如下：</p>
</li>
</ol>
<p> sh IR.sh </p>
<p>上面的振动模和活性是归一化以后的结果，也就是运行结果intensities&#x2F;results&#x2F;results.txt的内容。文件intensities&#x2F;results&#x2F;exact.res.txt是归一化之前的内容。</p>
<ol start="4">
<li>展宽</li>
</ol>
<p>使用脚本broaden.py给出展宽谱，可以选择洛伦兹线型或者高斯线型。</p>
<p>$ python2 broaden.py result.txt<br>生成result.txt-broaden.dat文件，画图即可。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/10/18-47-24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/10/18-47-24/" class="post-title-link" itemprop="url">4.1 力学性质</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-10 18:47:24" itemprop="dateCreated datePublished" datetime="2023-05-10T18:47:24+08:00">2023-05-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-17 14:56:40" itemprop="dateModified" datetime="2023-12-17T14:56:40+08:00">2023-12-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="弹性常数"><a href="#弹性常数" class="headerlink" title="弹性常数"></a>弹性常数</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>弹性常数描述了晶体对外加应变的响应的刚度。在材料的线性变形范围内（应变较小的情况下），体系的应力与应变满足胡克定律。也就是说，对于足够的小的变形，应力与应变成正比，即应力分量(S)是应变分量(E)的线性函数，三维材料的弹性刚度常数矩阵是6×6的。公式中Cij就是我们通常所说的弹性常数。因为刚度矩阵是对称矩阵，因此，弹性常数的独立张量元数目至多只有21个。<strong>对不同的晶系的晶体，因为对称性的关系，其独立的弹性常数是确定的。因此，晶系的对称性越高，独立的张量元数目越少。</strong><br><strong>立方晶系</strong> ——只有3个独立矩阵元（C11，C12，C44）<br><strong>六角晶系</strong> ——有5个独立矩阵元（C11，C12，C13，C33，C44）<br><strong>三角晶系</strong><br>a)  32，3m，-32&#x2F;m——有6个独立矩阵元（C11，C12，C13，C14，C33，C44）<br>b)  3，-3,——有8个独立矩阵元（C11，C12，C13，C14，C15，C33，C44，C45）<br><strong>四方晶系</strong><br>a) 422，4mm，-42m，4&#x2F;mmm——有6个独立矩阵元（C11，C12，C13，C33，C44，C66）<br>b) 4，-4，4&#x2F;m——有7个独立矩阵元（C11，C12，C13，C16，C33，C44，C66）<br><strong>正交晶系</strong> ——有9个独立矩阵元（C11，C12，C13，C22，C23，C33，C44，C55，C66）<br><strong>单斜晶系</strong> ——有13个独立矩阵元<br><strong>三斜晶系</strong> ——有21个独立矩阵元</p>
<h3 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h3><p>采用第一性原理计算弹性常数有两种方法，<strong>第一种方法是应力-应变方法，</strong> 即通过给结构施加不同应变，分别计算出所对应的应力大小，然后利用公式（1）拟合得到一次项系数，从而得到。<strong>第二种方法是能量-应变方法，</strong> 即通过给结构施加不同应变后计算出体系总能相对于基态能量变化（应变能），再利用公式（2）进行二次多项式拟合，其中二次多项式系数是晶体的某个弹性常数或者弹性常数组合。第一种方法优点是每进行一次计算可一次得到六个独立分量，缺点是为了得到准确的应力大小，必须选择更高的截断能和更密集的K格点。<strong>在同样的精度下，能量-应变法相比应力-应变方法要求的截断能和K点数目相对较少，缺点是计算应变数目有所增加。VASPKIT中弹性常数计算基于能量-应变法，目前不支持三斜晶系。</strong><br>一般计算弹性常数我们可以采用应变应力或者应变能量关系，进行拟合。或者可以直接通过VASP直接计算。</p>
<h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>首先介绍直接用VASP在输入文件中添加参数进行计算的方法。</p>
<ol>
<li><p>当然首先要进行结构优化，</p>
</li>
<li><p>在INCAR中添加关键参数，进行弹性常数的计算</p>
 <figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">NSW</span>=<span class="number">1</span></span><br><span class="line"><span class="variable constant_">EDIFFG</span>=-<span class="number">1e-3</span></span><br><span class="line"><span class="variable constant_">ISIF</span>=<span class="number">3</span></span><br><span class="line"><span class="variable constant_">IBRION</span>=<span class="number">6</span> #计算弹性常数</span><br><span class="line"><span class="variable constant_">POTIM</span>=<span class="number">0.015</span></span><br><span class="line"><span class="variable constant_">NFREE</span> = <span class="number">4</span></span><br></pre></td></tr></table></figure></li>
<li><p>计算完成后可以查看OUTCAR得到弹性刚度矩阵。或者可以利用VASPKIT直接得到弹性常数。<br>请注意OUTCAR中的刚度矩阵是未经过处理的刚度矩阵，二维材料需要乘以C轴长度的0.01，还需要了解Voigt简标，11&gt;1 22&gt;2 33&gt;3 23&gt;4 13&gt;5 12&gt;6。然后我们通过Origin等工具绘图即可得到材料的杨氏模量，泊松比等力学性质。</p>
</li>
</ol>
<h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>VASPKIT和VASP计算晶体的弹性常数具体计算步骤分为：</p>
<ol>
<li><p>准备优化彻底的POSCAR文件，注意通常采用标准的惯用原胞计算弹性常数，如果不确信POSCAR文件中是否是标准的惯用原胞，可以用vaspkit-603&#x2F;604生成标准结构；</p>
</li>
<li><p>运行vaspkit 选择102生成KPOINTS，由于计算弹性常数对K-mesh要求很高，因此对于半导体（金属体）体系，生成K点的精度应不小于 0.03(0.02)×2π {\AA}^{-1}</p>
</li>
<li><p>INCAR参考设置如下；</p>
 <figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Global</span> <span class="title class_">Parameters</span></span><br><span class="line"> <span class="variable constant_">ISTART</span> =  <span class="number">0</span>        </span><br><span class="line"> <span class="variable constant_">LREAL</span>  =  F      </span><br><span class="line"> <span class="variable constant_">PREC</span>   =  <span class="title class_">High</span>  （截断能设置默认值<span class="number">1.5</span>-<span class="number">2</span>倍）</span><br><span class="line"> <span class="variable constant_">LWAVE</span>  = F       </span><br><span class="line"> <span class="variable constant_">LCHARG</span> = F     </span><br><span class="line"> <span class="variable constant_">ADDGRID</span>= .<span class="property">TRUE</span>.    </span><br><span class="line"><span class="title class_">Electronic</span> <span class="title class_">Relaxation</span></span><br><span class="line"> <span class="variable constant_">ISMEAR</span> =  <span class="number">0</span>          </span><br><span class="line"> <span class="variable constant_">SIGMA</span>  =  <span class="number">0.05</span>       </span><br><span class="line"> <span class="variable constant_">NELM</span>   =  <span class="number">40</span>           </span><br><span class="line"> <span class="variable constant_">NELMIN</span> =  <span class="number">4</span>           </span><br><span class="line"> <span class="variable constant_">EDIFF</span>  =  <span class="number">1E-08</span>       </span><br><span class="line"><span class="title class_">Ionic</span> <span class="title class_">Relaxation</span></span><br><span class="line"> <span class="variable constant_">NELMIN</span> =  <span class="number">6</span>          </span><br><span class="line"> <span class="variable constant_">NSW</span>    =  <span class="number">100</span>         </span><br><span class="line"> <span class="variable constant_">IBRION</span> =  <span class="number">2</span>           </span><br><span class="line"> <span class="variable constant_">ISIF</span>   =  <span class="number">2</span>    （切记选择<span class="number">2</span>,如果选择<span class="number">3</span>会把施加应变后原胞重新优化成平衡原胞）</span><br><span class="line"> <span class="variable constant_">EDIFFG</span> = -<span class="number">1E-02</span>  </span><br></pre></td></tr></table></figure></li>
<li><p>准备VPKIT.in文件并设置第一行为1（预处理）；运行vaspkit并选择201, 将生成用于计算弹性常数文件；</p>
 <figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>                    ! 设置<span class="number">1</span>将产生计算弹性常数的输入文件，<span class="number">2</span>则计算弹性常数</span><br><span class="line">3D                   ! 2D为二维体系，3D为三维体系</span><br><span class="line"><span class="number">7</span>                    ! <span class="number">7</span>个应变</span><br><span class="line">-<span class="number">0.015</span> -<span class="number">0.010</span> -<span class="number">0.005</span> <span class="number">0.000</span> <span class="number">0.005</span> <span class="number">0.010</span> <span class="number">0.015</span>  ! 应变变化范围</span><br></pre></td></tr></table></figure></li>
<li><p>批量提交vasp作业；<br>总计有9个大文件夹，分别以该空间群所需要的独立弹性常数来命名；在每个大文件夹内则是以应变强度命名的实际计算执行的文件夹，文件夹的数量可根据预处理的VPKIT.in文件的最后一行的应变设置来更改。在每一个应变文件夹内则是施加了应变的POSCAR和事先准备好的INCAR、KPOINTS和POTCAR文件的链接，可直接进行vasp计算。<br>这里通过一个简单的两重for循环命令依次序完成所需要的计算任务。<br>脚本 :</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">path=<span class="string">`pwd`</span></span><br><span class="line">#记录当前文件夹位置并定义到变量 path中，称为初始目录</span><br><span class="line">pwd</span><br><span class="line"><span class="keyword">for</span> cij <span class="keyword">in</span> <span class="string">`ls -F | grep /$`</span></span><br><span class="line">#ls -F| grep /$ 命令为返回当前文件夹中所有子目录</span><br><span class="line">#将所有子目录添加到变量cij中，并准备进行<span class="keyword">for</span>循环</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">cd $&#123;path&#125;/$cij</span><br><span class="line">#进入cij变量所代表的子目录中</span><br><span class="line">pwd</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strain_*</span><br><span class="line">#将cij代表的子目录中所有strain文件夹添加到变量s中</span><br><span class="line">#此部添加变量s的方式可更改为添加变量cij的方式，但不建议这么做</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">cd $&#123;path&#125;/$cij/$s</span><br><span class="line">#进入初始目录下变量cij和变量s组成的目录，由于<span class="keyword">for</span>循环的设置，将遍历所有可计算的strain文件夹</span><br><span class="line">pwd</span><br><span class="line"> mpirun -np <span class="number">16</span> vasp_std</span><br><span class="line"> #执行vasp计算</span><br><span class="line">cd $&#123;path&#125;</span><br><span class="line">#返回初始目录</span><br><span class="line">pwd</span><br><span class="line">done</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
<li><p>再次修改VPKIT.in文件中第一行为2（后处理），然后再次运行vaspkit并选择201，得到以下结果；</p>
</li>
<li><p>如果在计算弹性常数时希望强制固定某个体系的空间群，可在SYMMETRY.in文件第二行设置空间群，这样晶系将通过指定空间群判断并计算相应的独立弹性常数，这对于掺杂或者合金体系比较有用。</p>
</li>
</ol>
<h3 id="根据弹性常数计算和三维可视化材料力学量"><a href="#根据弹性常数计算和三维可视化材料力学量" class="headerlink" title="根据弹性常数计算和三维可视化材料力学量"></a>根据弹性常数计算和三维可视化材料力学量</h3><p>首先利用VASPKIT-204命令得到体弹性模量、杨氏模量、剪切模量及泊松比随角度的依赖关系，具体算法可参考文献【J. Phys. Condens. Matter, 28, 275201 (2016)和Comput. Phys. Commun. 181, 2102–2115 (2010)】。接下来我们以某单斜体系的弹性常数为例来演示如何进行材料力学量三维可视化。</p>
<ul>
<li>第一步新建ELASTIC_TENSOR.in并输入6x6弹性常数矩阵，注意第一行是注释行不可省略。如果是二维体系，则输入文件为ELASTIC_TENSOR_2D.in，注意二维体系弹性常数矩阵大小为3x3。 <figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># comment line (<span class="keyword">in</span> <span class="title class_">GPa</span>)</span><br><span class="line">   <span class="number">228.38</span>   <span class="number">85.741</span>   <span class="number">81.503</span>        <span class="number">0</span>   -<span class="number">0.737</span>        <span class="number">0</span></span><br><span class="line">   <span class="number">85.741</span>   <span class="number">217.47</span>   <span class="number">94.201</span>        <span class="number">0</span>  -<span class="number">20.213</span>        <span class="number">0</span></span><br><span class="line">   <span class="number">81.503</span>   <span class="number">94.201</span>   <span class="number">178.81</span>        <span class="number">0</span>   -<span class="number">9.472</span>        <span class="number">0</span></span><br><span class="line">        <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span>   <span class="number">35.094</span>        <span class="number">0</span>  -<span class="number">17.851</span></span><br><span class="line">   -<span class="number">0.737</span>  -<span class="number">20.213</span>   -<span class="number">9.472</span>        <span class="number">0</span>   <span class="number">37.778</span>        <span class="number">0</span></span><br><span class="line">        <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span>  -<span class="number">17.851</span>        <span class="number">0</span>   <span class="number">42.708</span></span><br></pre></td></tr></table></figure></li>
<li>第二步运行VASPKIT 204命令得到MECHANICS_3D.dat<br>打开MECHANICS_3D.dat可看到第一行给出了每一列数据所代表的物理量，第二行给出了球坐标系下分别划分仰角θ∈[0,180]和方位角ϕ∈[0,360]的格点大小。</li>
<li>第三步从vaspkit&#x2F;examples&#x2F;angular_dependent_mechanics (VASPKIT ver. &gt;&#x3D; 1.3.2)文件夹中拷贝mechanics_3d_plot_matlab.m到当前目录，调用Matlab软件运行该脚本，得到以下信息.<br>如果我们想可视化杨氏模量，则输入2回车即可得到。</li>
<li>另外，以下两个软件也可以实现材料力学量三维可视化。<br>Elate<br>ElasticPOST</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/09/19-49-25/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/09/19-49-25/" class="post-title-link" itemprop="url">3.4 非谐声子</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-09 19:49:25" itemprop="dateCreated datePublished" datetime="2023-05-09T19:49:25+08:00">2023-05-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-29 17:26:26" itemprop="dateModified" datetime="2024-10-29T17:26:26+08:00">2024-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>ALAMODE中非谐声子计算部分采用了自洽声子计算方法。</p>
<p>具体教程：<a target="_blank" rel="noopener" href="https://alamode.readthedocs.io/en/latest/anphondir/formalism_anphon.html#self-consistent-phonon-scph-calculation">https://alamode.readthedocs.io/en/latest/anphondir/formalism_anphon.html#self-consistent-phonon-scph-calculation</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1mv411M7W7/?spm_id_from=333.999.0.0&vd_source=17084cc867ff3bb86398ff1a79b443f2">https://www.bilibili.com/video/BV1mv411M7W7/?spm_id_from=333.999.0.0&amp;vd_source=17084cc867ff3bb86398ff1a79b443f2</a></p>
<p>TDEP 是其采用技术Temperature dependent effective potential的缩写。<br>下面是开发者的网站，但是并不能下载到源代码。<a target="_blank" rel="noopener" href="http://ollehellman.github.io/page/index.html%E5%A5%BD%E6%B6%88%E6%81%AF%E6%98%AF%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86%E8%AE%A1%E7%AE%97%E8%BD%AF%E4%BB%B6ABINIT%E4%B8%AD%E9%9B%86%E6%88%90%E4%BA%86TDEP%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%98%E7%BD%91user">http://ollehellman.github.io/page/index.html好消息是第一性原理计算软件ABINIT中集成了TDEP方法，官网user</a> guide&gt;a-TDEP。需要研究的可以自行研究。ABINIT官网：<a target="_blank" rel="noopener" href="https://www.abinit.org/">https://www.abinit.org/</a></p>
<p>Dynaphopy 是采用了一种基于AIMD（第一性原理分子动力学）的杂化方法的python程序包：<a target="_blank" rel="noopener" href="http://abelcarreras.github.io/DynaPhoPy/index.html">http://abelcarreras.github.io/DynaPhoPy/index.html</a><br>文中给出了参考文献，需要的自行下载。</p>
<h1 id="ALAMODE"><a href="#ALAMODE" class="headerlink" title="ALAMODE"></a>ALAMODE</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a target="_blank" rel="noopener" href="https://alamode.readthedocs.io/en/latest/index.html#">https://alamode.readthedocs.io/en/latest/index.html#</a></p>
<h2 id="ALAMODE计算Si简谐声子谱"><a href="#ALAMODE计算Si简谐声子谱" class="headerlink" title="ALAMODE计算Si简谐声子谱"></a>ALAMODE计算Si简谐声子谱</h2><h3 id="1、利用ALM计算displacement-patterns"><a href="#1、利用ALM计算displacement-patterns" class="headerlink" title="1、利用ALM计算displacement patterns"></a>1、利用ALM计算displacement patterns</h3><p>优化后的超胞结构重命名<strong>POSCAR.orig</strong>，准备输入文件<strong>si_alm.in</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&amp;general</span><br><span class="line">  PREFIX = si222</span><br><span class="line">  MODE = suggest</span><br><span class="line">  NAT = 64; NKD = 1</span><br><span class="line">  KD = Si</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;interaction</span><br><span class="line">  NORDER = 1  # 1: harmonic, 2: cubic, ..</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;cell</span><br><span class="line">  20.406 # factor in Bohr unit</span><br><span class="line">  1.0 0.0 0.0 # a1</span><br><span class="line">  0.0 1.0 0.0 # a2</span><br><span class="line">  0.0 0.0 1.0 # a3</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;cutoff </span><br><span class="line">  Si-Si None</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;position</span><br><span class="line">  1 0.0000000000000000 0.0000000000000000 0.0000000000000000   </span><br><span class="line">  1 0.0000000000000000 0.0000000000000000 0.5000000000000000</span><br><span class="line">  1 0.0000000000000000 0.2500000000000000 0.2500000000000000</span><br><span class="line">  1 0.0000000000000000 0.2500000000000000 0.7500000000000000</span><br><span class="line">  1 0.0000000000000000 0.5000000000000000 0.0000000000000000</span><br><span class="line">  1 0.0000000000000000 0.5000000000000000 0.5000000000000000</span><br><span class="line">  1 0.0000000000000000 0.7500000000000000 0.2500000000000000</span><br></pre></td></tr></table></figure>
<p>晶格常数替代为自己的超胞结构。</p>
<p>运行ALM: <code>alm si_alm.in &gt; si_alm.log1</code>，将会生成<strong>si222.pattern_HARMONIC</strong>文件，包含坐标信息。对于Si只有一个displacement patterns。</p>
<h3 id="2、计算原子间力"><a href="#2、计算原子间力" class="headerlink" title="2、计算原子间力"></a>2、计算原子间力</h3><p>在此之前要确定位移的大小，一般简谐0.01-0.04，0.01大多可以。运行<code>python displace.py --VASP=POSCAR.orig --mag=0.01 -pf si222.pattern_HARMONIC</code></p>
<p>之后对每个结构提交计算，脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># Assume we have 20 displaced configurations for QE [disp01.pw.in,..., disp20.pw.in].</span><br><span class="line"></span><br><span class="line">for ((i=1;i&lt;=20;i++))</span><br><span class="line">do</span><br><span class="line">    num=`echo $i | awk &#x27;&#123;printf(&quot;%02d&quot;,$1)&#125;&#x27;`</span><br><span class="line">    mkdir $&#123;num&#125;</span><br><span class="line">    cd $&#123;num&#125;</span><br><span class="line">    cp ../disp$&#123;num&#125;.pw.in .</span><br><span class="line">    pw.x &lt; disp$&#123;num&#125;.pw.in &gt; disp$&#123;num&#125;.pw.out</span><br><span class="line">    cd ../</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>计算完成后，提取信息：<code>python extract.py --VASP=POSCAR.orig vasprun*.xml &gt; DFSET_harmonic</code>，生成<strong>DFSET_harmonic</strong>文件。</p>
<h3 id="3、拟合力常数"><a href="#3、拟合力常数" class="headerlink" title="3、拟合力常数"></a>3、拟合力常数</h3><p>修改1中的 <strong>si_alm.in</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&amp;general</span><br><span class="line">  PREFIX = si222</span><br><span class="line">  MODE = optimize   # &lt;-- here</span><br><span class="line">  NAT = 64; NKD = 1</span><br><span class="line">  KD = Si</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;optimize</span><br><span class="line">  DFSET = DFSET_harmonic</span><br><span class="line">/</span><br></pre></td></tr></table></figure>
<p>运行<code>alm si_alm.in &gt; si_alm.log2</code>，生成<strong>si222.fcs and si222.xml</strong></p>
<h3 id="4、计算声子谱和DOS"><a href="#4、计算声子谱和DOS" class="headerlink" title="4、计算声子谱和DOS"></a>4、计算声子谱和DOS</h3><p>准备<strong>si_phband.in</strong>文件，结构中用晶胞结构，注意&amp;cell中单位是Bohr，具体可设置如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&amp;general</span><br><span class="line">  PREFIX = si</span><br><span class="line">  MODE   = phonons</span><br><span class="line">  FCSXML = si.xml</span><br><span class="line"></span><br><span class="line">  NKD = 1; KD = Si</span><br><span class="line">  MASS = 28.085</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;cell</span><br><span class="line">  10.184247326051628 </span><br><span class="line">  0.0000000000000000    0.5071343999939496    0.5071343999939496</span><br><span class="line">  0.5071343999939496    0.0000000000000000    0.5071343999939496</span><br><span class="line">  0.5071343999939496    0.5071343999939496    0.0000000000000000</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;kpoint</span><br><span class="line">  1   # KPMODE = 1: line mode</span><br><span class="line">  G 0.0 0.0 0.0 X 0.5 0.5 0.0 51</span><br><span class="line">  X 0.5 0.5 1.0 G 0.0 0.0 0.0 51</span><br><span class="line">  G 0.0 0.0 0.0 L 0.5 0.5 0.5 51</span><br><span class="line">/</span><br></pre></td></tr></table></figure>
<p>执行<code>anphon si_phband.in &gt; si_phband.log</code>会产生<strong>si.bands</strong>文件，可以用plotband.py脚本画图。执行python plotband.py si.bands得到</p>
<p>准备si_phdos.in文件，结构中用晶胞结构，注意&amp;cell中单位是Bohr，具体可设置如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&amp;general</span><br><span class="line">  PREFIX = si</span><br><span class="line">  MODE   = phonons</span><br><span class="line">  FCSXML = si.xml</span><br><span class="line"></span><br><span class="line">  NKD = 1; KD = Si</span><br><span class="line">  MASS = 28.085</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;cell</span><br><span class="line">  10.184247326051628 </span><br><span class="line">  0.0000000000000000    0.5071343999939496    0.5071343999939496</span><br><span class="line">  0.5071343999939496    0.0000000000000000    0.5071343999939496</span><br><span class="line">  0.5071343999939496    0.5071343999939496    0.0000000000000000</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;kpoint</span><br><span class="line">  2   # KPMODE = 2: uniform mesh mode</span><br><span class="line">  20 20 20</span><br><span class="line">/</span><br></pre></td></tr></table></figure>
<p>执行<code>anphon si_phdos.in &gt; si_phdos.log</code>会产生<strong>si.dos</strong>文件，可以用plotdos.py脚本画图。执行python plotdos.py –emax 550 –nokey si.dos得到</p>
<h3 id="5-估算对热导率的立方IFCs-非简谐IFCs"><a href="#5-估算对热导率的立方IFCs-非简谐IFCs" class="headerlink" title="5. 估算对热导率的立方IFCs(非简谐IFCs)"></a>5. 估算对热导率的立方IFCs(非简谐IFCs)</h3><p>这里计算非简谐IFCs，我们把si_alm1.in复制为si_alm3.in，将NORDER &#x3D; 1改为NORDER &#x3D; 2.我们还要注意这里考虑计算三阶力常数，所以&amp;cutoff下的参数我们要再指定个截止半径，一般要求略大于第二近邻的距离（可以从si_alm1.log查看，如下图）。当然你接着用None也行，这样可能大大增加参数的数量，从而增加计算成本。</p>
<p>运行alm si_alm3.in &gt; si_alm3.log，可以看到多了si_cubic.相关文件。运行python displace.py –OpenMX&#x3D;Si.dat –mag&#x3D;0.04 -pf si_cubic.pattern_ANHARM3，可见产生了disp01.dat到disp11.dat11个OpenMX输入文件，我们准备shell脚本批量提交，shell脚本命名为pbs.sh，具体为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">for ((i=1;i&lt;=11;i++))</span><br><span class="line">do</span><br><span class="line">    num=`echo $i | awk &#x27;&#123;printf(&quot;%02d&quot;,$1)&#125;&#x27;`</span><br><span class="line">    mkdir $&#123;num&#125;</span><br><span class="line">    cd $&#123;num&#125;</span><br><span class="line">    cp ../disp$&#123;num&#125;.dat .</span><br><span class="line">    cp disp$&#123;num&#125;.dat Si.dat</span><br><span class="line">    cp ../openmx.pbs .</span><br><span class="line">    qsub openmx.pbs</span><br><span class="line">    cd ../</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="简谐计算步骤"><a href="#简谐计算步骤" class="headerlink" title="简谐计算步骤"></a>简谐计算步骤</h4><ol>
<li>输入文件： 优化后的超胞结构重命名<strong>POSCAR.orig</strong>，准备输入文件<strong>si_alm.in</strong>（其中mode：suggest）；输出：<strong>si222.pattern_HARMONIC</strong>文件，包含坐标信息。</li>
<li>displace.py对上面的.pattern文件处理，得到随机位移结构；对随机位移机构进行力的计算，生成不同vasprun.xml；extract.py处理上面vasprun.xml，生成<strong>DFSET_harmonic</strong>文件。</li>
<li><font color=red>力常数拟合输入文件：</font><strong>DFSET_harmonic</strong>文件，修改1中的 <strong>si_alm.in</strong>，其中mode改成opt, 添加下面；生成<strong>si222.fcs and si222.xml</strong>。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;optimize</span><br><span class="line">  DFSET = DFSET_harmonic</span><br><span class="line">/</span><br></pre></td></tr></table></figure></li>
<li>后处理输入文件：准备<strong>phband.in</strong>文件，修改MODE   &#x3D; phonons<br>  FCSXML &#x3D; si.xml；修改kmesh格式可得到声子谱、态密度、热性质等。</li>
</ol>
<h4 id="非谐计算"><a href="#非谐计算" class="headerlink" title="非谐计算"></a>非谐计算</h4><ol>
<li>准备简谐计算得到的<strong>si222.fcs and si222.xml</strong>，AIMD得到的vasprun.xml，超胞结构。</li>
<li>displace.py 对AIMD的vasprun.xml处理，得到随机结构；对随机位移机构进行力的计算，生成不同vasprun.xml；extract.py处理上面vasprun.xml，生成<strong>DFSET_AIMD_random</strong>文件。</li>
<li><font color=red>Cross validation (CV)：</font>alm_cv.in文件中添加简谐力常数 FC2XML &#x3D; ..&#x2F;harmonic.xml，添加高阶力常数部分标签和cv相关标签，<strong>mode &#x3D; cv</strong>；得到*cvset文件；python3 cvscore.py *cvset &gt; si222.cvscore得到Minimum cvscore</li>
<li><font color=red>拟合力常数输入文件：</font>alm_opt.in中mode&#x3D;opt；修改cv相关标签；生成高阶力常数<strong>cv.fcs and cv.xml</strong>.在这一步alm 的输入文件&amp;general 部分加入 FC3_SHENGBTE&#x3D;1、 FC4_SHENGBTE&#x3D;1可输出ShengBTE格式的输入文件。</li>
<li><font color=red>SCPH计算：</font>scph.in文件中修改MODE&#x3D;SCPH和温度标签；添加&amp;scph模块，见上面例子。anphon scph.in &gt; scph.log提交，查看收敛：grep “conv” scph.log。生成输出文件：.scph_dymat、.scph_dfc2、.scph_bands。对.scph_dfc2处理得到有效二阶力常数文件，用于后续计算。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;dfc2</span><br><span class="line">DFC2--a generator of renormalized harmonic FCs from SCPH outputs.</span><br><span class="line">XML file containing original Fc2 : STo222.xml </span><br><span class="line">Output xml filename with anharmonic correction : ST0222_SCPH2-2_300K.xml</span><br><span class="line">FC2 correction file fromSCPH calculation :STo_scph2-2.scph_dfc2</span><br><span class="line">Target temperature : 300</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">New XML file STo222_SCPH2-2_300K.xml was created successfully.</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Alamode计算高温声子色散"><a href="#Alamode计算高温声子色散" class="headerlink" title="Alamode计算高温声子色散"></a>Alamode计算高温声子色散</h2><p>Anharmonic Phonons (self-consistent phonon theory)<br>主要使用alamode软件。 版本：alamode-1.1.0</p>
<h3 id="输入文件"><a href="#输入文件" class="headerlink" title="输入文件"></a>输入文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vasprun.xml #分子动力学输出文件</span><br><span class="line">Dfile  #包含原子的力和位移</span><br><span class="line">extract_disp.py #选取结构，并计算位移</span><br><span class="line">extract_force.py #选取结构，并获得受力</span><br><span class="line">PPOSCAR #初始超胞</span><br><span class="line">alm.in #提取力常数的输入文件</span><br><span class="line">anphono.in #计算声子谱的输入文件</span><br></pre></td></tr></table></figure>
<ol>
<li>从分子动力学数据中选取一定数量的结构，并提取它们的力和计算与初始状态相比的位移，输出到<strong>Dfile</strong>文件当中</li>
</ol>
<p><code>python extract_disp.py </code><br>#运行后根据提示输入开始的步数和间隔步数<br>#例如总共1000步，从第一步开始提取，每间隔五步提取一次<br>#得到disp.dat</p>
<p><code>python extract_force.py</code> </p>
<p>方法同上得到force.dat<br>将disp.dat和force.dat文件按如下形式合并到一起</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">disp1x  disp1y  disp1z   force1x  force1y  force1z</span><br><span class="line">       ......</span><br><span class="line">       ......</span><br><span class="line">dispNx  dispNy  dispNz   forceNx  forceNy  forceNz</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获取力常数</li>
</ol>
<p>提取四阶力常数的<strong>alm.in</strong>文件如下（使用LASSO方法）：</p>
<p>二阶力常数可以通过有限位移法提取(详见官网手册)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&amp;general</span><br><span class="line">  PREFIX = ThO2_ENET</span><br><span class="line">  MODE = optimize</span><br><span class="line">  NAT = 81; NKD = 2</span><br><span class="line">  KD = Th O</span><br><span class="line">#  PRINTSYM=1</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;interaction</span><br><span class="line">  NORDER = 5  # 1: harmonic, 2: cubic, ..</span><br><span class="line">  NBODY = 2 3 3 2 2</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;cell</span><br><span class="line">  1 # factor in Bohr unit</span><br><span class="line">  0.0000000000000   15.919498944104   15.919498944104</span><br><span class="line">  15.919498944104   0.0000000000000   15.919498944104</span><br><span class="line">  15.919498944104   15.919498944104   0.0000000000000</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;optimize</span><br><span class="line">  LMODEL= enet</span><br><span class="line">  FC2XML = ThO2_2nd.xml</span><br><span class="line">  DFSET=ThO2_dffile</span><br><span class="line"></span><br><span class="line">  CV = 0</span><br><span class="line">  L1_RATIO = 1.0</span><br><span class="line">  L1_ALPHA = 1.0e-06</span><br><span class="line">  CV_MINALPHA = 1.0e-6</span><br><span class="line">  CV_MAXALPHA = 0.02</span><br><span class="line">  CV_NALPHA = 100</span><br><span class="line"></span><br><span class="line">  STANDARDIZE = 1</span><br><span class="line">  CONV_TOL = 1.0e-9</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;cutoff </span><br><span class="line">  *-* None None 12.0 12.0 12.0</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;position</span><br><span class="line">1  0.0000000000000000  0.0000000000000000  0.0000000000000000</span><br><span class="line">1  0.3333333333333333  0.0000000000000000  0.0000000000000000</span><br><span class="line">..................</span><br></pre></td></tr></table></figure>
<p>注意晶格常数单位的转换 $1 Bohr&#x3D; 0.529177208 Angstrom$</p>
<p>在终端运行：</p>
<p>bash<br><code>alm alm.in &gt; alm.log</code><br>得到<strong>Nb.xml</strong></p>
<ol start="3">
<li>Anharmonic Phonon</li>
</ol>
<p><strong>anphono.in</strong>输入文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&amp;general</span><br><span class="line"> PREFIX =scph</span><br><span class="line"> MODE = SCPH</span><br><span class="line"> FCSXML =Nb.xml #forceconstant file</span><br><span class="line"></span><br><span class="line"> NKD = 1; KD = Nb</span><br><span class="line"> MASS = 92.90638</span><br><span class="line"></span><br><span class="line"> #NONANALYTIC = 0; BORNINFO = PbTe.born</span><br><span class="line"></span><br><span class="line"> TMIN = 0; TMAX = 300; DT = 100   #Temperature and step</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;scph</span><br><span class="line"> KMESH_SCPH        = 6 6 6</span><br><span class="line"> KMESH_INTERPOLATE = 6 6 6</span><br><span class="line"></span><br><span class="line"> SELF_OFFDIAG = 0</span><br><span class="line"> RESTART_SCPH = 0</span><br><span class="line"></span><br><span class="line"> MIXALPHA = 0.1</span><br><span class="line"> MAXITER = 500</span><br><span class="line"> TOL_SCPH = 1.0e-10</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;cell   ## primitive cell is best</span><br><span class="line">  6.2507550151332</span><br><span class="line">  -0.5  0.5  0.5</span><br><span class="line">   0.5 -0.5  0.5</span><br><span class="line">   0.5  0.5 -0.5</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">&amp;kpoint</span><br><span class="line">  1  # KPMODE = 1: get phonon band  2: get others properties</span><br><span class="line">  G 0.0 0.0 0.0 H 0.5 -0.5 0.5 201</span><br><span class="line">  H 0.5 -0.5 0.5 P 0.25 0.25 0.25 201</span><br><span class="line">  P 0.25 0.25 0.25 G 0.0 0.0 0.0 201</span><br><span class="line">  G 0.0 0.0 0.0  N 0.0 0.0 0.5 201</span><br><span class="line">/</span><br></pre></td></tr></table></figure>
<p>在终端运行：</p>
<p><code>anphon anphono.in &gt; anphono.log</code><br>得到<strong>scph.scph_bands</strong>，里面有不同温度下的声子谱</p>
<ol start="4">
<li>进入安装目录下的tools文件夹：make Makefile，编译df2c。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[scf1355@ln151%nc-l ah]$ ~/soft/alamode/tools/dfc2 </span><br><span class="line"> DFC2 -- a generator of renormalized harmonic FCs from SCPH outputs.</span><br><span class="line"> XML file containing original FC2 : crte2-442.xml</span><br><span class="line"> Output xml filename with anharmonic correction : crte2-new.xml</span><br><span class="line"> FC2 correction file from SCPH calculation : crte2-442.scph_dfc2</span><br><span class="line"> Target temperature : 300</span><br></pre></td></tr></table></figure></li>
</ol>
<p> 输出crte2-new.xml.利用<a target="_blank" rel="noopener" href="https://github.com/ttadano/alamode/discussions/192">https://github.com/ttadano/alamode/discussions/192</a> 中提到的脚本转换成phonopy格式。此时的力常数文件由于对称性数量不匹配，利用phonopy读取并写出FULL_FORCE_CONSTANTS。</p>
<h2 id="Alamode-to-ShengBTE"><a href="#Alamode-to-ShengBTE" class="headerlink" title="Alamode_to_ShengBTE"></a>Alamode_to_ShengBTE</h2><h3 id="Alamode计算热导率步骤"><a href="#Alamode计算热导率步骤" class="headerlink" title="Alamode计算热导率步骤"></a>Alamode计算热导率步骤</h3><ol>
<li>所有的计算都是基于密度泛函软件 VASP 来进行的。</li>
<li>首先利用第一性原理的密度泛函对晶体结构进行优化，弛豫出稳定的晶格结构，然后利用密度泛函微扰理论计算出波恩有效电荷和静态介电张量，以便用于后续求解动力学矩阵的非解析部分。 </li>
<li>随后为了获得更加精准的二阶力常数，通过差分位移的方法生成微扰结构，后利用静态密度泛函理论计算出力和位移信息，再利用最小二乘法得到所需要的二阶力常数。 </li>
<li>对于高阶力常数，本文利用分子动力学模拟得到 80 个准随机结构，对每个准随机结构的原子施加随机方向的微小位移，以便得到更加随机的结构，最后利用最小绝对收缩和选择算子的方法得到高阶力常数。 </li>
<li>结合上述已经得到的介电张量、波恩有效电荷、二阶力常数和三阶力常数作为输入，最后通过ShengBTE声子玻尔兹曼输运方程求得简谐近似下晶格热导率、声子群速度、 声子散射率等热输运系数。 </li>
<li>结合介电张量、波恩有效电荷、二阶力常数和四阶力常数作为输入进行自洽声子理论的计算，这将得到与温度相关的非谐动力学矩阵，对其进行傅里叶变换得到与温度相关的有效二阶力常数，用有效二阶力常数代替上述的二阶力常数，在此基础上求解声子玻尔兹曼输运方程求得自洽声子理论下晶格热导率、声子群速度、声子散射率等热输运系数。</li>
<li>在简谐近似下存在虚频，与实验观察到的稳定性不一致。因此，传统的基于简谐原子间力常数的玻尔兹曼输运方程解的结果不再有效，并且非谐效应在足够大的位移振幅内变得显著。在 ALAMODE 软件包中，通过有限位移法在 2×2×2 超胞中获得简谐原子间力常数 (IFCs) ，位移大小设置为 0.01Å。<br>随后，通过压缩感知晶格动力学方法训练三阶和四阶力常数。具体来说，本文首先模拟了在 300 K、时间步长为 2fs 的 4000 步的从头算分子动力学，得到了 80 个快照。为了得到准随机结构， 本文将到得到快照中的原子向随机方向移动 0.1 Å。随后，本文将获得的准随机结构在 4×4×4 的 k 点网格中进行了静态 DFT 计算，以计算 Hellmann–Feynman 力。最终，利用得到的 80 个准随机结构的位移和力组成的数据集通过最小绝对收缩和选择算子 (least absolute shrinkage and selection operator，简称 LASSO)方法训练出非谐力常数。<br>在计算中本文考虑了超胞内的所有原子间最近邻相互作用来计算简谐和三阶力常数，四阶力常数只考虑了第五最近邻内的相互作用，由于五阶和六阶力常数 对结果的影响很小，因此只考虑了次近邻相互作用。<br>本文根据 ALAMODE 软件包中采用的 SCP 理论，利用获得的简谐和非谐力常数来计算非谐声子频率。<br>声子玻尔兹曼输运方程的解是通过 ShengBTE 的修订版 FourPhonon 软件包来实现的，并建立了具有高斯涂抹 (scale broad 参数为 0.05) 的 18×18×18 的 q 点网格来模拟相关积分和声子波矢量。此外，在计算中得到了大约 2.3×105 个三声子过程和 1.2×109 个四声子过程。因此，对于三声子散射，本文采用迭代方案来求解玻尔兹曼输运方程，而通过单模弛豫时间近似(SMRTA) 来处理四声子散射过程，这是因为计算成本巨大。</li>
</ol>
<h3 id="步骤分析"><a href="#步骤分析" class="headerlink" title="步骤分析"></a>步骤分析</h3><ul>
<li>上面第3步，利用alm来算大概分为三步，mode设为suggest产生随机位移，vasp求力和能量，mode设为opt拟合二阶力常数即可。<strong>alm模块</strong>。</li>
<li>上面第4步，利用AIMD产生随机位移，vasp求力和能量，压缩感知晶格动力学方法训练三阶和四阶力常数mode设为cv，随后mode设为opt拟合高阶力常数，<strong>alm模块</strong>。最后mode设为SCPH获得变温声子谱和有效二阶力常数,<strong>anphon模块</strong>。后续运行<strong>dfc2</strong>模块生成指定温度的有效二阶力常数，用<a target="_blank" rel="noopener" href="https://github.com/ttadano/alamode/discussions/192">https://github.com/ttadano/alamode/discussions/192</a> 中提到的脚本转换成phonopy格式。</li>
<li>上面第5步，为了产生ShengBTE的力常数输入文件，在拟合高阶力常数时，alm 的输入文件&amp;general 部分加入 FC3_SHENGBTE&#x3D;1、 FC4_SHENGBTE&#x3D;1即可。如果简谐声子谱有虚频，上面的有效二阶力常数也需要，即第7步所述。</li>
<li>上面第6步见ShengBTE教程3.2节。</li>
<li>Alamode可以得到的结果包括格林艾森常数、声子群速度、三声子相空间、热导率原子贡献率和元素、变温声子谱和态密度、MSD、可视化振动模式、QHA等,<strong>anphon模块</strong>。</li>
</ul>
<h3 id="Alamode-连接-shengBTE"><a href="#Alamode-连接-shengBTE" class="headerlink" title="Alamode 连接 shengBTE"></a>Alamode 连接 shengBTE</h3><p>首先，github上安装最新版本的develop branches 或 feature&#x2F;shengbte_4ph branches</p>
<p>[<strong>3rd 4th IFCs</strong>]  </p>
<p>拟合力常数时，alm 的输入文件&amp;general 部分加入 FC3_SHENGBTE&#x3D;1、 FC4_SHENGBTE&#x3D;1即可。</p>
<hr>
<p>&amp;general</p>
<p> PREFIX &#x3D; BN-1000</p>
<p> MODE &#x3D; opt</p>
<p> NAT &#x3D; 128</p>
<p> NKD &#x3D; 2; KD &#x3D; B N</p>
<p> TOLERANCE &#x3D; 1.0e-3</p>
<p> FC3_SHENGBTE&#x3D;1</p>
<p> FC4_SHENGBTE&#x3D;1</p>
<p>&#x2F;</p>
<hr>
<p>Note：输出的文件名为：FORCE_CONSTANT_3RD、FORCE_CONSTANT_4TH，和ShengBTE的文件名差一个S，FORCE_CONSTANTS_3RD、FORCE_CONSTANTS_4TH</p>
<p>[<strong>2nd IFCs</strong>]  </p>
<p>首先通过QE的DFPT计算一个不含SCP的二阶力常数，BN.ifc2。</p>
<p>做SCPH计算，会生成计算温度点的二阶力常数SCP等效修正部分，例如BN.scph_dfc2（仅考虑四声子散射对重整化的影响），若进一步考虑三声子散射的重整化作用，文件名为BN.scph+bubble(0)_dfc2。</p>
<p>alamode&#x2F;tools&#x2F;scph_to_qefc.py    可以将SCP的修正部分与QE计算的二阶力常数相加，得到指定温度重整化后的二阶力常数。</p>
<p>Usage:</p>
<blockquote>
<p>python scph_to_qefc.py  original_QEfc2 scph_fc2_correction temperature &gt; scp_fc2</p>
<p>python scph_to_qefc.py BN.ifc2    BN.scph_dfc2    1000 &gt; espresso.ifc2</p>
</blockquote>
<h2 id="Authors-and-references"><a href="#Authors-and-references" class="headerlink" title="Authors and references"></a>Authors and references</h2><p>Weizhe Yuan <u><a href="mailto:&#x79;&#117;&#x61;&#x6e;&#x77;&#122;&#x40;&#115;&#116;&#117;&#x2e;&#104;&#x69;&#x74;&#x2e;&#x65;&#x64;&#x6e;&#46;&#x63;&#x6e;">&#x79;&#117;&#x61;&#x6e;&#x77;&#122;&#x40;&#115;&#116;&#117;&#x2e;&#104;&#x69;&#x74;&#x2e;&#x65;&#x64;&#x6e;&#46;&#x63;&#x6e;</a></u></p>
<ul>
<li>W. Yuan et al., <a target="_blank" rel="noopener" href="https://www.researchgate.net/journal/Physical-Review-B-1095-3795?_tp=eyJjb250ZXh0Ijp7ImZpcnN0UGFnZSI6ImhvbWUiLCJwYWdlIjoicHVibGljYXRpb24iLCJwcmV2aW91c1BhZ2UiOiJwcm9maWxlIiwicG9zaXRpb24iOiJwYWdlSGVhZGVyIn19">Physical Review B</a> 110, 165412 (2024).</li>
</ul>
<h2 id="注意的问题"><a href="#注意的问题" class="headerlink" title="注意的问题"></a>注意的问题</h2><ol>
<li><p>The accuracy of the anharmonic force constants can be checked by increasing the size of the training dataset. If the physical properties, such as thermal conductivity and free energy, change significantly with the size of the training dataset, it indicates that the training is insufficient. If the change is minor, your force constants may be OK.</p>
</li>
<li><p>报错：Warning: The following force constant doesn’t exist in the original file:<br>You can neglect this warning as long as the correction term (the last column) is small.<br>This warning is raised when the absolute value of the correction is larger than 1.0e-10 and the corresponding force constant does not exist in the original FCSXML file. In your case, the correction term is only slightly above the tolerance. So, it should not cause any problems hopefully.<br>When the correction term is much larger than 1.0e-10, this warning indicates a possible error in the inputs. Likely errors are the input structure is not fully symmetrized, or the numerical digits of lattice vectors and fractional coordinates are insufficient.<br>the given KMESH_INTERPOLATE is not commensurate with the supercell size of the original FCSXML.</p>
</li>
<li><p>In the current implementation of alamode, only the former choice,<br>renormalized 2FCs + conventional (old) 3FCs,<br>is supported. Another possible choice may be<br>renormalized 2FCs + renormalized 3FCs,<br>but it is not supported within alamode yet.<br>When MODE &#x3D; RTA, the anphon code only reads the 2FCs and 3FCs from given XML files. By contrast, when MODE &#x3D; SCPH, the code additionally reads the 4FCs because they are necessary to compute the renormalized 2FCs based on the self-consistent phonon theory.<br>Therefore, the second combination of<br>renormalized 2FCs + high order FCs using SCPH<br>is not possible.</p>
</li>
<li><p>I performed the SCPH calculation. It is not converged at low temperatures (0K, 100K, 200K), while it achieved convergence at high temperatures (300~1200K).A potential solution is to use a smaller MIXALPHA and a smaller DT.</p>
</li>
<li><p>I would like to use second-order, third-order, and fourth-order force constants to obtain anharmonic potentials and calculate the potential energy as a function of atomic displacement. My goal is to generate a plot similar to the one in the paper “Orbitally driven giant phonon anharmonicity in SnSe” (Nature Phys. 2015).Please use <a target="_blank" rel="noopener" href="https://github.com/ttadano/alamode/blob/develop/tools/calcpes.py">https://github.com/ttadano/alamode/blob/develop/tools/calcpes.py</a>.</p>
</li>
<li><p>now that I have obtained the renormalized force constant file xxx.xml at a finite temperature, I now want to convert the renormalized force constant file directly to FORCE_CONSTANS</p>
</li>
<li><p>How to convert a second-order force constant matrix obtained by almode to FORCE_CONSTANTS in phonopy format？</p>
<blockquote>
<p>python convert.py alamode.xml &gt; FORCE_CONSTANTS</p>
</blockquote>
</li>
</ol>
<p>Could you give me some suggestion? How shoud I covert this with phonopy?</p>
<blockquote>
<p>FULL_FORCE_CONSTANTS &#x3D; .TRUE.<br>WRITE_FORCE_CONSTANTS &#x3D; .TRUE.<br>Note: the old FORCE_CONSTANTS will be overwrited</p>
</blockquote>
<ol start="8">
<li>How small the fitting error should be?</li>
</ol>
<p>It depends on the Taylor expansion potential and displacement magnitude you choose.<br>In the standard harmonic calculation where –mag&#x3D;0.01 is used in displace.py and the all harmonic interactions are considered (cutoff &#x3D; None), the fitting error is usually less than 5% (~1–2% in most cases).<br>In the calculation of third-order force constants with –mag&#x3D;0.04, the fitting error should be small as well. Indeed, in many cases, we obtain much smaller fitting errors (&lt; 1%) than the harmonic case.<br>In the temperature-dependent effective potential method, we try to fit the harmonic potential to the displacement-force datasets sampled by ab initio molecular dynamics at finite temperature. Therefore, the fitting error tends to be much larger (&gt; 10%).</p>
<h1 id="dynaphopy"><a href="#dynaphopy" class="headerlink" title="dynaphopy"></a>dynaphopy</h1><ol>
<li>简谐声子谱的计算。<br>dynaphopy的非谐修正是在phonopy的力常数基础上进行的，需要先进行0k声子谱的计算。<br>结构优化的INCAR，力的收敛标准是E-3，大部分的文献也是在这个精度范围内。结构优化的结构是单胞，10个原子。<br>这是phonopy计算的声子谱，计算的结构为2<em>2</em>2的超胞，80个原子，在gmma点和X点有很强的虚频。这个虚频即使提高收敛精度和扩大超胞也是无法消除的。</li>
<li>AIMD计算<br>dynaphopy通过读取AIMD的计算结构进行拟合（说法不准确），需要预先准备AIMD的outcar或xdatcar。<br>AIMD的计算设置，基本参考dynaphopy的example中的设置，详细的参数涵义，都有教程介绍。<br>这里只是采用了3000步的计算，步长是2fs，能量的收敛精度是E-6，不算太高。同样是采用80个原子的超胞。大部分做非谐计算的文献，所采用的都是在80-160原子数范围内的超胞，步长多是1-2fs，总步数大概是3000-6000，总的时长是5ps-10ps。从下面的非谐声子谱结果来看，这个设置对于非谐计算是合适的？</li>
<li>dynaphopy非谐声子谱计算。<br>dynaphopy的官网如下：Dynaphopy (abelcarreras.github.io)。<br>将结构优化的原始晶胞POSCAR，phonopy输出的力常数，和AIMD的OUTCAR放在一个文件夹内。<br>设置dynaphopy的输入文件input如下：分别是输入结构文件，力常数文件，原胞和超胞与POSCAR的关系设置，band是声子谱的高对称点路径，设置方式和vasp计算PBE能带一致。<br>然后输入dynaphopy input OUTCAR -i，进入下的界面，选择6，进入非谐声子谱计算，再选择1，可以同时输出简谐声子谱和非简谐声子谱，此时会对peak进行拟合。拟合结束后，会输出声子谱。<br>一开始使用默认设置，输出的声子谱，可以看到高温声子谱虚频加重了。从@get-it 大佬处了解到，dynaphopy默认使用最大熵方法拟合，效果可能不如fftw有效。于是小弟将拟合方式改为fftw,通过指令dynaphopy input OUTCAR -i -psm 3,采用快速傅里叶变换拟合。得到300k下的声子谱，可以看到，原来gamma点和X点的虚频，已经被成功消除了。而实验上，这个材料在室温下肯定是稳定的。</li>
</ol>
<p>当然，如果想要得到更准确的声子谱，需要提高优化精度，采用更大的超胞计算力常数，AIMD需要更多的步数和更小的步长，比如dynaphopy的例子是采用0.7 fs,跑200000步。如果只是想得到一个比较合理的声子谱，适当降低精度是没问题的。比如这个计算，在24核的机器上，结构优化用时不到3小时，dfpt计算1小时，AIMD计算14小时，差不多用时一天，能够得到一个比较合适的声子谱。如果提高精度，计算用时可能会提升数倍，但是声子谱的提升可能并不会太明显。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/09/18-49-25/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/09/18-49-25/" class="post-title-link" itemprop="url">3.3 电声耦合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-09 18:49:25" itemprop="dateCreated datePublished" datetime="2023-05-09T18:49:25+08:00">2023-05-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-15 15:59:43" itemprop="dateModified" datetime="2024-06-15T15:59:43+08:00">2024-06-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MC-电声耦合"><a href="#MC-电声耦合" class="headerlink" title="MC-电声耦合"></a>MC-电声耦合</h1><p>需要vasp6.0之后的版本,INCAR开启</p>
<p>PHON_LMC &#x3D; .TRUE.<br>IBRION &#x3D; 6</p>
<h2 id="全MC采样"><a href="#全MC采样" class="headerlink" title="全MC采样"></a>全MC采样</h2><ul>
<li><p>标签PHON_NSTRUCT设置由于MC抽样而生成的结构的数量。应该监视观测值相对于这个数量的收敛。</p>
</li>
<li><p>标签TEBEG&#x3D;0也是需要的，用于选择运行抽样的温度。</p>
</li>
<li><p>另外，PHON_LBOSE可以设置为.TRUE.或.FALSE. (默认PHON_LBOSE&#x3D;.TRUE.)，分别选择玻色-爱因斯坦统计或麦克斯韦-玻尔兹曼统计。</p>
</li>
</ul>
<p>0K的一个INCAR文件如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System = DEFAULT</span><br><span class="line">PREC = Accurate</span><br><span class="line">ISMEAR = 0; SIGMA = 0.1;</span><br><span class="line">IBRION = 6</span><br><span class="line"></span><br><span class="line">PHON_LMC = .TRUE.</span><br><span class="line">PHON_NSTRUCT = 100</span><br><span class="line">TEBEG = 0.0</span><br></pre></td></tr></table></figure>
<p>随后生成Wycoff positions畸变的许多POSCAR，输出为POSCAR.TEBEG.NUMBER</p>
<h2 id="ZG-configuration即时采样（one-shot）"><a href="#ZG-configuration即时采样（one-shot）" class="headerlink" title="ZG configuration即时采样（one-shot）"></a>ZG configuration即时采样（one-shot）</h2><p>这种方法仅使用单一的扭曲结构，因此比完全的MC抽样快上几个数量级，同时保持了与收敛的超晶胞尺寸的完全MC抽样非常接近的准确性。例如，我们展示了对于带隙的零点重整化，准确度在ZG配置和完全MC抽样之间在5毫电子伏特之内。因此，我们建议优先使用这种方法，当很难实现超晶胞尺寸的收敛或者5毫电子伏特的精度已经足够时。</p>
<ol>
<li>输入<br>要选择ZG配置，必须在INCAR文件中设置<code>PHON_NSTRUCT=0</code>。不同温度的数量和温度列表（以K为单位）必须使用标签<code>PHON_NTLIST</code>和<code>PHON_TLIST</code>，在INCAR文件中分别提供。一个示例如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PHON_NTLIST = 4</span><br><span class="line">PHON_TLIST = 0.0 100.0 200.0 350.0</span><br></pre></td></tr></table></figure></li>
</ol>
<p>给出了一个温度范围为0-700K（步长为100K）的示例INCAR文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System = DEFAULT</span><br><span class="line">PREC = Accurate</span><br><span class="line">ISMEAR = 0; SIGMA = 0.1;</span><br><span class="line">IBRION = 6</span><br><span class="line">PHON_NTLIST = 8</span><br><span class="line">PHON_TLIST = 0.0 100.0 200.0 300.0 400.0 500.0 600.0 700.0</span><br><span class="line">PHON_NSTRUCT = 0</span><br><span class="line">PHON_LMC = .TRUE.</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>输出</li>
</ol>
<p>类似于MC抽样，ZG配置方法会产生多个具有不同扭曲Wycoff位置但不变的布里渊矩阵的POSCAR文件。这些文件被标记为</p>
<p><code>POSCAR.TEMP</code><br>其中TEMP遍历由PHON_TLIST定义的所有温度。</p>
<h2 id="one-shot例子（金刚石带隙重整化）"><a href="#one-shot例子（金刚石带隙重整化）" class="headerlink" title="one-shot例子（金刚石带隙重整化）"></a>one-shot例子（金刚石带隙重整化）</h2><h3 id="输入文件"><a href="#输入文件" class="headerlink" title="输入文件"></a>输入文件</h3><p>INCAR：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">general:</span><br><span class="line"> System = cd-C</span><br><span class="line"> PREC = Accurate</span><br><span class="line"> ALGO = FAST</span><br><span class="line"> ISMEAR = 0 </span><br><span class="line"> SIGMA = 0.1;</span><br><span class="line"> IBRION = 6         #获得动力学矩阵声子计算</span><br><span class="line"> PHON_LMC = .TRUE.  #开启电声耦合计算</span><br><span class="line"> PHON_NSTRUCT = 0   #选择one-shot方法</span><br><span class="line"> PHON_NTLIST = 1    #温度点个数</span><br><span class="line"> PHON_TLIST = 0.0   #对应温度</span><br></pre></td></tr></table></figure>
<p>准备优化后的结构，需要扩胞，以保证声子准确。KPOINTS、POTCAR根据POSCAR调整。</p>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>一、获得结构</p>
<p>按照超胞结构和上面的INCAR提交任务，结束后获得OUTCAR。<br>执行： <code>cp OUTCAR OUTCAR.init</code><br>新的畸变后的结构输出为POSCAR.T&#x3D;0.</p>
<p>二、计算特定位移畸变结构的电子能级</p>
<p> <code>cp POSCAR.T=0. POSCAR</code></p>
<p>INCAR 修改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> System = cd-C</span><br><span class="line">PREC = Accurate</span><br><span class="line">ALGO = FAST</span><br><span class="line">ISMEAR = 0 </span><br><span class="line">SIGMA = 0.1  #去掉PHON_标签</span><br></pre></td></tr></table></figure>
<p>执行计算，完成后<code>cp OUTCAR OUTCAR.T=0.</code></p>
<p>三、 提取ZPR</p>
<p>具有特殊位移的带隙减去没有特殊位移的带隙，就可以得到零点带隙重整的值。带隙保存在OUTCAR文件里。</p>
<p>执行例子中的脚本：<code>bash extract_zpr.sh</code>,<br>脚本内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash </span><br><span class="line"></span><br><span class="line">i=&quot;OUTCAR.T=0.&quot;</span><br><span class="line">j=&quot;OUTCAR.init&quot;</span><br><span class="line"></span><br><span class="line">homo1=`awk &#x27;/NELECT/ &#123;print $3/2&#125;&#x27; $i`</span><br><span class="line">homo2=`awk &#x27;/NELECT/ &#123;print $3/2-1&#125;&#x27; $i`</span><br><span class="line">homo3=`awk &#x27;/NELECT/ &#123;print $3/2-2&#125;&#x27; $i`</span><br><span class="line">lumo1=`awk &#x27;/NELECT/ &#123;print $3/2+var+1&#125;&#x27; $i`</span><br><span class="line">lumo2=`awk &#x27;/NELECT/ &#123;print $3/2+var+2&#125;&#x27; $i`</span><br><span class="line">lumo3=`awk &#x27;/NELECT/ &#123;print $3/2+var+3&#125;&#x27; $i`</span><br><span class="line">lumo4=`awk &#x27;/NELECT/ &#123;print $3/2+var+4&#125;&#x27; $i`</span><br><span class="line">lumo5=`awk &#x27;/NELECT/ &#123;print $3/2+var+5&#125;&#x27; $i`</span><br><span class="line">lumo6=`awk &#x27;/NELECT/ &#123;print $3/2+var+6&#125;&#x27; $i`</span><br><span class="line">e1a=`grep &quot;   $homo1  &quot; $i | head -$nkpt | sort -n -k 2 | tail -1 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">e1b=`grep &quot;   $homo2  &quot; $i | head -$nkpt | sort -n -k 2 | tail -1 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">e1c=`grep &quot;   $homo3  &quot; $i | head -$nkpt | sort -n -k 2 | tail -1 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">e2a=`grep &quot;   $lumo1  &quot; $i | head -$nkpt | sort -n -k 2 | head -1 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">e2b=`grep &quot;   $lumo2  &quot; $i | head -$nkpt | sort -n -k 2 | head -1 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">e2c=`grep &quot;   $lumo3  &quot; $i | head -$nkpt | sort -n -k 2 | head -1 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">e2d=`grep &quot;   $lumo4  &quot; $i | head -$nkpt | sort -n -k 2 | head -1 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">e2e=`grep &quot;   $lumo5  &quot; $i | head -$nkpt | sort -n -k 2 | head -1 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">e2f=`grep &quot;   $lumo6  &quot; $i | head -$nkpt | sort -n -k 2 | head -1 | awk &#x27;&#123;print $2&#125;&#x27;`   </span><br><span class="line"> </span><br><span class="line">homo_ref=`awk &#x27;/NELECT/ &#123;print $3/2&#125;&#x27; $j`</span><br><span class="line">lumo_ref=`awk &#x27;/NELECT/ &#123;print $3/2+var+1&#125;&#x27; $j`</span><br><span class="line"></span><br><span class="line">h_ref=`grep &quot;   $homo_ref  &quot; $j | head -$nkpt | sort -n -k 2 | tail -1 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">l_ref=`grep &quot;   $lumo_ref  &quot; $j | head -$nkpt | sort -n -k 2 | head -1 | awk &#x27;&#123;print $2&#125;&#x27;`  </span><br><span class="line"> </span><br><span class="line">echo &quot;The band gap (in eV) without zero-point vibrations is:&quot;</span><br><span class="line">echo &quot;$h_ref $l_ref&quot; |awk &#x27;&#123;print ($2-$1)&#125;&#x27;</span><br><span class="line">echo &quot;The band gap (in eV) including zero-point vibrations is:&quot;</span><br><span class="line">echo &quot;$e1a $e1b $e1c $e2a $e2b $e2c $e2d $e2e $e2f&quot; |awk &#x27;&#123;print (($4+$5+$6+$7+$8+$9)/6.0-($1+$2+$3)/3.0)&#125;&#x27;</span><br><span class="line">echo &quot;The zero-point renormalization of the band gap (in eV) is:&quot; </span><br><span class="line">echo &quot;$e1a $e1b $e1c $e2a $e2b $e2c $e2d $e2e $e2f $h_ref $l_ref&quot; |awk &#x27;&#123;print (($4+$5+$6+$7+$8+$9)/6.0-($1+$2+$3)/3.0)-($11-$10)&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The band gap (in eV) without zero-point vibrations is:</span><br><span class="line">4.4049</span><br><span class="line">The band gap (in eV) including zero-point vibrations is:</span><br><span class="line">4.05102</span><br><span class="line">The zero-point renormalization of the band gap (in eV) is:</span><br><span class="line">-0.353883</span><br></pre></td></tr></table></figure>
<h3 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h3><p>精度取决于超胞大小。超胞越大越准确。</p>
<h2 id="温度依赖的带隙计算"><a href="#温度依赖的带隙计算" class="headerlink" title="温度依赖的带隙计算"></a>温度依赖的带隙计算</h2><h3 id="输入文件-1"><a href="#输入文件-1" class="headerlink" title="输入文件"></a>输入文件</h3><p>INCAR：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> System = cd-C</span><br><span class="line"> PREC = Accurate</span><br><span class="line"> ALGO = FAST</span><br><span class="line"> ISMEAR = 0 </span><br><span class="line"> SIGMA = 0.1;</span><br><span class="line"> IBRION = 6         #获得动力学矩阵声子计算</span><br><span class="line"> PHON_LMC = .TRUE.  #开启电声耦合计算</span><br><span class="line"> PHON_NSTRUCT = 0   #选择one-shot方法</span><br><span class="line">PHON_NTLIST = 8     #温度个数</span><br><span class="line">PHON_TLIST = 0.0 100.0 200.0 300.0 400.0 500.0 600.0 700.0</span><br></pre></td></tr></table></figure>
<p>准备优化后的结构，需要扩胞，以保证声子准确。KPOINTS、POTCAR根据POSCAR调整。</p>
<h3 id="计算-1"><a href="#计算-1" class="headerlink" title="计算"></a>计算</h3><p>一、 获取特定位移的结构</p>
<p>按照超胞结构和上面的INCAR提交任务，结束后获得OUTCAR。<br>执行： <code>cp OUTCAR OUTCAR.init</code><br>新的畸变后的结构输出为POSCAR.T&#x3D;0. ~ POSCAR.T&#x3D;700.</p>
<p>二、计算特定位移畸变结构的电子能级<br> <code>cp POSCAR.T=0. POSCAR</code></p>
<p>INCAR 修改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> System = cd-C</span><br><span class="line">PREC = Accurate</span><br><span class="line">ALGO = FAST</span><br><span class="line">ISMEAR = 0 </span><br><span class="line">SIGMA = 0.1  #去掉PHON_标签</span><br></pre></td></tr></table></figure>
<p>对每个温度下的结构执行计算。可通过脚本<code>run_temperature.sh</code>批量提交。<br>脚本内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># please enter your executable path here</span><br><span class="line">vasp_exec=./vasp_gam</span><br><span class="line"></span><br><span class="line">#please enter the number of processors used for VASP here</span><br><span class="line">np=8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in 0 100 200 300 400 500 600 700</span><br><span class="line">do</span><br><span class="line">   cp POSCAR.T\=$i. POSCAR</span><br><span class="line">   mpirun -np $np $vasp_exec</span><br><span class="line">   mv OUTCAR OUTCAR.T\=$i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>三、 分析OUTCAR</p>
<p>利用脚本<code>extract_temp.sh</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">!/bin/bash </span><br><span class="line"></span><br><span class="line">if [ -f gap_vs_temp.dat ]</span><br><span class="line">then</span><br><span class="line">   rm gap_vs_temp.dat</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">touch gap_vs_temp.dat</span><br><span class="line">counter=0</span><br><span class="line"></span><br><span class="line">for temp in 0 100 200 300 400 500 600 700</span><br><span class="line">do</span><br><span class="line">   i=&quot;OUTCAR.T=$temp&quot;</span><br><span class="line"></span><br><span class="line">   homo1=`awk &#x27;/NELECT/ &#123;print $3/2&#125;&#x27; $i`</span><br><span class="line">   homo2=`awk &#x27;/NELECT/ &#123;print $3/2-1&#125;&#x27; $i`</span><br><span class="line">   homo3=`awk &#x27;/NELECT/ &#123;print $3/2-2&#125;&#x27; $i`</span><br><span class="line">   lumo1=`awk &#x27;/NELECT/ &#123;print $3/2+var+1&#125;&#x27; $i`</span><br><span class="line">   lumo2=`awk &#x27;/NELECT/ &#123;print $3/2+var+2&#125;&#x27; $i`</span><br><span class="line">   lumo3=`awk &#x27;/NELECT/ &#123;print $3/2+var+3&#125;&#x27; $i`</span><br><span class="line">   lumo4=`awk &#x27;/NELECT/ &#123;print $3/2+var+4&#125;&#x27; $i`</span><br><span class="line">   lumo5=`awk &#x27;/NELECT/ &#123;print $3/2+var+5&#125;&#x27; $i`</span><br><span class="line">   lumo6=`awk &#x27;/NELECT/ &#123;print $3/2+var+6&#125;&#x27; $i`</span><br><span class="line">   e1a=`grep &quot;^    $homo1   &quot; $i | head -$nkpt | sort -n -k 2 | tail -1 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">   e1b=`grep &quot;^    $homo2   &quot; $i | head -$nkpt | sort -n -k 2 | tail -1 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">   e1c=`grep &quot;^    $homo3   &quot; $i | head -$nkpt | sort -n -k 2 | tail -1 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">   e2a=`grep &quot;^    $lumo1   &quot; $i | head -$nkpt | sort -n -k 2 | head -1 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">   e2b=`grep &quot;^    $lumo2   &quot; $i | head -$nkpt | sort -n -k 2 | head -1 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">   e2c=`grep &quot;^    $lumo3   &quot; $i | head -$nkpt | sort -n -k 2 | head -1 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">   e2d=`grep &quot;^    $lumo4   &quot; $i | head -$nkpt | sort -n -k 2 | head -1 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">   e2e=`grep &quot;^    $lumo5   &quot; $i | head -$nkpt | sort -n -k 2 | head -1 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">   e2f=`grep &quot;^    $lumo6   &quot; $i | head -$nkpt | sort -n -k 2 | head -1 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">   if [ $temp -eq &quot;0&quot; ]</span><br><span class="line">   then</span><br><span class="line">      ref=`echo &quot;$e1a $e1b $e1c $e2a $e2b $e2c $e2d $e2e $e2f&quot; |awk &#x27;&#123;print (($4+$5+$6+$7+$8+$9)/6.0-($1+$2+$3)/3.0)&#125;&#x27;`</span><br><span class="line">   fi</span><br><span class="line"></span><br><span class="line">   echo &quot;$e1a $e1b $e1c $e2a $e2b $e2c $e2d $e2e $e2f $temp $ref&quot; |awk &#x27;&#123;print $10,(($4+$5+$6+$7+$8+$9)/6.0-($1+$2+$3)/3.0)-$11&#125;&#x27; &gt;&gt; gap_vs_temp.dat</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>运行脚本后生成gap_vs_temp.dat文件，画图即可。</p>
<p>gnuplot画图：<br><code>gnuplot -e &quot;set terminal jpeg;set xlabel &#39;T (K)&#39;; set ylabel &#39;band gap&#39;; set style data lines; plot &#39;gap_vs_temp.dat&#39;, &#39;C_exp_points_offset0.dat&#39; w circles, &#39;C_exp_fit_offset0.dat&#39;&quot; &gt; gap_vs_temp.jpg</code></p>
<h2 id="包含体积效应的温度依赖带隙"><a href="#包含体积效应的温度依赖带隙" class="headerlink" title="包含体积效应的温度依赖带隙"></a>包含体积效应的温度依赖带隙</h2><p>仅考虑温度效应会低估带隙，要考虑体积效应。</p>
<p>一、准简谐近似方法获得体积变化</p>
<p>三个脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quasi_harm_4x4x4_diamond_create_pos_and_run_vasp.sh</span><br><span class="line">quasi_harm_4x4x4_diamond_make_energy_vs_volume_plots.sh</span><br><span class="line">quasi_harm_4x4x4_diamond_obtain_fitting.sh</span><br></pre></td></tr></table></figure>


<p>对超胞结构创建不同体积的结构进行体积-能量计算：</p>
<p>运行脚本：<code>quasi_harm_4x4x4_diamond_create_pos_and_run_vasp.sh</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line"></span><br><span class="line"># please enter your executable path here</span><br><span class="line">vasp_exec=./vasp_gam</span><br><span class="line"></span><br><span class="line">#please enter the number of processors used for VASP here</span><br><span class="line">np=8</span><br><span class="line"></span><br><span class="line">cp INCAR.qh INCAR</span><br><span class="line"></span><br><span class="line">for i in 6.13521592 6.27789536 6.4205748 6.56325424 6.70593368 6.84861312 6.99129256 7.133972 7.27665144 7.41933088 7.56201032 7.70468976 7.8473692 7.99004864 8.13272808</span><br><span class="line">do</span><br><span class="line">sed &quot;s/7.13397200/$&#123;i&#125;/g&quot; POSCAR.4x4x4 &gt; POSCAR_$i</span><br><span class="line">cp POSCAR_$i POSCAR</span><br><span class="line">mpirun -np 8 $vasp_exec</span><br><span class="line"></span><br><span class="line">mv OUTCAR OUTCAR_$i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>该脚本创建15个POSCAR，体积每步变化2%,运行脚本<code>quasi_harm_4x4x4_diamond_create_pos_and_run_vasp.sh</code>提交计算。</p>
<p>二、计算完成后运行<code>quasi_harm_4x4x4_diamond_make_energy_vs_volume_plots.sh</code>数据处理。<br>脚本内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">bandshift=0</span><br><span class="line">gwrun=-1</span><br><span class="line">dgbd=-1</span><br><span class="line">val=-1</span><br><span class="line">con=-1</span><br><span class="line">gwldadiff=-1</span><br><span class="line">test=-1</span><br><span class="line">while [[ $# -gt 0 ]]</span><br><span class="line">do</span><br><span class="line">   key=&quot;$1&quot;</span><br><span class="line">   case $key in</span><br><span class="line">   esac</span><br><span class="line">   shift</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">if [ -f &quot;helpscript.perl&quot; ]; then</span><br><span class="line">   rm helpscript.perl</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat &gt; helpscript.perl  &lt;&lt;EOF</span><br><span class="line">#!/bin/perl</span><br><span class="line"></span><br><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">my \$zahler=0;</span><br><span class="line">my @entropy=0;</span><br><span class="line">my \$ezp=0;</span><br><span class="line">my \$fhelmholtz=0;</span><br><span class="line">my \$uenergy;</span><br><span class="line">my \$kboltzmann=8.6173303*10**(-5.0);</span><br><span class="line">my \$ntemp=8;</span><br><span class="line">my \$tmax=700;</span><br><span class="line">my \$tmin=0;</span><br><span class="line">my \$tstep=100;</span><br><span class="line">for (my \$itemp=1;\$itemp&lt;=\$ntemp;\$itemp++)</span><br><span class="line">&#123;</span><br><span class="line">   \$entropy[\$itemp]=0;</span><br><span class="line">&#125;</span><br><span class="line">while (&lt;&gt;)</span><br><span class="line">&#123;</span><br><span class="line">   chomp;</span><br><span class="line">   \$_=~s/^/ /;</span><br><span class="line">   my @help=split(/[\t,\s]+/);</span><br><span class="line">   \$zahler=\$zahler+1;</span><br><span class="line">   if (\$zahler == 1) &#123;\$uenergy=\$help[1];&#125;</span><br><span class="line">   else </span><br><span class="line">   &#123;</span><br><span class="line">      my \$homega=\$help[2]/1000;</span><br><span class="line">      \$ezp=\$ezp+\$homega*0.5;</span><br><span class="line">      for (my \$itemp=1;\$itemp&lt;=\$ntemp;\$itemp++)</span><br><span class="line">      &#123;</span><br><span class="line">         my \$temp=(\$itemp-1)*\$tstep+\$tmin;</span><br><span class="line">         my \$kbt=\$kboltzmann*\$temp;</span><br><span class="line">         if (\$temp &lt; 0.0000001) </span><br><span class="line">         &#123;</span><br><span class="line">         &#125;</span><br><span class="line">         else</span><br><span class="line">         &#123;</span><br><span class="line">              \$entropy[\$itemp]=\$entropy[\$itemp]-\$kboltzmann*log(1-exp(-\$homega/\$kbt));</span><br><span class="line">              \$entropy[\$itemp]=\$entropy[\$itemp]+\$kboltzmann*\$homega/\$kbt*(1/(exp(\$homega/\$kbt)-1));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   last if eof;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\$ezp=\$ezp; #/ \$zahler;</span><br><span class="line"></span><br><span class="line">for (my \$itemp=1;\$itemp&lt;=\$ntemp;\$itemp++)</span><br><span class="line">&#123;</span><br><span class="line">    my \$temp=(\$itemp-1)*\$tstep+\$tmin;</span><br><span class="line">        </span><br><span class="line">    \$entropy[\$itemp]=\$entropy[\$itemp]; # / \$zahler; </span><br><span class="line">    \$fhelmholtz=\$uenergy+\$ezp-\$temp*\$entropy[\$itemp];</span><br><span class="line">    printf (&quot;%15.8e %15.8e\n&quot;,\$temp,\$fhelmholtz);</span><br><span class="line">&#125;</span><br><span class="line">printf (&quot;#NOTEMP %15.8e\n&quot;,\$uenergy);</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">rm OUTTEMP*</span><br><span class="line">first=0</span><br><span class="line">for i in OUTCAR_*; do</span><br><span class="line"></span><br><span class="line">   echo &quot;Starting $i&quot;</span><br><span class="line">   v2=$&#123;i##OUTCAR_&#125;</span><br><span class="line">   if [ -f &quot;helpfile.help&quot; ]; then</span><br><span class="line">      rm helpfile.help</span><br><span class="line">   fi</span><br><span class="line">   touch helpfile.help</span><br><span class="line">   cp OUTCAR_$v2 OUTCAR</span><br><span class="line">   awk &#x27;/free energy/&#x27; OUTCAR | tail -n 1| awk &#x27;&#123;print $5&#125;&#x27; &gt;&gt; helpfile.help</span><br><span class="line">   awk &#x27;/[0-9]* f .* THz/ &#123;print $1,$10&#125;&#x27; OUTCAR &gt;&gt; helpfile.help</span><br><span class="line">   awk &#x27;/[0-9]* f.i.*THz/ &#123;print $1,$9&#125;&#x27; OUTCAR &gt;&gt; helpfile.help</span><br><span class="line">   volume=`awk &#x27;/volume of cell/ &#123;print $5&#125;&#x27; OUTCAR | tail -n 1`</span><br><span class="line"></span><br><span class="line">   perl helpscript.perl helpfile.help &gt; hhhhelp.txt</span><br><span class="line"></span><br><span class="line">   runcount=0</span><br><span class="line">   while read line; do</span><br><span class="line">      runcount=$((runcount+1))</span><br><span class="line">      if [[ $first -eq 0 ]]; then</span><br><span class="line">         echo $line | awk -v var=&quot;$volume&quot; &#x27;&#123;print var,$2,$1&#125;&#x27; &gt; OUTTEMP_$runcount</span><br><span class="line">      else</span><br><span class="line">         echo $line | awk -v var=&quot;$volume&quot; &#x27;&#123;print var,$2&#125;&#x27; &gt;&gt; OUTTEMP_$runcount</span><br><span class="line">      fi</span><br><span class="line">   done &lt; ./hhhhelp.txt</span><br><span class="line"></span><br><span class="line">   first=1</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for i in OUTTEMP_*; do</span><br><span class="line">   v2=$&#123;i##OUTTEMP_&#125;</span><br><span class="line">   mv OUTTEMP_$v2 OUTHELP</span><br><span class="line">   sort -n -k 1 OUTHELP &gt; OUTTEMP_$v2</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">rm helpfile.help</span><br><span class="line">rm helpscript.perl</span><br><span class="line">rm hhhhelp.txt</span><br><span class="line">rm OUTHELP</span><br></pre></td></tr></table></figure>
<p>自由能曲线保存在OUTTEMP_*.</p>
<p>运行脚本<code>quasi_harm_4x4x4_diamond_obtain_fitting.sh</code>获得温度-体积关系。<br>脚本内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">for i in OUTTEMP_*</span><br><span class="line">do</span><br><span class="line">   cp $i OUTTEMP.current</span><br><span class="line">   #extract temperature</span><br><span class="line">   temp=`head -n 1 OUTTEMP.current|awk &#x27;&#123;print $3&#125;&#x27;`</span><br><span class="line">   #do fitting</span><br><span class="line">   gnuplot -e &quot;E(V)=E0+9.0/8.0*B0*V0*((V0/V)**(2.0/3.0)-1)**2 + 9.0/16.0*B0*\</span><br><span class="line">      (B0P-4)*V0*((V0/V)**(2.0/3.0)-1.0)**3.0 + R*((V0/V)**(2.0/3.0)-1.0)**4.0;\</span><br><span class="line">      B0P = 1;B0 = 1;V0 = 720;E0 = -1150;R  = -1.0;fit E(x) &#x27;OUTTEMP.current&#x27;  u 1:2 via B0P,B0,V0,E0,R&quot; &amp;&gt; suppress_output</span><br><span class="line">   #extract volume from fit</span><br><span class="line">   a=`grep &quot;V0&quot; fit.log|grep &quot;=&quot; |tail -n 1|awk &#x27;&#123;print ($3/2.0)**(1.0/3.0)&#125;&#x27;`</span><br><span class="line">   #print temperature and volume to </span><br><span class="line">   echo &quot;temperature: $temp, a_latt: $a&quot; </span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">rm suppress_output</span><br><span class="line">rm OUTTEMP.current</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">temperature: 0.00000000e+00, a_latt: 7.18012</span><br><span class="line">temperature: 1.00000000e+02, a_latt: 7.18014</span><br><span class="line">temperature: 2.00000000e+02, a_latt: 7.18064</span><br><span class="line">temperature: 3.00000000e+02, a_latt: 7.18267</span><br><span class="line">temperature: 4.00000000e+02, a_latt: 7.18613</span><br><span class="line">temperature: 5.00000000e+02, a_latt: 7.19037</span><br><span class="line">temperature: 6.00000000e+02, a_latt: 7.19493</span><br><span class="line">temperature: 7.00000000e+02, a_latt: 7.19959</span><br><span class="line">temperature: #NOTEMP, a_latt: 7.15218</span><br></pre></td></tr></table></figure>
<p>三、 最后将QHA获得的晶胞参数，替换掉POSCAR.T&#x3D;* files中的晶胞参数。再次运行<code>run_temperature.sh</code> 和<code>extract_temp.sh.</code>获得数据画图。</p>
<ul>
<li><p>通过添加体积效应，与实验获得了更好的一致性。在这个教程中，我们只使用了一个4x4x4的单元格，因为更大的单元格已经相当耗时，但对于收敛的5x5x5单元格，两条曲线都应该与实验相比略有变差。由于在本例中使用的PBE无法充分描述电子交换和相关性，因此预计实验与理论之间会有差异。为了获得真正的优异一致性，<strong>需要使用GW近似方法</strong>。</p>
</li>
<li><p>严格来说，将体积效应添加到电子-声子相互作用的正确方法是<strong>首先为每个温度更改体积，然后为该温度计算电子-声子相互作用</strong>。在这个教程和参考文献[5]中，我们是反过来做的。因此，电子-声子相互作用只需要计算一次。在参考文献[5]中，我们观察到这两种方法给出了非常相似的结果。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Keke Liu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
