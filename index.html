<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.16.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一个小学生的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Lightchaser">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Lightchaser">
<meta property="og:description" content="一个小学生的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Keke Liu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Lightchaser</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Lightchaser</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">三人行，必有我师</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Keke Liu</p>
  <div class="site-description" itemprop="description">一个小学生的博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/stemdkk" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;stemdkk" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:257198@whut.edu.cn" title="E-Mail → mailto:257198@whut.edu.cn" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/11/18-47-24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/03/11/18-47-24/" class="post-title-link" itemprop="url">10.1 铁电极化计算</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-03-11 18:47:24" itemprop="dateCreated datePublished" datetime="2025-03-11T18:47:24+08:00">2025-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-22 17:23:12" itemprop="dateModified" datetime="2025-04-22T17:23:12+08:00">2025-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>铁电极化强度（ferroelectric polarization）是指在铁电材料中，由外加电场引起的电偶极矩的强度。铁电材料是一类具有自发极化特性的材料，即在没有外加电场时，这些材料内部的电偶极矩已经排列成某种方向。铁电极化强度描述了这种极化的强弱，它是材料的重要电学特性之一。</p>
<h2 id="四种常见的铁电起源"><a href="#四种常见的铁电起源" class="headerlink" title="四种常见的铁电起源"></a>四种常见的铁电起源</h2><ol>
<li><p>离子偏移<br>这种是最常见的铁电类型，比如BaTiO3中的Ti离子偏移中心位置；CuInP2S6中Cu离子上(下)偏移中心位置诱导的极化上(下)</p>
</li>
<li><p>极性分子团(polar molecular groups)比如有机-无机杂化材料的中一维（1D）和二维（2D）结构的杂化铁电材料，由极性分子诱导铁电。</p>
</li>
<li><p>电荷重布居(Charge redistribution)通过相邻层的占据态与邻近层的未占据态之间的杂化，可以实现层间电荷的重新分布，从而诱导出平面外的电偶极子，比如滑移铁电。</p>
</li>
<li><p>自旋比如正交晶系的TbMnO3，它具有非共线自旋结构的反铁磁性，通过逆Dzyaloshinskii Moriya相互作用产生净电极化。</p>
</li>
</ol>
<p>下面介绍两种VASP计算铁电极化强度的方法。第一种，也是目前文献中最常见的方法，Berry phase方法。此外，还可以通过其他方法来计算。偶极矫正法是一种通过直接计算材料中偶极矩来估算铁电材料极化强度的简化方法。它通常用于快速评估铁电材料的极化强度，特别是在不需要高精度结果或没有使用现代极化理论（如 Berry 相位方法）的情况下。</p>
<h1 id="例子1：离子型铁电"><a href="#例子1：离子型铁电" class="headerlink" title="例子1：离子型铁电"></a>例子1：离子型铁电</h1><p>本文主要计算经典的铁电材料 BaTiO3 的极化强度。</p>
<p>原文链接:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ghzhan/articles/16305679.html">https://www.cnblogs.com/ghzhan/articles/16305679.html</a></p>
<p>BaTiO3 是钙钛矿结构，它的铁电相结构和中心对称结构如图所示，属于四方晶系。<br>该铁电材料是沿着 c 方向极化，主要是 O 离子和 Ti 离子的移动的贡献。 例如，上图中的左边铁电相极化方向朝下，右边铁电相极化方向朝上。极化强度详细计算步骤如下:</p>
<h2 id="1-结构优化"><a href="#1-结构优化" class="headerlink" title="1 结构优化"></a>1 结构优化</h2><p>先构造 BaTiO3 两种极化方向的晶格结构，并用 VASP 进行结构优化得到 CONTCAR；<br>铁电相POSCAR<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Ti   Ba   O    </span><br><span class="line">1.00000000000000       </span><br><span class="line"> 3.9944999999999999   0.0000000000000000   0.0000000000000000   </span><br><span class="line"> 0.0000000000000000   3.9944999999999999  -0.0000000000000000   </span><br><span class="line"> 0.0000000000000000   0.0000000000000000   4.0335000000000001</span><br><span class="line"> Ti   Ba   O </span><br><span class="line"> 1  1  3  </span><br><span class="line"> Direct  </span><br><span class="line"> 0.5000000000000000  0.5000000000000000  0.5142700000000000    </span><br><span class="line"> 0.0000000000000000 -0.0000000000000000  0.0000000000000000    </span><br><span class="line"> 0.5000000000000000  0.5000000000000000  0.9744770000000000    </span><br><span class="line"> 0.5000000000000000  0.0000000000000000  0.4876180000000000    </span><br><span class="line"> 0.0000000000000000  0.5000000000000000  0.4876180000000000</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Ti   Ba   O    </span><br><span class="line">1.00000000000000        </span><br><span class="line">3.9944999999999999   0.0000000000000000   0.0000000000000000   </span><br><span class="line">0.0000000000000000   3.9944999999999999  -0.0000000000000000   </span><br><span class="line">0.0000000000000000   0.0000000000000000   4.0335000000000001</span><br><span class="line">Ti   Ba   O </span><br><span class="line">1  1  3  </span><br><span class="line">Direct  </span><br><span class="line">0.5000000000000000  0.5000000000000000  0.4857300000000000    </span><br><span class="line">0.0000000000000000 -0.0000000000000000  0.0000000000000000    </span><br><span class="line">0.5000000000000000  0.5000000000000000  0.0255230000000000    </span><br><span class="line">0.5000000000000000  0.0000000000000000  0.5123820000000000    </span><br><span class="line">0.0000000000000000  0.5000000000000000  0.5123820000000000</span><br></pre></td></tr></table></figure>

<p>中心对称相POSCAR</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Ti   Ba   O    </span><br><span class="line">1.00000000000000        </span><br><span class="line">3.9944999999999999   0.0000000000000000   0.0000000000000000   </span><br><span class="line">0.0000000000000000   3.9944999999999999  -0.0000000000000000   </span><br><span class="line">0.0000000000000000   0.0000000000000000   4.0335000000000001</span><br><span class="line">Ti   Ba   O </span><br><span class="line">1  1  3  </span><br><span class="line">Direct  </span><br><span class="line">0.5000000000000000  0.5000000000000000  0.5000000000000000    </span><br><span class="line">0.0000000000000000  0.0000000000000000  0.0000000000000000    </span><br><span class="line">0.5000000000000000  0.5000000000000000  0.0000000000000000    </span><br><span class="line">0.5000000000000000  0.0000000000000000  0.5000000000000000    </span><br><span class="line">0.0000000000000000  0.5000000000000000  0.5000000000000000</span><br></pre></td></tr></table></figure>

<h2 id="2-产生相对位移结构"><a href="#2-产生相对位移结构" class="headerlink" title="2 产生相对位移结构"></a>2 产生相对位移结构</h2><p>将上一步优化后的两个结构分别放入创建好的 ini, fin 文件夹。利用 NEB 的 nebmake.pl 命令产生这两种极化方向的中间过渡结构 (vtst下载地址: Download — Transition State Tools for VASP (utexas.edu))，具体命令为：nebmake.pl ini&#x2F;CONTCAR fin&#x2F;CONTCAR 32<br>这里的 ‘32’ 是表示产生中间过渡的 32 种结构。执行上述命令后，当前文件夹下会产生 00, 01, 02, …, 33 个文件夹，每个文件夹下有一个 POSCAR 文件。</p>
<h2 id="3-自洽极化强度计算"><a href="#3-自洽极化强度计算" class="headerlink" title="3 自洽极化强度计算"></a>3 自洽极化强度计算</h2><p>对每个文件夹的结构进行一次 VASP 自洽运算，INCAR 文件里面需要额外设置 DIPOL 和 LCALPOL 参数。DIPOL 参数可以选取任一坐标，但是保证同一体系采用相同值。 LCALPOL 参数是打开 极化运算。</p>
<p>INCAR 文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SYSTEM=BaTiO3</span><br><span class="line">ISTART =0</span><br><span class="line">ICHARG =2</span><br><span class="line">PREC   =Accurate</span><br><span class="line">ENCUT  =520</span><br><span class="line">EDIFF  =0.1E-07</span><br><span class="line">ISMEAR = 0</span><br><span class="line">LWAVE=.FALSE.</span><br><span class="line">LCHARG = .FALSE.</span><br><span class="line">NELM = 200</span><br><span class="line">DIPOL = 0.5 0.5 0.5</span><br><span class="line">LCALCPOL=.TRUE</span><br></pre></td></tr></table></figure>

<p>INCAR要注意：<br>铁电极化计算建议设置高精度；DIPOL &#x3D; 不要设置在原子及迁移路径上，设置在真空层的一边&#x2F;质心。</p>
<p>批量化计算，计算程序根据相应计算环境调整。</p>
<p><code>grep &#39;dipole moment&#39; */OUTCAR|rev| awk &#39;&#123;printf (&quot;%s &quot;, $4)&#125;&#39;|rev|awk &#39;&#123;printf (&quot;%f\n&quot;, $1+$2)&#125;&#39; &gt;&gt; dipole_c.dat </code></p>
<p><code>grep &#39;free  energy   TOTEN&#39; */OUTCAR | awk &#39;&#123;printf (&quot;%s\n&quot;,$5)&#125;&#39; &gt;&gt; energy.dat </code></p>
<p>注意，这里通过 grep 命令产生的 dipole_c.dat 文件记录的是沿着 c 方向的极化值，这是因为 BaTiO3 是沿着 c 方向极化的。对于具体的情况需要自行修改。离子与电子相加即可，然后用NP相-铁电相即可得到极化强度P。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在铁电极化计算过程中经常会出现参考相为非半导体的情况，这种情况下可以：①镜像法：以FE相以NP为参照中心，建立一个-FE相 (PhaseB’, 即铁电极化方向相反)。然后按照上述方法计算极化，再以FE相的极化-（-FE相）的极化值，然后除以2即得到极化强度。可以理解为1-(-1) &#x3D; 2，2&#x2F;2&#x3D;1；<br>②线性插值法：在FE和NP相中间插入一系列中间过渡相(0%（FE）,10%,20%,30%….100%(NP))，计算它们的极化，然后可以用Origin做拟合，100%时即为NP相的极化。(100%-0%)则是极化强度P。</p>
<h2 id="4-处理和分析数据。"><a href="#4-处理和分析数据。" class="headerlink" title="4 处理和分析数据。"></a>4 处理和分析数据。</h2><p>首先要理清数据单位。VASP 计算得到的 dipole moment 的单位是 e*Å，它与库仑之间换算为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1e =  1.602176634 * 10^-19 C  </span><br><span class="line">1Å = 10^-10 m</span><br></pre></td></tr></table></figure>

<p>三维体系的极化强度： 极化值除以体积。单位为 $e&#x2F;Å^2$；</p>
<p>二维体系的极化强度：极化值除以面积。单位为 $e&#x2F;Å$。</p>
<p>在这个例子中，BaTiO3 的体积为 64.3586 $Å^3$。</p>
<p>不同 image  的极化强度不是连续的，这是和选取的原胞有关，需要考虑极化量子的影响。BaTiO3 沿着 c 方向极化，所以需要对该极化值加减整数倍的 c 方向的晶格常数。</p>
<p>选取最靠近中间极化强度为 0 的那条曲线，即为 BaTiO3 的极化强度曲线：除以体积并进行简单的单位换算后为:另外，我们也可以绘制极化值 P 与能量 E 曲线</p>
<p>因此， BaTiO3 的极化强度大约为 0.248 $C&#x2F;m^2$，与文献中的实验结果 0.26 $C&#x2F;m^2$ 吻合。（Physical Review, 99(4), 1161–1165, 1955 ）</p>
<p>拟合 Landau-Ginzburg 公式<br>$$<br>E &#x3D; \sum_{i} \left( \frac{A}{2} P_i^2 + \frac{B}{4} P_i^4 + \frac{C}{6} P_i^6 \right) + \frac{D}{2} \sum_{i,j} (P_i - P_j)^2<br>$$</p>
<p>分别计算各个原子位移（原子移动方式可以类似于线性插值法）后结构的极化值，通过L-G公式拟合极化与能量得到前三项的系数A,B和C。由具有铁电性的原胞（FE结构）建立441超胞，计算超胞能量E1。然后将441超胞中其中一个原胞的FE结构换成-FE结构（-FE结构），代表一个dipole发生了翻转，计算出超胞能量E2，根据朗道有效哈密顿量在这两种情况下的表达式，并比较能量E1和E2，就可以得到D的数值。</p>
<p>拟合该多项式曲线，得到$E &#x3D; 6062.434883706029<em>P^6 +2437.756598493882</em>P^4 + -340.5806845162749*P^2 +10.339600058315137$ 其中参数 A, B,  C 分别为<br>$$<br>A &#x3D; -0.68116 eV *(m^2&#x2F;C)^2<br>B &#x3D;  9.75103  eV *(m^2&#x2F;C)^4<br>C &#x3D; 36.37461  eV *(m^2&#x2F;C)^6<br>$$</p>
<p> 绘制能量曲线的脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;energy.dat&#x27;,&#x27;r&#x27;) as f:</span><br><span class="line">    content = f.readlines()</span><br><span class="line">res = [float(i.strip(&#x27;\n&#x27;)) for i in content]</span><br><span class="line">minres = min(res)</span><br><span class="line">res = [1e3*(i-minres) for i in res]</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(res,&#x27;b.-&#x27;)</span><br><span class="line">plt.xlabel(&#x27;displacement&#x27;)</span><br><span class="line">plt.ylabel(&#x27;Energy ($meV$)&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>绘制dipole曲线，以及考虑极化量子的脚本:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;dipole_c.dat&#x27;,&#x27;r&#x27;) as f:</span><br><span class="line">   content = f.readlines()</span><br><span class="line">res = [float(i.strip(&#x27;\n&#x27;)) for i in content]</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">plt.figure()</span><br><span class="line">plt.xlabel(&#x27;displacement&#x27;)</span><br><span class="line">plt.ylabel(&#x27;Polarization ($e*&#123;\AA&#125;$)&#x27;)</span><br><span class="line">plt.xlim([0,32])</span><br><span class="line">plt.plot(res,&#x27;r.&#x27;)</span><br><span class="line"></span><br><span class="line">### 考虑极化量子</span><br><span class="line"></span><br><span class="line">c = 4.0335000000000001</span><br><span class="line">tmp = []</span><br><span class="line">N = 20</span><br><span class="line">for j in range(N):</span><br><span class="line">   start = -N/2+j</span><br><span class="line">   tmp1 = [i+start*c for i in res]</span><br><span class="line">   # print(tmp1[0])</span><br><span class="line">   tmp.append(tmp1)</span><br><span class="line">plt.figure()</span><br><span class="line">for i in tmp: </span><br><span class="line">   plt.plot(i,&#x27;.&#x27;)</span><br><span class="line"></span><br><span class="line">#plt.ylim([-2,2])</span><br><span class="line">plt.xlabel(&#x27;displacement&#x27;)</span><br><span class="line">plt.ylabel(&#x27;Polarization ($e*&#123;\AA&#125;$)&#x27;)</span><br><span class="line">plt.xlim([0,32])</span><br><span class="line"></span><br><span class="line">### 单位换算</span><br><span class="line"></span><br><span class="line">P = [-1.1965400000000006, -1.1288099999999996, -1.060039999999999, -0.990219999999999, -0.9193599999999993, -0.8474299999999992, -0.7744599999999995, -0.7004900000000003, -0.6255299999999995, -0.5496499999999997, -0.4728999999999992, -0.3953799999999994, -0.31716999999999906, -0.2384000000000004, -0.1591799999999992,-0.11827, 0.0, 0.11827, 0.1591799999999992, 0.2384000000000004, 0.31716999999999906, 0.3953799999999994, 0.4728999999999992, 0.5496499999999997, 0.6255299999999995, 0.7004900000000003, 0.7744599999999995, 0.8474299999999992, 0.9193599999999993, 0.990219999999999, 1.060039999999999, 1.1288099999999996, 1.1965400000000006]</span><br><span class="line">plt.figure()</span><br><span class="line">P = [i*0.248945227832799346 for i in P]</span><br><span class="line">plt.xlabel(&#x27;displacement&#x27;)</span><br><span class="line">plt.ylabel(&#x27;Polarization ($C/m^2$)&#x27;)</span><br><span class="line">plt.xlim([0,32])</span><br><span class="line">plt.plot(P,&#x27;r.&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>绘制极化值 P 与能量 E 曲线的脚本:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">E = [0.0035557599999975764, 0.0016252999999935014, 0.0004821100000000911, 0.0, 5.983999999870093e-05, 0.0005505999999968481, 0.0013690299999993272, 0.0024182999999950994, 0.003608839999998281, 0.004859239999994713, 0.006096989999996083, 0.007258279999994954, 0.008287759999994648, 0.009138139999997463, 0.00977216999999797, 0.010162939999993625, 0.010294929999993485, 0.010162939999993625, 0.00977216999999797, 0.009138139999997463, 0.008287759999994648, 0.007258279999994954, 0.006096989999996083, 0.004859239999994713, 0.003608839999998281, 0.0024182999999950994, 0.0013690299999993272, 0.0005505999999968481, 5.983999999870093e-05, 0.0, 0.0004821100000000911, 0.0016252999999935014, 0.0035557599999975764]</span><br><span class="line">P = [-1.1965400000000006, -1.1288099999999996, -1.060039999999999, -0.990219999999999, -0.9193599999999993, -0.8474299999999992, -0.7744599999999995, -0.7004900000000003, -0.6255299999999995, -0.5496499999999997, -0.4728999999999992, -0.3953799999999994, -0.31716999999999906, -0.2384000000000004, -0.1591799999999992,-0.11827, 0.0, 0.11827, 0.1591799999999992, 0.2384000000000004, 0.31716999999999906, 0.3953799999999994, 0.4728999999999992, 0.5496499999999997, 0.6255299999999995, 0.7004900000000003, 0.7744599999999995, 0.8474299999999992, 0.9193599999999993, 0.990219999999999, 1.060039999999999, 1.1288099999999996, 1.1965400000000006]</span><br><span class="line"></span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">E = [1e3*i for i in E]</span><br><span class="line">P = [i*0.248945227832799346 for i in P]</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(P,E,&#x27;b.-&#x27;)</span><br><span class="line">plt.xlabel(&#x27;Polarization ($C/m^2$)&#x27;)</span><br><span class="line">plt.ylabel(&#x27;Energy ($meV$)&#x27;)</span><br><span class="line">f1 = np.polyfit(P, E, 6)</span><br><span class="line">poly = &#x27;&#x27;for i in range(len(f1)): </span><br><span class="line">   poly += &#x27;&#123;&#125;*x^&#123;&#125;  +  &#x27;.format(f1[i],len(f1)-i-1)</span><br><span class="line">print(poly)</span><br><span class="line">x = [ -0.35+0.7*i/99 for i in range(100)]</span><br><span class="line">Eval = np.polyval(f1,x)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x,Eval,&#x27;b&#x27;)</span><br><span class="line">plt.plot(P,E,&#x27;r*&#x27;)</span><br><span class="line">plt.xlabel(&#x27;Polarization ($C/m^2$)&#x27;)</span><br><span class="line">plt.ylabel(&#x27;Energy ($meV$)&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>参考:</p>
<p><a target="_blank" rel="noopener" href="https://chengcheng-xiao.github.io/post/2019/12/25/Wannier_center_polarization.html">https://chengcheng-xiao.github.io/post/2019/12/25/Wannier_center_polarization.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv14756243/">https://www.bilibili.com/read/cv14756243/</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/358517335">https://zhuanlan.zhihu.com/p/358517335</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/537595648">https://zhuanlan.zhihu.com/p/537595648</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ghzhan/articles/16341122.html">https://www.cnblogs.com/ghzhan/articles/16341122.html</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/445884561">https://zhuanlan.zhihu.com/p/445884561</a></p>
<p>5). 居里温度计算的两种方法</p>
<ol>
<li>AIMD方法计算居里温度Tc（计算量巨大，准确）使用AIMD分别计算不同温度下的超胞，通过统计学得到平均极化距离d，通过d找到对应温度下的极化值，然后通过slogical1函数拟合得到$T_c$。</li>
<li>MC方法计算居里温度$T_c$（计算速度极快，建议）通过L-G公式进行拟合即可，代码及教程详细可看<a target="_blank" rel="noopener" href="https://github.com/Chengcheng-Xiao/mpiPyMC">https://github.com/Chengcheng-Xiao/mpiPyMC</a></li>
</ol>
<h1 id="滑移铁电"><a href="#滑移铁电" class="headerlink" title="滑移铁电"></a>滑移铁电</h1><p>华中科技大学的吴梦昊教授，在2017年首次提出层间滑移铁电，通过两层之间的滑移，实现电极化翻转。</p>
<p>下面以双层GdI2为例，计算这个材料的铁电极化强度。</p>
<p>Xun W, Wu C, Sun H, et al. Coexisting magnetism, ferroelectric, and ferrovalley multiferroic in stacking-dependent two-dimensional materials[J]. Nano letters, 2024, 24(11): 3541-3547.</p>
<h2 id="1-首先准备优化好的铁电相，即AB堆叠的POSCAR："><a href="#1-首先准备优化好的铁电相，即AB堆叠的POSCAR：" class="headerlink" title="1 首先准备优化好的铁电相，即AB堆叠的POSCAR："></a>1 首先准备优化好的铁电相，即AB堆叠的POSCAR：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CONTCAR                                    </span><br><span class="line">1.00000000000000          </span><br><span class="line">4.1426458804503365    0.0000000000000000    0.0000000508502232    </span><br><span class="line">-2.0713229953957617    3.5876365788074991   -0.0000000399383119     </span><br><span class="line">0.0000004448876875    0.0000000102694673   30.0000000000000000   </span><br><span class="line">I    Gd     </span><br><span class="line">4     2</span><br><span class="line">Direct  </span><br><span class="line">0.3333333244151952  0.6666666877589731  0.2311447203064440  </span><br><span class="line">0.3333333924379757  0.6666666704222977  0.0889274910801614  </span><br><span class="line">0.6666666411760427  0.3333333528368931  0.4864429969506502  </span><br><span class="line">0.6666666937613037  0.3333333375676722  0.3442418595816502  </span><br><span class="line">0.6666666947651289  0.3333333427541252  0.1601182205842356  </span><br><span class="line">0.0000000004443691  0.0000000116600432  0.4152546984968589</span><br></pre></td></tr></table></figure>
<p>在INCAR中加入参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DIPOL = 0.5 0.5 0.3</span><br><span class="line">LCALCPOL = .TRUE.   #计算铁电极化开关 </span><br></pre></td></tr></table></figure>


<h2 id="2-自洽计算"><a href="#2-自洽计算" class="headerlink" title="2 自洽计算"></a>2 自洽计算</h2><p>计算完成后，在OUTCAR中查找关键字dipole：由于我们关注的是c方向，因此只要看最后一列，用-397.00967 + 7.0125 &#x3D; -389.99717，即为铁电相的极化值。</p>
<h2 id="3-接下来计算顺电相，即AA堆叠，"><a href="#3-接下来计算顺电相，即AA堆叠，" class="headerlink" title="3 接下来计算顺电相，即AA堆叠，"></a>3 接下来计算顺电相，即AA堆叠，</h2><p>优化好的POSCAR如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CONTCAR                                    </span><br><span class="line">1.00000000000000          </span><br><span class="line">4.1426458804503365    0.0000000000000000    0.0000000508502232    </span><br><span class="line">-2.0713229953957617    3.5876365788074991   -0.0000000399383119     </span><br><span class="line">0.0000004448876875    0.0000000102694673   30.0000000000000000   </span><br><span class="line">I    Gd     </span><br><span class="line">4     2</span><br><span class="line">Direct  </span><br><span class="line">0.6756282937225784  0.3441349445403583  0.2202487956955387  </span><br><span class="line">0.6756257399639071  0.3441404853191938  0.0779182529604372  </span><br><span class="line">0.6708730704449056  0.3402390499976288  0.4974588775154418  </span><br><span class="line">0.6708673133601825  0.3402448262892301  0.3551273278370464  </span><br><span class="line">0.0089448210006132  0.0107926773902162  0.1491235435481827  </span><br><span class="line">0.0042207755078186  0.0069279784633755  0.4262532274433494</span><br></pre></td></tr></table></figure>
<p>同样在自洽的INCAR中加入参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DIPOL = 0.5 0.5 0.3</span><br><span class="line">LCALCPOL = .TRUE.  #计算铁电极化开关</span><br></pre></td></tr></table></figure>
<p>计算完成后查看顺电相的极化：</p>
<p>极化值为：-397.00991 + 7.00991 &#x3D; -390</p>
<h2 id="4-数据处理"><a href="#4-数据处理" class="headerlink" title="4 数据处理"></a>4 数据处理</h2><p>铁电相减去顺电相，得到的值为：-389.99717-(-390)&#x3D;0.00283，单位是电子&#x2F;埃。</p>
<p>极化强度是单位面积上的极化值，进行单位转换，最终结果3.0467x10-13 C&#x2F;m。</p>
<p>对比文献中的结果：数值还是非常接近的，差距可能在结构优化，或者参数设置的一些细节方面。至于为什么文献中是-12次方，我的是-13次方，我特地联系了通讯作者询问了一下，是他们笔误搞错了，正确结果就是-13次方。最后可能有人发现了，似乎没用到极化量子，由于计算的结果比较凑巧，刚好在同一个极化量子的范围内。一般情况下，可能算出来的极化值会相差很多个极化量子。</p>
<p>原链接：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/1j97g5A1Ny95EOn3cqKh-A">https://mp.weixin.qq.com/s/1j97g5A1Ny95EOn3cqKh-A</a></p>
<h1 id="功函数和静电势计算"><a href="#功函数和静电势计算" class="headerlink" title="功函数和静电势计算"></a>功函数和静电势计算</h1><p>VASP 中可使用 LVHAR 参数进行功函数计算控制，输出文件中 LOCPOT 就是我们想要的静电势贡献，格式和 CHGCAR 一样，需计算 Z 方向的平均贡献,利用vaspkit -task 422&#x2F;426.</p>
<p>VASP 中直接使用 LDIPOL 和 IDPOL 即可开启它的偶极校正功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LDIPOL = .TRUE. 表示打开偶极校正</span><br><span class="line">IDIPOL = 3 表示偶极校正方向为第三晶格矢</span><br><span class="line">DIPOL = 0.5 0.5 0.5 表示体系的中心，以分数坐标表示</span><br><span class="line">LVHAR = .TRUE.</span><br></pre></td></tr></table></figure>

<p>真空能级在打开 LVHAR 时可能去读取 OUTCAR 直接得到</p>
<p><code>grep vacuum OUTCAR</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vacuum level on the upper side and lower side of the slab         2.807         3.188</span><br></pre></td></tr></table></figure>
<p>注意 OUTCAR 中的真空能级需进行费米能级修正，即减去 OUTCAR 中的 E-fremi</p>
<h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><p>功函数：将一个固体内部的电子移动到真空所需的能量。（类似于逸出功）。</p>
<p>真空能级：固体表面外真空中自由电子所具有的能量。换句话说，电子跑出固体表面并达到这个能级后即可认为它自由。</p>
<ol>
<li><p>因 VASP 所适用的体系是周期性体系，使用它来模拟实验中的 Slab 模型时会取一个相当大的真空层来隔绝相邻两个周期中 Slab 的相互作用。理想情况下，真空层中的功函数应当是一条水平的直线（函数值为定值）。但如果表面的两侧并非对称，即其中一侧吸附了分子时， 这两侧的功函数存在差异，此时如果不进行偶极校正，真空中的功函数会是一条斜线；而经过偶极校正后，功函数会出现一个阶梯，阶梯两侧附近的曲接近水平。</p>
</li>
<li><p>在 VASP 中 LVHAR 参数可以使 VASP 输出体系的功函数文件 LOCPOT 。LOCPOT 文件本身是 Volumetric data ，它的格式与 CHGCAR 一样。一般而言，用户关心的功函数是垂直于表面方向上的数据，因此在得到 LOCPOT 后需要对 xy平面内的数据做平均，然后乘以晶胞的体积，就得到我们需要的功函数信息。</p>
</li>
<li><p>若体系难以收敛可手动计算原子坐标平均值并设置 DIPOL &#x3D; 0.5 0.5 <z averaged z>，若修正效果不到预期可以打开偶极校正并设置上述 DIPOL &#x3D; 0.5 0.5 <z averaged> 进行弛豫计算；<br>关闭 DIPOL，再次进行弛豫计算；<br>关闭 DIPOL，打开 LVHAR &#x3D; .TRUE. 进去静态计算得到功函数；<br>若出现功函数台阶即为计算成功。</p>
</li>
<li><p>如果计算失败请检查 POSCAR 中晶格基矢对应分量是否为 0。如计算第三个方向偶极修正请保证前两个基矢的 z 分量为零且第三个基矢只有 z 分量不为零。另外要注销并行参数。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/19/18-47-20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/19/18-47-20/" class="post-title-link" itemprop="url">9.1 转角结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-19 18:47:20" itemprop="dateCreated datePublished" datetime="2024-12-19T18:47:20+08:00">2024-12-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-07 11:18:15" itemprop="dateModified" datetime="2025-06-07T11:18:15+08:00">2025-06-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="转角结构简介"><a href="#转角结构简介" class="headerlink" title="转角结构简介"></a>转角结构简介</h1><h1 id="构建转角结构原理"><a href="#构建转角结构原理" class="headerlink" title="构建转角结构原理"></a>构建转角结构原理</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/j6dARDTRI_4c6yiSijTvHQ">https://mp.weixin.qq.com/s/j6dARDTRI_4c6yiSijTvHQ</a></p>
<p>转移矩阵这一步看不懂可先从三步看构建超胞我们是是用转移矩阵的方法来分别转角两层结构的。<br>这里先记住两个转移矩阵：第一层转移矩阵：<br>第二层转移矩阵：整数 越大超胞越大，单层原子数&#x3D; 单胞原子数 转移矩阵的行列式 ：$N &#x3D; n  det(T)$转角 满足：这里举个例子：对于石墨烯单胞原子数n&#x3D;2，如果我们i取2，则转移矩阵的行列式&#x3D;19，则单层原子数为</p>
<h1 id="构建转角结构的方法和程序"><a href="#构建转角结构的方法和程序" class="headerlink" title="构建转角结构的方法和程序"></a>构建转角结构的方法和程序</h1><h2 id="Twist2D"><a href="#Twist2D" class="headerlink" title="Twist2D"></a>Twist2D</h2><p>Python code for twisting the 2D materials.</p>
<p>链接：<a target="_blank" rel="noopener" href="https://github.com/kYangLi/Twist2D">https://github.com/kYangLi/Twist2D</a></p>
<p>使用：<code>python demo.py  #将twist2d.py放到同一文件夹</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;Twist2D Demo.&quot;&quot;&quot;</span><br><span class="line">#%%</span><br><span class="line"># +------------+</span><br><span class="line"># | Usage Demo |</span><br><span class="line"># +------------+</span><br><span class="line">from twist2d import *</span><br><span class="line"></span><br><span class="line"># Create an object for t2d</span><br><span class="line">twist_demo = Twist2D()</span><br><span class="line"></span><br><span class="line"># Initialize the different twisted layers</span><br><span class="line">#  - super_a1_mult,  super_a2_mult: supercell vector a1&#x27;,a2&#x27; based on a1,a2</span><br><span class="line">#  - layer_dis: the layer distance of this layer to next layer, default 2A.</span><br><span class="line">#  - scs_x, scs_y: supercell shift in x,y direction in angstroms, default 0A.</span><br><span class="line">#  - prim_poscar: POSCAR for primitive cell of current layer, default &#x27;POSCAR&#x27;. </span><br><span class="line">m = 6</span><br><span class="line">n = 7</span><br><span class="line">#--&gt; 1st layer </span><br><span class="line">#    The 1st layer is also the base layer, which all of other layers will </span><br><span class="line">#    try to add some strain to match the 1st layer&#x27;s cell constants.</span><br><span class="line">super_a1_mult = [m, n]</span><br><span class="line">super_a2_mult = [-n, m+n]</span><br><span class="line">twist_demo.add_layer(super_a1_mult, super_a2_mult, layer_dis=3, prim_poscar=&quot;POSCAR&quot;)</span><br><span class="line">#--&gt; 2nd layer</span><br><span class="line">super_a1_mult = [n, m]</span><br><span class="line">super_a2_mult = [-m, n+m]</span><br><span class="line">twist_demo.add_layer(super_a1_mult, super_a2_mult, prim_poscar=&quot;POSCAR&quot;)</span><br><span class="line"># #--&gt; 3rd layer</span><br><span class="line"># super_a1_mult = [n, m]</span><br><span class="line"># super_a2_mult = [-m, n+m]</span><br><span class="line"># twist_demo.add_layer(super_a1_mult, super_a2_mult, prim_poscar=&quot;POSCAR-BN&quot;)</span><br><span class="line"></span><br><span class="line"># Twisting the layers</span><br><span class="line">#  - start_z: The lowest atom&#x27;s fractional coordinates in z, default 0.1</span><br><span class="line">#  - super_a3_z: The length of the c vector in z direction, default 20A.</span><br><span class="line">twist_demo.twist_layers(start_z=0.1)</span><br><span class="line"></span><br><span class="line"># Write results to the file</span><br><span class="line">twist_demo.write_res_to_poscar()</span><br><span class="line"></span><br><span class="line"># (Optional) Calculate the twisted angles of each layer in degree </span><br><span class="line">twisted_angles = twist_demo.calc_layers_twist_angles()</span><br><span class="line">print(twisted_angles)</span><br><span class="line"></span><br><span class="line"># PROGRAM END</span><br><span class="line"></span><br><span class="line">#%%</span><br><span class="line"># +-------------------+</span><br><span class="line"># | Special condition |</span><br><span class="line"># +-------------------+</span><br><span class="line">from twist2d import *</span><br><span class="line"></span><br><span class="line"># If you are twisting a bilayer graphene-like system, </span><br><span class="line">#   you can write more simply like this:</span><br><span class="line"></span><br><span class="line"># Twist bilayer graphene-like structures</span><br><span class="line">tbg_demo = TwistBGL()</span><br><span class="line">tbg_demo.gen_TBGL(6, 7)</span><br><span class="line">#tbg_demo.gen_TBG(m=6, n=7, prim_poscar=&#x27;POSCAR&#x27;, poscar_out=&quot;POSCAR.T2D.vasp&quot;, start_z=0.1, super_a3_z=20.0, layer_dis=2.0, scs_x=0.0, scs_y=0.0)</span><br><span class="line"></span><br><span class="line"># (Optional) Calculate the twisted angles of each layer in degree </span><br><span class="line">twisted_angles = tbg_demo.calc_layers_twist_angles()</span><br><span class="line">print(twisted_angles)</span><br><span class="line"></span><br><span class="line">#PROGRAM END</span><br></pre></td></tr></table></figure>
<h2 id="Twister"><a href="#Twister" class="headerlink" title="Twister"></a>Twister</h2><p>印度科学研究所Manish Jain教授课题组开发了相应的Twister程序。</p>
<p>To construct a super lattice:</p>
<ol>
<li><p>Select the angle you wish to use from the table.</p>
</li>
<li><p>Use the corresponding twist angle (in radians), (m,n) and (p,q)   in the input file: twist.inp (see Graphene&#x2F; and MoS2&#x2F; examples)</p>
</li>
<li><p>Provide the basis atoms in crystal units in a file:   basis_pos_crys (additionally provide another basis file for layer 2. See MoS2&#x2F;Angle_63.48 for an example)</p>
</li>
<li><p>Run twister:python path_to_Twister_1.0&#x2F;src&#x2F;twister.py</p>
</li>
</ol>
<p>链接：<a target="_blank" rel="noopener" href="http://www.physics.iisc.ac.in/~mjain/software/twister">http://www.physics.iisc.ac.in/~mjain/software/twister</a></p>
<h3 id="转角异质结构建："><a href="#转角异质结构建：" class="headerlink" title="转角异质结构建："></a>转角异质结构建：</h3><p>新建文件夹heterbilayer从其中一个例子中考入3个输入文件：basis_pos_crys  basis_pos_crys_layer2  get_ang.inp </p>
<p>basis_pos_crys 和 basis_pos_crys_layer2是两层二维材料的晶体的原子坐标信息</p>
<p>get_ang.inp 为输入文件：自动搜索指定角度范围（theta_range）的扭转角，并输出精确扭转角、超晶格基矢和新的晶格参数</p>
<p>并行支持：-n 5 表示使用5个MPI进程加速计算。运行get_angle.py</p>
<p>输出文件：结果默认保存到文档</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">range_nm:  # 建立超胞的尺寸范围，尽量大点</span><br><span class="line">-10 11</span><br><span class="line">celldm_a:</span><br><span class="line">2.512 2.512 25.0  #第1原子层的晶格常数</span><br><span class="line">a1:</span><br><span class="line">0.5 0.8660254 0.0 #单胞1矢量a</span><br><span class="line">a2:</span><br><span class="line">-0.5 0.8660254 0.0 #单胞1矢量b</span><br><span class="line">a3:</span><br><span class="line">0.0 0.0 1.0 #单胞1矢量c</span><br><span class="line">Number_basis_atoms_a: #单胞1原子数</span><br><span class="line">2</span><br><span class="line">celldm_b:</span><br><span class="line">3.301 3.301 25.0 #第2原子层的晶格常数</span><br><span class="line">b1:</span><br><span class="line">0.5 0.8660254 0.0 #单胞2矢量a</span><br><span class="line">b2:</span><br><span class="line">-0.5 0.8660254 0.0 #单胞2矢量b</span><br><span class="line">b3:</span><br><span class="line">0.0 0.0 1.0       #单胞2矢量c</span><br><span class="line">Number_basis_atoms_b: #单胞2原子数</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">theta_range: </span><br><span class="line">19.05 19.15 0.01 #角度搜索参数（°）：上限 下限 步长；根据对称性：0-30°和30-60°结果相同initial mismatch threshold (Angstrom):不开启深度搜索的失配阈值。</span><br><span class="line">0.02512  #这个值很关键，太小了通常搜索不到,个人建议单胞晶格常数的1%</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">final mismatch threshold (Angstrom):#开启深度搜索后的最终失配阈值。</span><br><span class="line">0.00001</span><br><span class="line">strain_tensor_vector:  #如果设置为TRUE，则单位向量会受到应变；如果设置为FALSE，则晶格参数会受到应变</span><br><span class="line">&#x27;False&#x27;  # 只能是&#x27;False&#x27; 或者 True，大小写都不能错</span><br><span class="line">strain_per: #应变变化所允许的最大百分比范围</span><br><span class="line">1.0</span><br><span class="line">strain_layer: #&#x27;Top&#x27;,&#x27;Bottom&#x27;or&#x27;Both&#x27;</span><br><span class="line">&#x27;Top&#x27;  # Top就是拉伸第2层，Bottom，就是拉伸第一层,具体拉伸那一层看你研究的对象</span><br><span class="line">DeepSearch:</span><br><span class="line">&#x27;False&#x27;</span><br><span class="line">fix_ang:</span><br><span class="line">&#x27;True&#x27;</span><br><span class="line">f_ang:</span><br><span class="line">60</span><br><span class="line">plot:</span><br><span class="line">&#x27;N&#x27;</span><br></pre></td></tr></table></figure>


<p>编辑输入文件 twist.inp，包含以下关键参数：</p>
<p>从 get_angle.py 输出的 共格扭转角、超晶格矢量 和 晶格参数。</p>
<p>原子基矢位置文件：basis_pos_crys（底层）和 basis_pos_crys_layer2（顶层）。</p>
<p>运行命令生成原子坐标</p>
<p>关于twist.inp的设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">a1_l:</span><br><span class="line">1.000000000 0.000000000 0.000000000</span><br><span class="line">a2_l:</span><br><span class="line">0.500000000 0.866025400 0.000000000 </span><br><span class="line">a3_l:</span><br><span class="line">0.0 0.0 1.0</span><br><span class="line"></span><br><span class="line">celldm1_l, celldm2_l, celldm3_l: (Angstrom)</span><br><span class="line">3.164000000 3.164000000 25.000000000</span><br><span class="line"></span><br><span class="line">a1_u:</span><br><span class="line">1.000000000 0.000000000 0.000000000</span><br><span class="line">a2_u:</span><br><span class="line">0.500000000 0.866025400 0.000000000</span><br><span class="line">a3_u:</span><br><span class="line">0.0 0.0 1.0</span><br><span class="line"></span><br><span class="line">celldm1_u, celldm2_u, celldm3_u: (Angstrom)</span><br><span class="line">2.895032860 2.895032860 25.000000000</span><br><span class="line"></span><br><span class="line">angle: (radians)</span><br><span class="line">0.132454782</span><br><span class="line">layer2_from_file:</span><br><span class="line">True basis_pos_crys_layer2</span><br><span class="line">translate_z: (Angstrom)</span><br><span class="line">6.2</span><br><span class="line"></span><br><span class="line">Superlattice1: (m,n)</span><br><span class="line">-6.000000000 0.000000000  #.out文件中的第5行</span><br><span class="line"></span><br><span class="line">Superlattice2: (p,q)</span><br><span class="line">-6.000000000 6.000000000  #.out文件中的第6行</span><br><span class="line"></span><br><span class="line">Plot_lattice:False</span><br></pre></td></tr></table></figure>

<p>晶格参数默认以Å为单位，角度为弧度。</p>
<h2 id="CellMatch"><a href="#CellMatch" class="headerlink" title="CellMatch"></a>CellMatch</h2><p>CellMatch代码的目的是给定所选材料的两个单胞来生成这种共同的超胞。CellMatch代码在给定的组合空间内进行搜索，并根据施加在其中一个成分上的应变对结果进行排序，而另一个成分则经历零应变。</p>
<p>链接：<a target="_blank" rel="noopener" href="https://data.mendeley.com/datasets/drx9wzhn75/1">https://data.mendeley.com/datasets/drx9wzhn75/1</a></p>
<h2 id="online工具1"><a href="#online工具1" class="headerlink" title="online工具1"></a>online工具1</h2><p><a target="_blank" rel="noopener" href="https://materialsweb.org/lattice_matching/app">https://materialsweb.org/lattice_matching/app</a></p>
<ol>
<li>Upload two POSCARs for your monolayer materials</li>
<li>Enter the maximum acceptable area of the resultant unit cell</li>
<li>Enter the maximum acceptable strain in the resultant unit cell</li>
<li>Hit submit</li>
</ol>
<p>You can download the result POSCAR files using the Download POSCAR button. Keep in mind that POSCAR 1 will be the top part of the heterostructure and POSCAR 2 will be the bottom part of the heterostructure. The structures will be the same regardless unless either of the monolayers is asymmetric.</p>
<h2 id="online工具2"><a href="#online工具2" class="headerlink" title="online工具2"></a>online工具2</h2><p><a target="_blank" rel="noopener" href="http://www.latticemixer.com/">http://www.latticemixer.com</a></p>
<p>视频教程：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=OKRRmAPyX7w&t=370s">https://www.youtube.com/watch?v=OKRRmAPyX7w&amp;t=370s</a></p>
<h2 id="vaspkit"><a href="#vaspkit" class="headerlink" title="vaspkit"></a>vaspkit</h2><p>vaspkit pro版本的825功能：Build Hexagonal Moire Superlattices</p>
<h1 id="小角度转角构建及哈密顿"><a href="#小角度转角构建及哈密顿" class="headerlink" title="小角度转角构建及哈密顿"></a>小角度转角构建及哈密顿</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/11/18-47-24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/11/18-47-24/" class="post-title-link" itemprop="url">8.1 QE基础教程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-11 18:47:24" itemprop="dateCreated datePublished" datetime="2024-10-11T18:47:24+08:00">2024-10-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-28 08:59:44" itemprop="dateModified" datetime="2024-10-28T08:59:44+08:00">2024-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="QE简介"><a href="#QE简介" class="headerlink" title="QE简介"></a>QE简介</h1><p>(1)EPW模块:计算载流子迁移率与超导转变温度。<br>(2)声子模块:计算电声耦合以及动力学矩阵。<br>(3)微动弹性带模块:计算化学反应过渡态与反应路径。<br>（4）开源软件，完全免费多种泛函可供选择，提供外部泛函库(libxc)赝势种类众多，根据需求生成</p>
<h1 id="输入文件"><a href="#输入文件" class="headerlink" title="输入文件"></a>输入文件</h1><p>pw.x处理的计算包括以下7种类型，在输入文件中用calculation设置：</p>
<p>‘scf’：自洽计算，self-consistent field，通过迭代的方式数值求解微分-积分方程（Kohn-Sham方程），迭代收敛以电荷的变化足够小为准，最终得到自洽电荷。</p>
<p>‘nscf’：非自洽计算，scf计算常在k空间的网格上进行，网格要足够密以完成k空间上的积分，在DOS等计算需要更密的k<br>点，这时在自洽电荷基础上，计算这些更多的k<br>点，nscf计算保持自洽电荷不变。</p>
<p>‘bands’：也是一种nscf计算，k<br>点按照三维k空间中的特殊路径选取。</p>
<p>‘relax’：一系列scf计算，通过Hellman-Feynman力计算离子坐标驰豫（通过优化算法找到受力为零的结构），relax计算时固定cell不变。</p>
<p>‘vc-relax’: 允许cell变化的relax，通过应力的计算改变cell。</p>
<p>‘md’：分子动力学，将电子对离子的作用看成离子感受到的势，根据势能和离子初始速度求解离子运动的经典力学方程。</p>
<p>‘vc-md’：允许cell改变的md。</p>
<p>pw.x的输入说明见INPUT_PW。注意默认的单位，其中原子单位制为（以下数值见源程序q-e-qe-6.3&#x2F;Modules&#x2F;constants.f90）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 bohr = 1 a.u. (atomic unit) = 0.52917720859 angstroms.</span><br><span class="line">1 Rydberg (Ry) = 13.60569193 eV</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/10/18-47-21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/10/18-47-21/" class="post-title-link" itemprop="url">7.3 DMFT</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-10 18:47:21" itemprop="dateCreated datePublished" datetime="2024-05-10T18:47:21+08:00">2024-05-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-30 11:56:38" itemprop="dateModified" datetime="2025-06-30T11:56:38+08:00">2025-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="DFT-DMFT-calculations-vasp6-5"><a href="#DFT-DMFT-calculations-vasp6-5" class="headerlink" title="DFT+DMFT calculations(vasp6.5)"></a>DFT+DMFT calculations(vasp6.5)</h1><p><a target="_blank" rel="noopener" href="https://www-.vasp.at/wiki/index.php/DFT%2BDMFT_calculations#">https://www-.vasp.at/wiki/index.php/DFT%2BDMFT_calculations#</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/10/18-47-20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/10/18-47-20/" class="post-title-link" itemprop="url">7.2 磁性计算2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-10 18:47:20" itemprop="dateCreated datePublished" datetime="2024-05-10T18:47:20+08:00">2024-05-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-13 20:44:43" itemprop="dateModified" datetime="2024-12-13T20:44:43+08:00">2024-12-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Sym4state-Manual"><a href="#Sym4state-Manual" class="headerlink" title="Sym4state Manual"></a>Sym4state Manual</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CurrentModule = Sym4state.ModCore</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>pre_and_post</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">using PrintFileTree</span><br><span class="line">local pair_mat, coeff_array</span><br></pre></td></tr></table></figure>

<p>bilinear Heisenberg model can be described by</p>
<p>$\mathcal{H} &#x3D; \sum_{i &lt; j} S_i \cdot \mathcal{J}<em>{i j} \cdot S_j + \sum</em>{i} S_i \cdot \mathcal{A} \cdot S_i - m \sum_{i} S_i \cdot \vec{B}$</p>
<p>where the symbol $\mathcal{J}_{ij}$ denotes the exchange interaction matrix between two spins, $S_i$ and $S_j$, the matrix $\mathcal{A}$ represents the single-ion anisotropy. 四态法计算磁耦合，需要计算4种不同的磁基态，allowing the extraction of individual components for the exchange matrix.</p>
<p>想计算每一个元素的交换矩阵，就需要计算36个能量，由于一些结构的等价性，手动分析对称性筛选很有挑战，而且有遗漏的风险。</p>
<h2 id="Pre-process"><a href="#Pre-process" class="headerlink" title="Pre-process"></a>Pre-process</h2><p>One can use our program to streamline the simpilifing and calculating process easily. For example, with a POSCAR file of monolayer CrI3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Cr2 I6                                  </span><br><span class="line">   1.00000000000000     </span><br><span class="line">     7.1131374882967124    0.0000000000000000    0.0000000000000000</span><br><span class="line">    -3.5565687441483571    6.1601577654763897    0.0000000000000000</span><br><span class="line">     0.0000000000000000    0.0000000000000000   18.0635365764484419</span><br><span class="line">   Cr   I </span><br><span class="line">     2     6</span><br><span class="line">Direct</span><br><span class="line">  0.6666666666666643  0.3333333333333357  0.5000000247180765</span><br><span class="line">  0.3333333333333357  0.6666666666666643  0.5000000501683317</span><br><span class="line">  0.6415738047516142  0.9999977877949036  0.4116659127023310</span><br><span class="line">  0.3584239830432894  0.3584261952483858  0.4116659127023310</span><br><span class="line">  0.0000022122051035  0.6415760169567106  0.4116659127023310</span><br><span class="line">  0.3584241488090230  0.9999980859273947  0.5883340783387269</span><br><span class="line">  0.6415739371183646  0.6415758511909699  0.5883340783387269</span><br><span class="line">  0.0000019140726053  0.3584260628816354  0.5883340783387269</span><br></pre></td></tr></table></figure>

<p>合适设置 INCAR, POTCAR and KPOINTS 用于磁性自洽计算, 可以用 <code>Sym4state.jl</code> 产生所有的输入文件用于计算最近邻交换作用和单离子各向异性，过程如下：</p>
<figure class="highlight plaintext"><figcaption><span>pre_and_post</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">using Sym4state</span><br><span class="line">cd(&quot;CrI3&quot;) do   # hide</span><br><span class="line">Sym4state.pre_process(</span><br><span class="line">    &quot;./POSCAR&quot;,</span><br><span class="line">    [24],   # Take Cr element as magnetic</span><br><span class="line">    5.0     # There exists an interaction between atoms within a distance of 5 Å.</span><br><span class="line">)</span><br><span class="line">end # hide</span><br></pre></td></tr></table></figure>
<p>它将会构建超胞，满足两个任意原子无相互作用。给定的单层 ${CrI3}$ with a cutoff radius of 5 Å, a $2 \times 2 \times 1$ supercell will provide sufficient size. The supercell diagram below labels all the ${Cr}$ atoms:</p>


<p>Within the 5 Å cutoff radius, the monolayer of <code>\ce&#123;CrI3&#125;</code> exhibits two distinct groups of interactions. The first group corresponds to interactions between nearest neighbors, whereas the second group pertains to interactions arising from single-ion anisotropy. It is important to note that all atom pairs within the same group are considered equivalent. This equivalence implies the existence of symmetric operations that can transform one interaction matrix into another, highlighting the underlying symmetry of the system.</p>
<p> <code>pre_process</code> function的输出结果中，1组包含6对等价，第2组有2对等价。尽管简化了计算，还是要计算几种磁结构。 在考虑最近邻情况下，至少计算9个磁基态，相反在处理单离子各向异性需要2个。<br>不同参数和能量的关系储存在 <code>cal.jld2</code>. 另外该功能会生成几个目录储存对应输入文件。</p>
<figure class="highlight plaintext"><figcaption><span>pre_and_post</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printfiletree(&quot;CrI3&quot;)   # hide</span><br></pre></td></tr></table></figure>
<p>所有的目录储存在 <code>cal_list</code>, 后续提交任务即可。 <a target="_blank" rel="noopener" href="https://slurm.schedmd.com/">Slurm</a>‘s job array by submitting a shell like:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#SBATCH -n 144</span></span><br><span class="line"><span class="comment">#SBATCH --array=1-11%2</span></span><br><span class="line"></span><br><span class="line">module load vasp-6.3.2-optcell</span><br><span class="line"></span><br><span class="line">target_dir=$(sed -n <span class="string">&quot;<span class="variable">$&#123;SLURM_ARRAY_TASK_ID&#125;</span>p&quot;</span> cal_dir_list)</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;target_dir&#125;</span></span><br><span class="line"></span><br><span class="line">srun vasp_ncl</span><br></pre></td></tr></table></figure>

<p>这个 shell 脚本创建  Slurm job array 计算所有 11 magnetic configurations, while efficiently managing computational resources by allowing a maximum of 2 jobs to run simultaneously.</p>
<h2 id="Post-process"><a href="#Post-process" class="headerlink" title="Post-process"></a>Post-process</h2><p>计算完成后 <code>post_process</code> function 提取不同磁结构的能量，最终创建交换矩阵。</p>
<figure class="highlight plaintext"><figcaption><span>pre_and_post</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd(&quot;CrI3&quot;) do   # hide</span><br><span class="line">global pair_mat, coeff_array    # hide</span><br><span class="line">mv(&quot;../oszicar.tar.gz&quot;, &quot;./oszicar.tar.gz&quot;) # hide</span><br><span class="line">run(`tar -xvzf oszicar.tar.gz`) # hide</span><br><span class="line">for (idx, dir_name) in enumerate(readlines(&quot;cal_dir_list&quot;)) # hide</span><br><span class="line">    cp(&quot;oszicar/OSZICAR_$(idx)&quot;, dir_name * &quot;OSZICAR&quot;)  # hide</span><br><span class="line">end # hide</span><br><span class="line">pair_mat, coeff_array = Sym4state.post_process(&quot;./cal.jld2&quot;)</span><br><span class="line">end # hide</span><br></pre></td></tr></table></figure>
<p>我们可以测试 the dimensions of <code>pair_mat</code> and <code>coeff_array</code>, 它分别存储了不同原子对的起始点和结束点的索引及其对应的相互作用矩阵。</p>
<figure class="highlight plaintext"><figcaption><span>pre_and_post</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size(pair_mat)</span><br><span class="line">size(coeff_array)</span><br></pre></td></tr></table></figure>

<p>因此我们看到共有8个相互作用在cutoff radius of 5 Å. 让我们检查<code>pair_mat</code>中的一个特定条目，它包含表示原子对的索引：</p>
<figure class="highlight plaintext"><figcaption><span>pre_and_post</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair_mat[:, 1]</span><br></pre></td></tr></table></figure>

<p>初始数字和最终数字分别对应于起点原子和终点原子的指数。第二个和第三个数字表示原始单元格沿x轴和y轴的偏移量。</p>
<h2 id="Monte-Carlo-Simulation"><a href="#Monte-Carlo-Simulation" class="headerlink" title="Monte Carlo Simulation"></a>Monte Carlo Simulation</h2><p>前面 <code>pair_mat</code> and <code>coeff_array</code>的结果，可以通过 Monte Carlo simulation 计算 phase transition temperature or magnetic texture :</p>
<figure class="highlight plaintext"><figcaption><span>pre_and_post</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">using Unitful, UnitfulAtomic</span><br><span class="line">mcconfig = Sym4state.MC.MCConfig&#123;Float32&#125;(</span><br><span class="line">    lattice_size=[128, 128],</span><br><span class="line">    magmom_vector=[3.5, 3.5],</span><br><span class="line">    pair_mat=pair_mat,</span><br><span class="line">    interact_coeff_array=coeff_array,</span><br><span class="line">    temperature=collect(150:-2:0),</span><br><span class="line">    magnetic_field=zeros(3),</span><br><span class="line">    equilibration_step_num=100_000,</span><br><span class="line">    measuring_step_num=100_000</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>In the aforementioned code snippet, we have configured a simulated annealing simulation, commencing at a temperature of 150 K and progressively reducing it to 0 K in steps of 2 K. The simulation operates on a $128 \times 128$ supercell of ${CrI3}$ using the previously computed interaction matrix. To assess the system, we perform a preliminary equilibration phase consisting of <code>100000</code> sweeps, followed by a measurement phase comprising <code>100000</code> sweeps for acquiring physical quantities. It is worth noting that the magnetic field is absent, rendering the <code>magmom_vector</code> inconsequential.</p>
<p>With the created <code>mcconfig</code>, one can initiate a Monte Carlo simulation as follows:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">    states_over_env,</span><br><span class="line">    norm_mean_mag_over_env,</span><br><span class="line">    susceptibility_over_env,</span><br><span class="line">    specific_heat_over_env</span><br><span class="line">) = Sym4state.MC.mcmc(</span><br><span class="line">    mcconfig,</span><br><span class="line">    backend=Sym4state.MC.CPU()</span><br><span class="line">    progress_enabled=<span class="literal">false</span>,</span><br><span class="line">    log_enabled=<span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>The parameter <code>backend</code> can be configured to employ <code>CUDABackend()</code> provided by <a target="_blank" rel="noopener" href="https://github.com/JuliaGPU/CUDA.jl"><code>CUDA.jl</code></a> or any other backends supported by <a target="_blank" rel="noopener" href="https://github.com/JuliaGPU/KernelAbstractions.jl"><code>KernelAbstractions.jl</code></a> to enhance performance utilizing the GPU.</p>
<p>The <code>MCConfig</code> can also be stored into a <code>.toml</code> file by:</p>
<figure class="highlight plaintext"><figcaption><span>pre_and_post</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd(&quot;CrI3&quot;) do   # hide</span><br><span class="line">Sym4state.MC.save_config(&quot;CrI3.toml&quot;, mcconfig)</span><br><span class="line">end # hide</span><br></pre></td></tr></table></figure>

<p>or it can also be restored by:</p>
<figure class="highlight plaintext"><figcaption><span>pre_and_post</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd(&quot;CrI3&quot;) do   # hide</span><br><span class="line">mcconfig = Sym4state.MC.load_config(&quot;CrI3.toml&quot;)</span><br><span class="line">end # hide</span><br></pre></td></tr></table></figure>

<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reduce_interact_mat_for_a_pair</span><br><span class="line">supercell_check</span><br><span class="line">pre_process</span><br><span class="line">post_process</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm(&quot;CrI3&quot;, recursive=true)</span><br><span class="line">nothing</span><br></pre></td></tr></table></figure>



<h1 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h1><h2 id="当前模块"><a href="#当前模块" class="headerlink" title="当前模块"></a>当前模块</h2><p><code>Sym4state.ModCore</code> 使用 <code>PrintFileTree</code> 本地 <code>pair_mat</code>、<code>coeff_array</code></p>
<p>对于磁体的磁性特性的理论探索，双线性海森堡模型被证明是表示磁相互作用的有用框架，可以用以下公式描述：<br>$$<br>\mathcal{H} &#x3D; -\sum_{i,j} \mathcal{J}_{ij} \mathbf{S}_i \cdot \mathbf{S}<em>j + \sum</em>{i} \mathcal{A} \mathbf{S}_i^2<br>$$<br>其中符号 <code>\mathcal&#123;J&#125;_&#123;ij&#125;</code> 表示两个自旋 <code>S_i</code> 和 <code>S_j</code> 之间的交换相互作用矩阵，矩阵 <code>\mathcal&#123;A&#125;</code> 表示单离子各向异性。为了确定磁相互作用矩阵元素，研究人员通常采用四态方法 <a href="#user-content-fn-1-8f7d6183a295783803aaf3f6284a47b5">1</a> <a href="#user-content-fn-2-8f7d6183a295783803aaf3f6284a47b5">2</a> <a href="#user-content-fn-3-8f7d6183a295783803aaf3f6284a47b5">3</a>。该方法涉及计算四种不同的磁配置的能量，从而提取交换矩阵的各个分量。将此方法扩展到交换矩阵的每个元素需要计算总共 36 种能量，以获得完整的矩阵。需要注意的是，由于材料的对称性，一些能量是简并的。尽管如此，进行手动对称分析以简化能量计算的数量仍然是一项具有挑战性的工作，因为存在遗漏或误解某些对称操作的潜在风险。</p>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>可以使用我们的程序轻松简化和计算过程。例如，使用 <code>\ce&#123;CrI3&#125;</code> 的 POSCAR 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Cr2 I6</span><br><span class="line">1.00000000000000</span><br><span class="line">7.11313748829671    0.00000000000000    0.00000000000000</span><br><span class="line">-3.55656874414836    6.16015776547639    0.00000000000000</span><br><span class="line">0.00000000000000    0.00000000000000   18.06353657644844</span><br><span class="line">Cr   I2     6</span><br><span class="line">Direct</span><br><span class="line">0.66666666666666  0.33333333333333  0.50000002471808</span><br><span class="line">0.33333333333333  0.66666666666666  0.50000005016833</span><br><span class="line">0.64157380475161  0.99999778779490  0.41166591270233</span><br><span class="line">0.35842398304329  0.35842619524839  0.41166591270233</span><br><span class="line">0.00000221220510  0.64157601695671  0.41166591270233</span><br><span class="line">0.35842414880902  0.99999808592739  0.58833407833873</span><br><span class="line">0.64157393711836  0.64157585119097  0.58833407833873</span><br><span class="line">0.00000191407261  0.35842606288164  0.58833407833873</span><br></pre></td></tr></table></figure>

<p>以及适当设置的 INCAR、POTCAR 和 KPOINTS 文件以进行 SCF 计算，可以简单地使用 <code>Sym4state.jl</code> 生成所有输入文件以计算最近的交换相互作用和单离子各向异性相互作用，如下所示：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Sym4state</span><br><span class="line">cd(<span class="string">&quot;CrI3&quot;</span>) <span class="keyword">do</span></span><br><span class="line">    Sym4state.pre_process(<span class="string">&quot;./POSCAR&quot;</span>, [<span class="number">24</span>],   <span class="comment"># 以 Cr 元素作为磁性</span></span><br><span class="line">    <span class="number">5.0</span>     <span class="comment"># 存在一个距离为 5 Å 的原子间相互作用</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>此函数将利用 <a target="_blank" rel="noopener" href="https://github.com/A-LOST-WAPITI/Sym4state.jl/blob/main/docs/src/@ref"><code>supercell_check</code></a> 方法为提供的结构创建超晶胞。超晶胞应足够大，以确保在指定的截止半径内，任何两个原子之间不超过一个连接。对于给定的 <code>\ce&#123;CrI3&#125;</code> 单层，截止半径为 5 Å，<code>2 \times 2 \times 1</code> 的超晶胞将提供足够的大小。下图标记了所有的 <code>\ce&#123;Cr&#125;</code> 原子：</p>
<p><img src="https://github.com/A-LOST-WAPITI/Sym4state.jl/raw/main/docs/src/figs/CONTCAR.webp" alt="单层 \ce{CrI3} 的俯视图"></p>
<p>在 5 Å 的截止半径内，单层 <code>\ce&#123;CrI3&#125;</code> 显示出两组不同的相互作用。第一组对应于最近邻之间的相互作用，而第二组则涉及单离子各向异性引起的相互作用。需要注意的是，同一组内的所有原子对被视为等效。这种等效性意味着存在对称操作，可以将一个相互作用矩阵转换为另一个，突显了系统的潜在对称性。</p>
<p>根据 <code>pre_process</code> 函数获得的输出，初始组包含 6 对等效的原子对，而第二组则包含 2 对等效的原子对。尽管通过使用对称操作简化涉及各种相互作用矩阵的计算的潜力存在，但仍然有一个特定的相互作用矩阵需要计算最少数量的配置。在最近邻相互作用的情况下，必须计算至少 9 种磁配置的能量。相反，在处理单离子各向异性相互作用时，需要评估至少 2 种磁配置的能量。</p>
<p>该函数将恢复不同能量和配置之间的所有关系到文件 <code>cal.jld2</code> 中。此外，该函数将生成多个目录以存储与各种磁配置相对应的输入文件。</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printfiletree(<span class="string">&quot;CrI3&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>所有这些目录的路径存储在文件 <code>cal_list</code> 中，可以使用该文件通过提交如下的 shell 创建 Slurm 的作业数组：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#SBATCH -n 144</span></span><br><span class="line"><span class="comment">#SBATCH --array=1-11%2</span></span><br><span class="line">module load vasp-6.3.2-opt</span><br><span class="line">celltarget_dir=$(sed -n <span class="string">&quot;<span class="variable">$&#123;SLURM_ARRAY_TASK_ID&#125;</span>p&quot;</span> cal_dir_list)</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;target_dir&#125;</span></span><br><span class="line">srun vasp_ncl</span><br></pre></td></tr></table></figure>

<p>该 shell 脚本旨在创建一个 Slurm 作业数组，以计算所有 11 种磁配置的能量，同时通过允许最多 2 个作业同时运行来有效管理计算资源。</p>
<h2 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h2><p>一旦所有计算都已收敛，可以利用 <code>post_process</code> 函数提取与不同配置相关的能量。此过程最终导致构建相互作用矩阵。</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd(<span class="string">&quot;CrI3&quot;</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">global</span> pair_mat, coeff_array</span><br><span class="line">    mv(<span class="string">&quot;../oszicar.tar.gz&quot;</span>, <span class="string">&quot;./oszicar.tar.gz&quot;</span>) <span class="comment"># 隐藏</span></span><br><span class="line">    run(<span class="string">`tar -xvzf oszicar.tar.gz`</span>) <span class="comment"># 隐藏</span></span><br><span class="line">    <span class="keyword">for</span> (idx, dir_name) <span class="keyword">in</span> enumerate(readlines(<span class="string">&quot;cal_dir_list&quot;</span>)) <span class="comment"># 隐藏</span></span><br><span class="line">        cp(<span class="string">&quot;oszicar/OSZICAR_<span class="subst">$(idx)</span>&quot;</span>, dir_name * <span class="string">&quot;OSZICAR&quot;</span>)  <span class="comment"># 隐藏</span></span><br><span class="line">    <span class="keyword">end</span> <span class="comment"># 隐藏</span></span><br><span class="line">    pair_mat, coeff_array = Sym4state.post_process(<span class="string">&quot;./cal.jld2&quot;</span>)</span><br><span class="line"><span class="keyword">end</span> <span class="comment"># 隐藏</span></span><br></pre></td></tr></table></figure>

<p>我们可以检查 <code>pair_mat</code> 和 <code>coeff_array</code> 的维度，这些存储了各种原子对的起始和结束点的索引及其对应的相互作用矩阵。</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size(pair_mat)</span><br><span class="line">size(coeff_array)</span><br></pre></td></tr></table></figure>

<p>因此，我们观察到在 5 Å 的截止半径内存在总共 8 种相互作用。让我们检查 <code>pair_mat</code> 中的一个特定条目，该条目包含表示原子对的索引：</p>
<p>初始和最终数字对应于起始和结束点原子的索引，第二和第三个数字表示沿 x 轴和 y 轴的原始单元的偏移量。</p>
<h2 id="蒙特卡罗模拟"><a href="#蒙特卡罗模拟" class="headerlink" title="蒙特卡罗模拟"></a>蒙特卡罗模拟</h2><p>利用前面的结果 <code>pair_mat</code> 和 <code>coeff_array</code>，我们可以设置一个蒙特卡罗模拟的配置，以确定相变温度或磁纹理，如下所示：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Unitful, UnitfulAtomic</span><br><span class="line"></span><br><span class="line">mcconfig = Sym4state.MC.MCConfig&#123;<span class="built_in">Float32</span>&#125;(</span><br><span class="line">    lattice_size=[<span class="number">128</span>, <span class="number">128</span>],</span><br><span class="line">    magmom_vector=[<span class="number">3.5</span>, <span class="number">3.5</span>],</span><br><span class="line">    pair_mat=pair_mat,</span><br><span class="line">    interact_coeff_array=coeff_array,</span><br><span class="line">    temperature=collect(<span class="number">150</span>:-<span class="number">2</span>:<span class="number">0</span>),</span><br><span class="line">    magnetic_field=zeros(<span class="number">3</span>),</span><br><span class="line">    equilibration_step_num=<span class="number">100_000</span>,</span><br><span class="line">    measuring_step_num=<span class="number">100_000</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在上述代码片段中，我们配置了一个模拟退火模拟，从 150 K 开始，逐渐降低到 0 K，步长为 2 K。模拟在 <code>\ce&#123;CrI3&#125;</code> 的 <code>128 \times 128</code> 超晶胞上运行，使用先前计算的相互作用矩阵。为了评估系统，我们进行初步的平衡阶段，包含 <code>100000</code> 次扫掠，随后是包含 <code>100000</code> 次扫掠的测量阶段，以获取物理量。值得注意的是，磁场缺失，因此 <code>magmom_vector</code> 并不重要。</p>
<p>使用创建的 <code>mcconfig</code>，可以如下启动蒙特卡罗模拟：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(states_over_env, norm_mean_mag_over_env, susceptibility_over_env, specific_heat_over_env) = </span><br><span class="line">    Sym4state.MC.mcmc(mcconfig, backend=Sym4state.MC.CPU(), progress_enabled=<span class="literal">false</span>, log_enabled=<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>参数 <code>backend</code> 可以配置为使用 <a target="_blank" rel="noopener" href="https://github.com/JuliaGPU/CUDA.jl"><code>CUDABackend()</code></a> 提供的 GPU 加速，或任何其他由 <a target="_blank" rel="noopener" href="https://github.com/JuliaGPU/KernelAbstractions.jl"><code>KernelAbstractions.jl</code></a> 支持的后端，以提高性能。</p>
<p><code>MCConfig</code> 还可以存储到 <code>.toml</code> 文件中：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd(<span class="string">&quot;CrI3&quot;</span>) <span class="keyword">do</span></span><br><span class="line">    Sym4state.MC.save_config(<span class="string">&quot;CrI3.toml&quot;</span>, mcconfig)</span><br><span class="line"><span class="keyword">end</span> <span class="comment"># 隐藏</span></span><br></pre></td></tr></table></figure>

<p>或者也可以通过以下方式恢复：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd(<span class="string">&quot;CrI3&quot;</span>) <span class="keyword">do</span></span><br><span class="line">    mcconfig = Sym4state.MC.load_config(<span class="string">&quot;CrI3.toml&quot;</span>)</span><br><span class="line"><span class="keyword">end</span> <span class="comment"># 隐藏</span></span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><code>reduce_interact_mat_for_a_pair</code></li>
<li><code>supercell_check</code></li>
<li><code>pre_process</code></li>
<li><code>post_process</code></li>
<li><code>rm(&quot;CrI3&quot;, recursive=true)</code></li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>Xiang, H. J., et al. “Predicting the spin-lattice order of frustrated systems from first principles.” Physical Review B 84.22 (2011): 224429. <a href="#user-content-fnref-1-8f7d6183a295783803aaf3f6284a47b5">↩</a></li>
<li>Šabani, D., C. Bacaksiz, and M. V. Milošević. “Ab initio methodology for magnetic exchange parameters: Generic four-state energy mapping onto a Heisenberg spin Hamiltonian.” Physical Review B 102.1 (2020): 014457. <a href="#user-content-fnref-2-8f7d6183a295783803aaf3f6284a47b5">↩</a></li>
<li>Xiang, Hongjun, et al. “Magnetic properties and energy-mapping analysis.” Dalton Transactions 42.4 (2013): 823-853. <a href="#user-content-fnref-3-8f7d6183a295783803aaf3f6284a47b5">↩</a></li>
</ol>
<h2 id="SAXIS"><a href="#SAXIS" class="headerlink" title="SAXIS"></a>SAXIS</h2><p><strong>默认值</strong>: <code>SAXIS = (0, 0, 1)</code></p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>设置全局自旋量子化轴相对于笛卡尔坐标系的方向。</p>
<p>SAXIS 指定由泡利矩阵生成的自旋子空间的相对方向。默认情况下，<code>SAXIS</code> 为 <code>(0, 0, 1)</code>，即自旋量子化轴沿 z 轴方向。</p>
<h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>在包含自旋轨道耦合时（<code>LSORB</code> &#x3D; True），自旋量子化轴的相对方向与真实空间的关系变得重要。所有由 VASP 写入或读取的磁矩和类自旋量子数都以自旋子空间的基底表示。</p>
<h3 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h3><p><img src="https://www.vasp.at/wiki/images/thumb/5/56/Saxis-angles.png/300px-Saxis-angles.png" alt="坐标系统"></p>
<p>图 1. 欧拉角 $\alpha$ 和 $\beta$ 的定义。</p>
<p>默认方向为 $\sigma_1&#x3D;\hat x$，$\sigma_2&#x3D;\hat y$，$\sigma_3 &#x3D; \hat z</p>
<h1 id="Automag"><a href="#Automag" class="headerlink" title="Automag"></a>Automag</h1><p>An automatic workflow software for calculating the ground collinear magnetic state of a given structure and for estimating the critical temperature of the magnetically ordered to paramagnetic phase transition.<br>用于计算共线磁基态的自动工作流程软件，并用于估计磁相变温度。</p>
<h2 id="Installation安装"><a href="#Installation安装" class="headerlink" title="Installation安装"></a>Installation安装</h2><p>Automag is meant to be run on a computing cluster. The first step in the installation is to clone the repository<br>Automag 旨在运行在计算集群上。第一步 installation 是克隆存储库</p>
<p><code>git clone https://github.com/michelegalasso/automag.git</code></p>
<p>I assume that you have Python 3 installed on your system, accessible through the python command, with the wheel and the venv packages installed. After cloning, go to the automag directory which has appeared and initialize a Python virtual environment<br>我假设您的系统上安装了 Python 3，可通过 python 命令，安装了 wheel 和 venv 包。 克隆后，转到已出现的 automag 目录并初始化 Python 虚拟环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd automag</span><br><span class="line">python -m venv .venv</span><br></pre></td></tr></table></figure>
<p>After that, activate your virtual environment. If you are working on an Unix-like system, you can do it with the command<br>之后，激活您的虚拟环境。如果您正在使用类 Unix 系统，您可以使用命令</p>
<p><code>source .venv/bin/activate</code></p>
<p>Finally, you need to install all the necessary Python dependencies for Automag with the command<br>最后，您需要为 Automag 安装所有必要的 Python 依赖项 使用命令</p>
<p><code>pip install -r requirements.txt</code></p>
<p>Before using Automag, make sure that enumlib is installed on your system and that that your command line has access to the commands enum.x and makeStr.py. In addition, Automag needs to know how to use VASP, so you need to edit the file automag&#x2F;ase&#x2F;run_vasp.py for Automag to correctly load the MKL and MPI libraries (if needed) and call the vasp_std executable on your system. Then add the following lines to your ~&#x2F;.bashrc file<br>在使用 Automag 之前，请确保系统上已安装 enumlib 并且 您的命令行可以访问命令 enum.x 和 makeStr.py。 此外，Automag 需要知道如何使用 VASP，因此您需要编辑文件 automag&#x2F;ase&#x2F;run_vasp.py 用于 Automag 正确加载 MKL 和 MPI 库 （如果需要）并调用系统上的 vasp_std 可执行文件。然后添加以下几行添加到您的 ~&#x2F;.bashrc 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export PYTHONPATH=/PATH/TO/automag:$PYTHONPATH</span><br><span class="line">export VASP_SCRIPT=/PATH/TO/automag/ase/run_vasp.py</span><br><span class="line">export VASP_PP_PATH=/PATH/TO/pp</span><br><span class="line">export AUTOMAG_PATH=/PATH/TO/automag</span><br></pre></td></tr></table></figure>
<p>obviously replacing &#x2F;PATH&#x2F;TO with the actual path to these files or directories. The pp folder is the VASP pseudopotential library and it should contain two subfolders named, respectively, potpaw_LDA and potpaw_PBE.<br>显然将 &#x2F;PATH&#x2F;TO 替换为这些文件或目录的实际路径。 pp 文件夹是 VASP 赝势库，它应该包含两个子文件夹分别命名为 potpaw_LDA 和 potpaw_PBE。</p>
<p>Before starting to use Automag, you should also make sure to have the FireWorks library correctly pointing to a MongoDB database and configured for launching jobs through a queue management system (for more detailed information refer to the FireWorks documentation). Last but not least, open the file automag&#x2F;common&#x2F;SubmitFirework.py and edit line 23 with the location of your my_launchpad.yaml file. Now you are ready to use Automag.<br>在开始使用 Automag 之前，您还应该确保拥有 FireWorks 库正确指向 MongoDB 数据库并配置为启动作业（有关更多详细信息，请参阅 添加到 FireWorks 文档）。最后打开文件 automag&#x2F;common&#x2F;SubmitFirework.py 并编辑第 23 行编辑 my_launchpad.yaml 文件。现在，您可以开始使用 Automag。</p>
<h2 id="Convergence-tests收敛测试"><a href="#Convergence-tests收敛测试" class="headerlink" title="Convergence tests收敛测试"></a>Convergence tests收敛测试</h2><p>When studying a magnetic structure, you may want to start from convergence tests. Automag allows you to check for convergence of the VASP parameter ENCUT, which is the energy cut-off of the plane wave basis set, and to simultaneously check for convergence of the two parameters SIGMA and kpts, which are the electronic smearing parameter and the k-mesh resolution parameter for Brillouin zone sampling, respectively.<br>在研究磁性结构时，您可能希望从收敛测试开始。 Automag 允许您检查 VASP 参数 ENCUT 的收敛性，该参数是平面波基组的能量截止，并同时检查 SIGMA 和 kpts 这两个参数的收敛，它们是电子的用于布里渊区采样的涂抹参数和 k-mesh 分辨率参数， 分别。</p>
<p>In order to run convergence tests, go to the folder 0_conv_tests and insert the following input parameters in the file input.py:<br>要运行收敛测试，请转到文件夹 0_conv_tests 并插入文件 input.py 中的以下输入参数：</p>
<ul>
<li><p>mode can be “encut” for convergence tests with respect to ENCUT or “kgrid” for convergence tests with respect to SIGMA and kpts;<br>mode可以是 “ENCUT” 用于关于 ENCUT 或 “kgrid” 的收敛测试 用于 SIGMA 和 kpts 的收敛测试;</p>
</li>
<li><p>poscar_file is the name of the file in POSCAR format which contains the input geometry and which has been put in the folder automag&#x2F;geometries;<br>poscar_file 是包含输入的 POSCAR 格式文件的名称 geometry 的 ，并且已放入文件夹 automag&#x2F;geometries;</p>
</li>
<li><p>params is a collection of VASP parameters to be used during single-point energy calculations.<br>params 是要在单点期间使用的 VASP 参数的集合 能量计算。<br>In addition, the following optional parameters can be specified:<br>此外，还可以指定以下可选参数：</p>
</li>
<li><p>magnetic_atoms contains the atomic types to be considered magnetic (defaults to transition metals);<br>magnetic_atoms 包含要被视为磁性的原子类型（默认值 过渡到过渡金属）;</p>
</li>
<li><p>configuration is the magnetic configuration to use for convergence tests (defaults to ferromagnetic high-spin);<br>configuration 是用于收敛测试的磁性配置 （默认为铁磁高自旋）;</p>
</li>
<li><p>encut_values contains the trial values for ENCUT (defaults to the interval [500, 1000] eV at steps of 10 eV);<br>encut_values 包含 ENCUT 的 trial 值（默认为区间 [500， 1000] eV，步长为 10 eV）;</p>
</li>
<li><p>sigma_values contains the trial values for SIGMA (defaults to the interval [0.05, 0.20] eV at steps of 0.05 eV);<br>sigma_values包含 SIGMA 的试验值（默认为区间 [0.05， 0.20] eV，步长为 0.05 eV）;</p>
</li>
<li><p>kpts_values contains the trial values for kpts (defaults to the interval [20, 100] A^-1 at steps of 10 A^-1).<br>kpts_values 包含 kpts 的试验值（默认为区间 [20, 100]A^-1 以 10 A^-1 为步长）。<br>Once you have inserted the input parameters in the file input.py, launch the script 1_submit.py using the python executable of your virtual environment and a number of workflows containing single-point VASP calculations will be saved in your remote database. These calculations need to be run in a separate directory called CalcFold. You can enter it and then submit the jobs with the following commands, being in the automag directory<br>在文件 input.py 中插入输入参数后，启动使用虚拟环境的 python 可执行文件1_submit.py，以及 许多包含单点 VASP 计算的工作流将保存在您的远程数据库。这些计算需要在单独的目录中运行 称为 CalcFold。您可以输入它，然后使用以下内容提交作业 命令， 位于 automag 目录中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd CalcFold</span><br><span class="line">nohup qlaunch -r rapidfire -m 10 --nlaunches=infinite &amp;</span><br></pre></td></tr></table></figure>
<p>This will enter the directory CalcFold and it will invoke the qlaunch command in the background, which constantly checks for new calculations in the remote database and submits them to the queue management system of your cluster. The command line option -m 10 means that qlaunch will allow a maximum number of 10 jobs to be in the queue of your system at the same time. If 10 or more jobs are waiting or running in your queue, qlaunch will not submit more jobs until their total number becomes less than 10. If you wish, you can change this parameter to a different number. In the following, I assume that the qlaunch process is always working in the background.<br>这将进入 CalcFold 目录，并将调用 qlaunch 命令，该命令会不断检查 remote 数据库，并将其提交到集群的队列管理系统。 命令行选项 -m 10 表示 qlaunch 将允许最大数量 的 10 个作业同时位于您的系统队列中。如果 10 或更多作业正在等待或正在您的队列中运行，qlaunch 不会提交更多作业 直到它们的总数小于 10。如果您愿意，您可以更改此 参数设置为不同的数字。在下文中，我假设 qlaunch 进程始终在后台运行。</p>
</li>
</ul>
<p>After all calculations have been completed, you can launch the script named 2_plot_results.py in the 0_conv_tests folder. It will read the output file that Automag wrote in CalcFold and it will produce a plot of the parameters under study versus energy. In addition, the script will also print on screen the values of the parameters under study for which the error in energy is less than 1 meV&#x2F;atom with respect to the most accurate result.<br>完成所有计算后，您可以启动名为 2_plot_results.py 0_conv_tests 文件夹中。它将读取输出文件 Automag 在 CalcFold 中写入的，它将生成参数图 正在研究与能源。此外，脚本还将在屏幕上打印能量误差小于 1 meV&#x2F;atom 相对于最准确的结果。</p>
<h2 id="Calculation-of-the-electronic-correlation-parameter-U-by-linear-response通过线性响应计算电子相关参数-U"><a href="#Calculation-of-the-electronic-correlation-parameter-U-by-linear-response通过线性响应计算电子相关参数-U" class="headerlink" title="Calculation of the electronic correlation parameter U by linear response通过线性响应计算电子相关参数 U"></a>Calculation of the electronic correlation parameter U by linear response通过线性响应计算电子相关参数 U</h2><p>The linear response formalism for the calculation of the Hubbard U is based on the application of a series of small perturbations to the first magnetic atom. During the whole process, the perturbed atom must be treated independently from the other atoms of the same species, and we achieve this using a simple trick: we change the chemical identity of the atom to which we want to apply perturbations to a dummy atomic species, but we place the POTCAR file of the original atomic species in the pp folder corresponding to the dummy atom. For example, if we are calculating the value of the Hubbard U for Fe in the system Fe12O18 and we choose Zn as dummy atom, we need to ensure that the same POTCAR file of Fe is used also for Zn in order to have, instead of Zn, a Fe atom that is treated independently from the others. This can be achieved with the following commands<br>用于计算 Hubbard U 的线性响应形式基于对第一个磁性原子施加一系列小扰动。 在整个过程中，必须独立于同一物种的其他原子，我们用一个简单的技巧来实现这一点：我们更改我们要施加扰动的原子的化学性质添加到虚拟原子种类中，但我们将原始原子的 POTCAR 文件物种。例如，如果我们是 计算系统 Fe12O18 中 Fe 的哈伯德 U 值，我们选择 Zn 作为虚拟原子，我们需要确保也使用相同的 Fe 的 POTCAR 文件 对于 Zn，以便有一个独立处理的 Fe 原子，而不是 Zn 从其他人那里。这可以通过以下命令来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd $VASP_PP_PATH/potpaw_PBE/Zn</span><br><span class="line">mv POTCAR _POTCAR</span><br><span class="line">cp ../Fe/POTCAR .</span><br></pre></td></tr></table></figure>
<p>In this way the Automag code, and in particular the ASE library, will treat the system as if it was ZnFe11O18, but when they will look for the POTCAR file in the Zn folder, they will find the POTCAR of Fe, so the system will remain Fe12O18. Before launching this calculation, go to the directory 1_lin_response and set the necessary parameters in the file input.py:<br>通过这种方式，Automag 代码，特别是 ASE 库，将处理系统，就好像它是 ZnFe11O18 一样，但是当他们将在 Zn 文件夹中，他们会找到 Fe 的 POTCAR，因此系统将保持 Fe12O18。 在启动此计算之前，请转到目录 1_lin_response 并设置 文件中的必要参数 input.py：</p>
<ul>
<li>poscar_file is the name of the file in POSCAR format which contains the input geometry and which has been put in the folder automag&#x2F;geometries;<br>poscar_file 是包含输入的 POSCAR 格式文件的名称 geometry 的 ，并且已放入文件夹 automag&#x2F;geometries;</li>
<li>dummy_atom is the name of the dummy atomic species to use for the atom which is subject to perturbations (do not forget to manually put the right POTCAR file in the pp folder for this atom);<br>dummy_atom 是用于原子的虚拟原子种类的名称，其中 会受到干扰（不要忘记手动放置正确的 POTCAR 文件 在此原子的 pp 文件夹中）;</li>
<li>dummy_position is the position of the dummy atom in your POSCAR file (from 0 to N - 1, where N is the number of atoms in the unit cell);<br>dummy_position 是虚拟原子在 POSCAR 文件中的位置（从 0 到 N - 1，其中 N 是晶胞中的原子数）;</li>
<li>perturbations contains the values of the perturbations to apply to the chosen atom in eV;<br>perturbations 包含要应用于所选 原子在 eV 中;<br>params is a collection of VASP parameters to be used during * single-point energy calculations.<br>params 是要在单点期间使用的 VASP 参数的集合能量计算。</li>
</ul>
<p>In addition, the following optional parameters can be specified:<br>此外，还可以指定以下可选参数：</p>
<ul>
<li>magnetic_atoms contains the atomic types to be considered magnetic (defaults to transition metals);<br>magnetic_atoms 包含要被视为磁性的原子类型（默认值 过渡到过渡金属）;</li>
<li>configuration is the magnetic configuration to use for U calculation (defaults to ferromagnetic high-spin).<br>configuration 是用于 U 计算的磁性配置（默认值 到铁磁高自旋）。</li>
</ul>
<p>Once the input parameters have been inserted in the file input.py, you can launch the script 1_submit.py in order to save the necessary VASP jobs to the remote database. You will see that the instance of qlaunch which is running in the background will immediately send these jobs to the queue management system of your cluster. When all calculations are completed, you will find in CalcFold the file charges.txt, containing the amount of electrons on the partially occupied shell of the chosen atom for each value of the applied perturbation, for both the selfconsistent and the non-selfconsistent runs. Now you can execute the script 2_plot_results.py, which will plot the selfconsistent and the non-selfconsistent responses, it will interpolate them as straight lines to the least squares and it will calculate their slopes. The value of U is obtained from U &#x3D; 1&#x2F;X - 1&#x2F;X0, where X and X0 are the selfconsistent and the non-selfconsistent slopes, respectively.<br>将输入参数插入文件 input.py 后，您可以 启动脚本1_submit.py，以便将必要的 VASP 作业保存到 远程数据库。您将看到在 后台会立即将这些作业发送到队列管理系统 的集群。完成所有计算后，您将在 CalcFold 中找到 该文件charges.txt，其中包含部分 所选原子的占用壳，用于施加扰动的每个值， 对于自洽和非自洽游程。现在您可以执行 脚本2_plot_results.py，它将绘制 selfconsistent 和 nonself-align 响应，它会将它们作为直线插入到 最小二乘法，它将计算它们的斜率。U 的值由 U &#x3D; 1&#x2F;X - 1&#x2F;X0，其中 X 和 X0 是自洽和非自洽 slopes 的 Slope 值。</p>
<h2 id="Search-for-the-most-stable-magnetic-state寻找最稳定的磁态"><a href="#Search-for-the-most-stable-magnetic-state寻找最稳定的磁态" class="headerlink" title="Search for the most stable magnetic state寻找最稳定的磁态"></a>Search for the most stable magnetic state寻找最稳定的磁态</h2><p>The search for the ground collinear magnetic state consists in generating a number of trial configurations and in computing their single-point energy, in order to determine which is the most thermodynamically stable. The trial configurations differ from each other only by the choice of the unit cell and by the initialization of the magnetic moments. Note that the value of the magnetic moment on each atom can change during the single-point energy calculation. Automag generates trial configurations by separately initializing each Wyckoff position occupied by magnetic atoms in a ferromagnetic (FM), antiferromagnetic (AFM) or non magnetic (NM) fashion, taking into account all possible combinations. A completely non-magnetic (NM) configuration is also generated. In this way, overall ferrimagnetic (FiM) states are allowed if the magnetic atoms occupy more than one Wyckoff position. For each magnetic atom, one or two absolute values for the magnetization can be given in input. In the first case, the given value is used for initializing all the spin-up and spin-down states in the configurations generated by Automag. Conversely, if two separate values are given for high-spin (HS) and low-spin (LS) states, then each Wyckoff position occupied by that magnetic atom is separately initialized in a HS or LS fashion, taking into account all possible combinations. In order to run such a calculation, go to the directory 2_coll and set the necessary input parameters in the file input.py:<br>对共线磁基态的搜索包括生成一个 试验配置的数量和计算它们的单点能量，在 order 来确定哪个是最热力学稳定的。审判 配置彼此之间唯一的区别在于晶胞的选择和 磁矩的初始化。请注意，磁性 在单点能量计算过程中，每个原子上的矩都会发生变化。 Automag 通过单独初始化每个 Wyckoff 来生成试验配置 铁磁 （FM） 中磁性原子占据的位置， 反铁磁 （AFM） 或非磁性 （NM） 方式，同时考虑所有可能的组合。 还会生成完全无磁性 （NM） 配置。这样， 如果磁性原子占据更多，则允许整体亚铁磁性 （FiM） 状态 比一个 Wyckoff 位置。对于每个磁性原子，一个或两个 磁化强度可以在 input 中给出。在第一种情况下，给定值为 用于初始化配置中的所有 spin-up 和 spin-down 状态 由 Automag 生成。相反，如果为 high-spin 给定两个单独的值 （HS） 和低自旋 （LS） 状态，则每个 Wyckoff 位置都由该 磁性原子以 HS 或 LS 方式单独初始化，同时考虑到 所有可能的组合。要运行此类计算，请转到目录 2_coll并设置必要的输入参数：</p>
<p>poscar_file is the name of the file in POSCAR format which contains the input geometry and which has been put in the folder automag&#x2F;geometries;<br>poscar_file 是包含输入的 POSCAR 格式文件的名称 geometry 的 ，并且已放入文件夹 automag&#x2F;geometries;<br>supercell_size is the maximum supercell size for generating distinct magnetic configurations, in multiples of the input structure;<br>supercell_size 是产生不同磁性元件的最大超级单元大小 配置，以输入结构的倍数;<br>spin_values a maximum of two values (HS and LS) of the magnetization in Bohr magnetons for each magnetic atom, used to initialize spin-up and spin-down states;<br>spin_values玻尔的磁化强度最多两个值（HS 和 LS） 每个磁性原子的磁子，用于初始化自旋上升和自旋下降状态;<br>params is a collection of VASP parameters to be used during single-point energy calculations.<br>params 是要在单点期间使用的 VASP 参数的集合 能量计算。<br>In addition, the following optional parameter can be specified:<br>此外，还可以指定以下可选参数：</p>
<p>lower_cutoff is the minimum value in Bohr magnetons to which a magnetic moment can fall in order for the corresponding configuration to be used for estimating the critical temperature of the material (defaults to zero).<br>lower_cutoff 是磁矩达到的玻尔磁子的最小值 可以进行 材料的临界温度（默认为零）。<br>Once the input parameters have been inserted in the file input.py, you can launch the script 1_submit.py in order to save the necessary VASP jobs to the remote database. The running instance of qlaunch will send these jobs to the queue management system of your cluster. Once all calculations have been completed, you can launch the script 2_plot_results.py which will produce a number of files containing the histogram plot of the obtained energies for all trial configurations that successfully completed the single-point energy calculation. The script also prints on screen the name of the configuration with lowest energy.<br>将输入参数插入文件 input.py 后，您可以 启动脚本1_submit.py，以便将必要的 VASP 作业保存到 远程数据库。正在运行的 qlaunch 实例会将这些作业发送到 集群的队列管理系统。一旦所有计算都已完成 complete，您可以启动脚本2_plot_results.py，这将生成一个 包含所有所得能量的直方图的文件数 成功完成单点能量的 Trial 配置 计算。该脚本还会在屏幕上打印配置的名称 以最低的能量。</p>
<p>Calculation of the critical temperature<br>临界温度的计算<br>Automag can calculate the critical temperature of the magnetically ordered to paramagnetic phase transition from a Monte Carlo simulation of the effective Hamiltonian which describes the magnetic interaction. Automag computes the coupling constants of the corresponding Heisenberg model and provides all the necessary input files to run the Monte Carlo simulation with the VAMPIRE software package. The simulation itself needs to be run by the user, while Automag can be used to plot and to fit the results. The accuracy of the Heisenberg model is evaluated by computing the Pearson Correlation Coefficient (PCC) between the DFT energies and the predicted energies of a control group of magnetic configurations. It is worth noting that this approach can be applied only if all magnetic atoms have the same absolute value of the magnetization. In order to estimate the critical temperature with Automag, go to the folder 3_monte_carlo and set the necessary parameters in the file input.py:<br>Automag 可以计算出磁力排序的临界温度 顺磁相变来自蒙特卡洛模拟的有效 描述磁相互作用的哈密顿量。Automag 计算 耦合常量，并提供所有 使用 VAMPIRE 软件运行 Monte Carlo 模拟所需的输入文件 包。仿真本身需要由用户运行，而 Automag 可以 用于绘制和拟合结果。海森堡模型的精度为 通过计算 DFT 能量和磁控制组的预测能量 配置。值得注意的是，只有在所有 磁性原子具有相同的磁化绝对值。为了 使用 Automag 估计临界温度，转到 3_monte_carlo 并在 file input.py 中设置必要的参数：</p>
<p>configuration is the name of the magnetic configuration to use for the Monte Carlo simulation (usually you want to put here the name of the configuration with lowest energy, obtained at the previous step);<br>configuration 是用于 Monte 的磁性配置的名称 Carlo 模拟（通常您希望在此处使用 最低能量，在上一步获得）;<br>cutoff_radius is the maximum distance between two magnetic atoms to be considered as interacting neighbors;<br>cutoff_radius 是两个磁性原子之间的最大距离 被视为互动邻居;<br>control_group_size is the relative size of the control group used to evaluate the accuracy of the Heisenberg model;<br>control_group_size 是用于评估的对照组的相对大小 海森堡模型的准确性;<br>append_coupling_constants is a boolean flag which tells Automag whether or not to append the computed values of the coupling constants to the file input.py, which are needed by the script 2_write_vampire_ucf.py.<br>append_coupling_constants 是一个布尔标志，它告诉 Automag 是否 要将耦合常量的计算值附加到文件 input.py， 脚本2_write_vampire_ucf.py需要。<br>In addition, the following optional parameter can be specified:<br>此外，还可以指定以下可选参数：</p>
<p>magnetic_atoms contains the atomic types to be considered magnetic (defaults to transition metals).<br>magnetic_atoms 包含要被视为磁性的原子类型（默认值 过渡到过渡金属）。<br>Once the input parameters have been inserted in the file input.py, you can launch the script 1_coupling_constants.py. It will compute the coupling constants for the given cutoff radius and it will print their values on screen. In addition, it will create a file model.png, which contains a plot of the Heisenberg model energies versus the DFT energies for all the configurations in the control group. The values of the distances between neighbors, the amounts of neighboring pairs of magnetic atoms in the unit cell at each distance and the value of the PCC are also printed on screen.<br>将输入参数插入文件 input.py 后，您可以 1_coupling_constants.py启动脚本。它将计算耦合 常量，它将在屏幕上打印它们的值。 此外，它还将创建一个文件model.png，其中包含 海森堡模型能量与 DFT 能量的关系 Control 组。相邻要素之间的距离值、 晶胞中每个距离处的相邻磁原子对和 PCC 的值也打印在屏幕上。</p>
<p>We suggest to run the script 1_coupling_constants.py a couple of times with the append_coupling_constants flag set to False and with different values of the cutoff_radius, in order to investigate how many neighbors you need to include for obtaining a well-converged Heisenberg model. Once you are satisfied with the model’s accuracy, run the script a last time with the append_coupling_constants flag set to True and Automag will append the values of the coupling constants and the distances between neighbors to the file input.py. Now you are ready to run the script 2_write_vampire_ucf.py, which will read the file input.py and will produce a VAMPIRE unit cell file vamp.ucf. Now you can run VAMPIRE on your cluster using the unit cell file written by Automag, an input file and a material file specific for your problem. Automag contains a sample input file and a sample material file in the folder 3_monte_carlo&#x2F;vampire_input, which can be simply edited and adapted to the problem under study. Once the VAMPIRE run is done, you can copy the output file in the folder 3_monte_carlo and run the last script 3_plot_results.py. It will produce a plot of the mean magnetization length (of the spin-up channel for antiferromagnetic materials) versus temperature obtained from the Monte Carlo simulation and it will fit the data using the analytical expression of the mean magnetization length, obtaining the values of the critical temperature and of the critical exponent. The fitted values of these two parameters are printed on screen.<br>1_coupling_constants.py我们建议使用 append_coupling_constants标志设置为 False，并且 cutoff_radius，为了调查您需要包含多少个邻居 获得收敛良好的 Heisenberg 模型。一旦您对 model 的 accuracy 时，请使用 append_coupling_constants flag 设置为 True 将附加耦合常量的值 以及 input.py 的邻居之间的距离。现在您已准备好 运行脚本 2_write_vampire_ucf.py，它将读取文件 input.py 将生成一个 VAMPIRE 晶胞文件 vamp.ucf。现在，您可以在 使用 Automag 编写的晶胞文件、输入文件和材质的簇 特定于您的问题的文件。Automag 包含一个样本输入文件和一个样本 material 文件，可以是 3_monte_carlo&#x2F;vampire_input 文件夹中，也可以是简单的 编辑并改编了正在研究的问题。VAMPIRE 运行完成后，您 可以复制 3_monte_carlo 文件夹中output文件并运行最后一个脚本 3_plot_results.py。它将生成平均磁化长度 （的 反铁磁材料的自旋向上通道）与温度的关系 来自 Monte Carlo 模拟，它将使用分析来拟合数据 平均磁化长度的表达式，得到临界 温度和临界指数。这两个的拟合值 参数打印在屏幕上。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/09/18-47-20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/09/18-47-20/" class="post-title-link" itemprop="url">7.1 磁性计算1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-09 18:47:20" itemprop="dateCreated datePublished" datetime="2024-05-09T18:47:20+08:00">2024-05-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-30 11:55:06" itemprop="dateModified" datetime="2025-06-30T11:55:06+08:00">2025-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="vasp磁性参数"><a href="#vasp磁性参数" class="headerlink" title="vasp磁性参数"></a>vasp磁性参数</h1><p>设置ISPIN和MAGMOM参数，详见vasp官网。关闭对称性：ISYM&#x3D;0.一般有的采用先做非磁结构优化，再打开自旋和磁性设置做磁基态计算。确定磁性体系可以直接做磁性计算。磁性计算一般属于过渡金属，要进行DFT+U计算。对于考虑LDAU的情况一般推荐增加参数 LMAXMIX。</p>
<p>INCAR中的参数设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LORBIT = 11</span><br><span class="line">LDAU = .TRUE. 打开LDAU</span><br><span class="line">LDAUTYPE =2 LDAU类型LDAUTYPE=2： 只考虑U-J的值；LDAUTYPE=1： 同时考虑U和J，J基本为常数1 eV</span><br><span class="line">LDAUL = 2 -1 库伦排斥的轨道</span><br><span class="line">LDAUU = 2.8 0 库伦排斥的大小</span><br><span class="line">LDAUJ = 0 0 stoner 交换参数大小</span><br><span class="line">LMAXMIX = 4 mix轨道</span><br></pre></td></tr></table></figure>
<p>如果进行非线性计算，LNONCOLLINEAR &#x3D; .TRUE. MAGMOM &#x3D; x y z . . . … 可以读前一步的CHGCAR，进行非线性自洽计算（不用结构优化），也可以直接进行非线性计算。为了避免以上报错，增<br>加mix参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LMAXMIX = 4</span><br><span class="line">AMIX = 0.2</span><br><span class="line">BMIX = 0.00001</span><br><span class="line">AMIX_MAG = 0.8</span><br><span class="line">BMIX_MAG = 0.00001</span><br></pre></td></tr></table></figure>
<p>提交任务要使用vasp_ncl版本的程序</p>
<p>自旋轨道耦合<br>默认 SAXIS &#x3D; 0 0 1<br>加入磁矩参数<br>MAGMOM &#x3D; x y z … … </p>
<p>一般接口wannier90还需要<br>ISYM&#x3D;-1<br>NPAR &#x3D;1 或者将这个开关删除<br>##</p>
<p>铁磁半导体相对好收敛，遇到不收敛问题，可尝试降低 AMIX，增加 BMIX<br>尝试更换不同的ISMEAR，比如加电场时，会遇到矩阵不厄密。<br>call to ZHEGV failed 问题可能是</p>
<ol>
<li>结构不合理</li>
<li>优化时优化到一个不合理的结构： 尝试改变弛豫算法IBRION ，减小步长POTIM &#x3D; 0.1或者更小</li>
<li>对角化算法不稳定 ： ALGO &#x3D; Normal&#x2F;Fast</li>
<li>尝试关掉对称性</li>
</ol>
<h1 id="磁基态"><a href="#磁基态" class="headerlink" title="磁基态"></a>磁基态</h1><p>得出体系的具体磁基态：比较三个计算无磁，铁磁，反铁磁的能量，能量更低的为体系的磁基态。构建不同磁基态有可能需要扩胞。</p>
<p>得出体系原子的具体磁矩：用vi编辑器打开OUTCAR或其他方式打开，从最后往前翻动，第一个magnetization (x)开头的表格就是原子的磁矩大小。需要打开LORBIT&#x3D;11</p>
<p>磁矩分布画图：使用chgsplit.sh（可以向组内师兄师姐寻找）。磁性测试输出CHGCAR后，运行命令.&#x2F;chgsplit.sh CHGCAR得到cf1和cf2文件，把cf2文件重命名为CHGCAR-mag，与CONTCAR一起拖入VESTA中画图即可。vaspkit 312功能。</p>
<h1 id="磁耦合"><a href="#磁耦合" class="headerlink" title="磁耦合"></a>磁耦合</h1><p>对于磁性体系的第一性原理计算结果，能量部分可以分<br>为两个部分E &#x3D; E_0 （非磁项） + E_s （磁性相关能量）<br>对比磁性耦合产生的能量，不能够用磁性态的能量跟非<br>磁的去对比<br>E_s 包含交换耦合以及单离子各向异性能（SOC）<br>一般来说，磁性相关的能量可以用下面的公式来表示</p>
<ol>
<li>磁性态的构造<br>为了求磁耦合强度，我们需要构造出不同磁构型哈密顿，通过求解这些哈密顿方程<br>组来得到磁耦合参数。例如对于一个体系，我们需要求解最近邻J1和次<br>近邻J2，那么体系能量中有三个未知量H0, J1, J2。这样我们需要构造三个线性独立的方程来求解。<br>磁耦合参数</li>
</ol>
<h3 id="四态法"><a href="#四态法" class="headerlink" title="四态法"></a>四态法</h3><p>接下来，我们以一个例子来看四态法<br>是如何用来求磁耦合的。</p>
<ol>
<li>构建超胞<br>这里我们以二维六角晶格为例，原胞<br>中有两个磁性原子，我们构建一个<br>8<em>8</em>1的超胞，目标是求下图中A、B<br>之间的磁耦合作用。<br>构建四个磁性态 ，分别<br>为<br>其中第一项是DFT中的非磁项，联立这四个方程组就<br>可以求解<br>注意这里的超胞大小，只要满足这个8*8的超胞里的A、<br>B与周期外的A、B格点之间没有作用或者作用可忽略就<br>可以。</li>
</ol>
<p>单离子各向异性，对于沿Z轴具有三重四重六重旋转对称性的体系，只需要计算一个Azz  − Axx 。</p>
<h1 id="居里温度"><a href="#居里温度" class="headerlink" title="居里温度"></a>居里温度</h1><p>对于铁磁有序材料，当温度达到某一临界值之后，在没有外磁场的情况下，材料会变成<br>顺磁态，这个温度点便是居里温度（Curie temperature: Tc）<br>铁磁是一种铁性材料，所谓铁磁是指在外场作用下，极化随着外场的翻转会有一个滞后，<br>自旋极化随着外场的变化曲线形成磁滞回线。对于反铁磁有序材料，当温度达到某一临界值之后，在没有外磁场的情况下，材料同样会变成<br>顺磁态，这个温度点便是奈尔温度（Neel temperature: TN）</p>
<p>对于反铁磁有序材料，一般可以使用测试磁化率来判断其相变温度，磁化率满足居里外斯定律</p>
<ol>
<li>平均场近似</li>
<li>自旋波方法详细推导见文件夹mean-field-theory</li>
<li>Monte Carlo方法</li>
</ol>
<p>居里温度的Monte Carlo 模拟</p>
<ol>
<li>撒点，给初始磁矩</li>
<li>计算哈密顿<br>3 尝试随机反转一个格点的磁矩，计算能量<br>4判断，如果能量变低，则翻转，如果能量变高，那么<br>如果 则翻转，否则不翻转<br>5 先进行充足的MC步骤至平衡，然后在进行充足的步骤采样，取平均磁矩。<br>每一个温度点做一次1-5步骤，即每一个温度点有一个平均磁矩，磁矩下降最快的点（斜率绝对值最大）即为<br>居里温度。<br>反铁磁需要计算奈尔温度，那么平均磁矩会一直是0，有两种办法，算其中一个格点的平均磁矩，或者看磁比<br>热</li>
</ol>
<h2 id="mcsolver计算XY模型的一个例子。"><a href="#mcsolver计算XY模型的一个例子。" class="headerlink" title="mcsolver计算XY模型的一个例子。"></a>mcsolver计算XY模型的一个例子。</h2><p>在学习的过程中，我发现参数设置非常重要，也比较难，但网上并没有给出一个详细的教程说明，结合网上已有说明和朋友讨论，以下给出我的一点见解，希望大家相互讨论学习，有错误欢迎批评指正。</p>
<p>1.lattice晶格常数</p>
<p>关于晶格常数的设置，这步比较简单。</p>
<p>晶格常数需要采用归一化后的晶格常数，a1、a2、a3分别归一化，例如a1&#x3D;（3，4，0）归一化后就是（0.6，0.8，0）。</p>
<p>sc（supercell）表示使用的超胞规模，一般情况下尽可能的大，例如16<em>16</em>1或32<em>32</em>1（在二维情况下）。</p>
<p>2.Orbital list</p>
<p>这一步是对原胞中不等价磁性原子的设置。</p>
<p>ID是对设置的原子的编号，在可视化界面中，这一项不用手动设置，程序会自动根据我们的设置进行从0开始的编号。</p>
<p>type表示原胞中磁性原子的种类，根据具体情况进行设置，如果只有一种磁性原子，都设置成0就可以。</p>
<p>init spin表示自旋磁矩的设置，比如你用VASP计算出来得到的磁矩是3，那么这一项需要设置为1.5（需要除以一个2，换算成玻尔磁子）。</p>
<p>pos对磁性原子的位置坐标进行设置，这里最好是采用分数坐标（如果是笛卡尔坐标建议转换成分数坐标进行计算）。（更正：应该是相对于a1、a2、a3的分数坐标，也就是相对于斜的平行四边形的而言的，以其两条邻边为晶格矢量，例如CrI3是0.333   0.666667    0，如果是直角坐标系下的分数坐标的话第一个值应该是负的才对）</p>
<p>Ani表示单离子在xyz方向上的各向异性系数或单离子磁晶各向异性能(在Ising模型中是无用的，在XY模型中只使用前两个）。对自己的结构做一个易磁化轴位置的判断。一般为Z方向就在DZ处添加。同时，注意各向异性的单位是开尔文。 （1meV&#x3D;11.604609K）</p>
<p>至此，我们已经完成了第二步Orbital list的设置。</p>
<p>3.Bond list</p>
<p>设置第二步里面的磁性原子之间的交换耦合系数，在你的计算中，一共考虑到了多少个相互作用就要添加多少个。比如，对于CrI3来说，考虑到了最近邻、次近邻和第三近邻相互作用，分别有3个、6个和3个，那么你一共就需要添加12条信息。</p>
<p>对于每一项来说，设置方法如下：</p>
<p>ID是相互作用的编号，如同第二步一样，系统会从0开始自动编号。</p>
<p>J是磁性原子之间的交换耦合系数，一个J有九个矩阵元素，分别包括Jxx、Jyy、Jzz、Jxy、Jxz、Jyz、Jyx、Jzx、Jzy。每个元素描述了自旋的两个分量之间的耦合。对于Ising模型，由于只考虑一维自选变数，即只存在自旋向上或自旋向下，因此只使用第一个元素Jxx。对于XY模型也一样，自旋的朝向由up和down解放到了XY平面的任意朝向，因此只使用Jxx、Jyy、Jxy、Jyz。而对于heisenberg模型来说，三个自旋方向都存在相互作用，因此Jxx、Jyy、Jzz、Jxy、Jxz、Jyz、Jyx、Jzx、Jzy九个矩阵元素都需要设置。（对于模型的设置在后面的Model处进行选择。）对于前Ising和XY模型来说，即便你设置了九个矩阵元素，有效输入的也只是对应的起作用的元素，因此选好模型很关键。</p>
<p>s，t和over lat.表示我们考虑哪两个磁性原子之间的相互作用，s和t要选择我们在第二步中设置的原胞中磁性原子的ID，over lat.的三个元素指代一个晶格矢量，这个晶格矢量表示：在晶格中，你考虑的原子（在该中心原胞平移该晶格矢量后的原胞的t原子），和中心s原子之间的相互作用。（这里比较难，为了便于理解，建议读者找个例子琢磨琢磨或者自己多动手尝试一下）</p>
<p>注意所有的能量单位都是开尔文（1meV&#x3D;11.604609K）</p>
<p>至此，我们已经完成了第三步Bond list的设置。</p>
<p>现在，我们可以在Structure viewer里面看到超胞里磁性原子的分布和相互作用示意图。大家可以根据右上角的图查看自己添加的是否正确。一定要多加尝试。</p>
<p>4.Other settings其他设置</p>
<p>关于一些其他参数的设置。</p>
<p>T start&amp;end表示起始和结束温度，也就是温度的取值范围，total points表示温度插值次数（用于温度扫描），也就是总取点数，一般来说点越多图形越精确。示例给出的0.9,1.2和8只是为了快速计算得到结果，真实输入的时候要视实际情况而定。</p>
<p>同理，H start&amp;end表示外加磁场的取值范围，total points表示采样次数（用于磁场扫描）。</p>
<p>nthermal是使系统进入平衡状态的总步骤，nsweep是测量所涉及的总步骤，tau表示每一步的MC更新。</p>
<p>xAxis表示右边Result viewer的x轴上的物理量，可以是T(表示M-T曲线)或H(表示迟滞回线)。</p>
<p>Model可以选择Ising模型、XY模型或Heisenberg模型。</p>
<p>Algorithm选择相应的算法（支持Wolff，Metropolis，Swedsen-Wang）。</p>
<p>Measure corr. si&amp;sj设置spin＿i和spin＿j以及它们之间的晶格矢量，用于相关拼接。（如果spin＿i&#x3D;spin＿j并且overLat&#x3D;0 0 0，那么你将得到spin＿i的磁化率）。</p>
<p>nFrame是输出自旋构型的数目，用于说明在平衡或非平衡状态下的自旋构型。</p>
<p>core设置并行计算的核心资源。</p>
<p>至此，所有参数都设置完毕。</p>
<p>5.最后</p>
<p>save可以选择保存当前参数到文件，以便下一次找到。</p>
<p>单击StartMC启动计算。</p>
<p>等待右面板中的关系图更新。之后，你可以在mcsolver的根目录下找到一个result.txt文件，其中有许多有用的信息，包括平均自旋(在步骤5中定义的spin＿i和j上)，spin＿i和j之间的相关性，内能，比热容量和Binder累积量U4等。如果你处理有多个核心的模拟，那么结果可能不会根据温度排序，但是，每一行的对应关系都是可以的。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46679797/article/details/134455309">https://blog.csdn.net/qq_46679797/article/details/134455309</a></p>
<h1 id="MAE"><a href="#MAE" class="headerlink" title="MAE"></a>MAE</h1><p>磁晶各向异性 magnetic anisotropic energy (MAE) 是指自旋方向在不同方向上的能量差。MAE跟体系对称性有关。<br>对于简单体二维系，易磁化轴可能在面内或者垂直于面，我们可以选择计算不同方向的某一磁性态能量对比来求MAE<br>比如CrI3， 我们可以计算沿着x方向的FM能量Ex，然后计算沿着z方向的FM能量Ez。<br>MAE &#x3D; (Ex -Ez)&#x2F;2<br>对于对称性较低的体系，需要每个面去计算MAE。在vasp中，三维体系研究MAE，可以在高对称轴上算能量差</p>
<p>三步：结构优化，共线计算磁性并输出CHGCAR,读取CHGCAR改为非线性计算不同方向的能量。</p>
<p>晶体磁各向异性能量由按不同方向旋转所有自旋决定。首先，必须在基态下进行精确（PREC&#x3D;精确，LREAL&#x3D;.False.）共线计算（使用vasp_std版本）。接下来，考虑自旋轨道耦合（LSORBIT&#x3D;.True.，使用vasp_ncl版本）对几种自旋取向进行非自洽计算（ICHARG&#x3D;11）。在大多数情况下，能量变化非常小（有时约为微电子伏）。与共线相比，必须将NBANDS加倍。</p>
<p>为了修改晶体中自旋的取向，我们考虑这里描述的第二种方法。对于MAGMOM标签，根据z方向编写总局部磁矩（必要时，x和y方向均为0）。自旋取向（𝑢，𝑣，𝑤）由笛卡尔坐标系中的SAXIS标签定义。通过使自旋朝不同方向取向计算晶体磁各向异性能量和以下方程式</p>
<p>𝐸MAE&#x3D;𝐸（𝑢，𝑣，𝑤）−𝐸0</p>
<p>其中 𝐸0 是最稳定自旋方向的能量。更多细节请查看SAXIS和LSORBIT页面。</p>
<p>练习：通过将自旋沿以下路径定向，确定NiO的非自洽方式下的晶体磁各向异性能量：(2,2,2) –&gt; (2,2,1) –&gt; (2,2,0) –&gt; … –&gt; (2,2,-6)。与自洽方法进行比较。</p>
<p>INCAR:</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NiO</span> <span class="variable constant_">MAE</span></span><br><span class="line">  <span class="variable constant_">SYSTEM</span>    = <span class="string">&quot;NiO&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="title class_">Electronic</span> minimization</span><br><span class="line">  <span class="variable constant_">PREC</span> = <span class="title class_">Accurate</span></span><br><span class="line">  <span class="variable constant_">ENCUT</span>         = <span class="number">450</span></span><br><span class="line">  <span class="variable constant_">EDIFF</span>         = <span class="number">1E-7</span></span><br><span class="line">  <span class="variable constant_">LORBIT</span>        = <span class="number">11</span></span><br><span class="line">  <span class="variable constant_">LREAL</span>         = .<span class="property">False</span>.</span><br><span class="line">  <span class="variable constant_">ISYM</span>          = -<span class="number">1</span></span><br><span class="line">  <span class="variable constant_">NELMIN</span>        = <span class="number">6</span></span><br><span class="line">  #  <span class="variable constant_">ICHARG</span> = <span class="number">11</span></span><br><span class="line">  #  <span class="variable constant_">LCHARG</span> = .<span class="property">FALSE</span>.</span><br><span class="line">  #  <span class="variable constant_">LWAVE</span> = .<span class="property">FALSE</span>.</span><br><span class="line">  #  <span class="variable constant_">NBANDS</span> = <span class="number">52</span></span><br><span class="line">  #  <span class="variable constant_">GGA_COMPAT</span> = .<span class="property">FALSE</span>.</span><br><span class="line">    </span><br><span class="line"><span class="variable constant_">DOS</span></span><br><span class="line">  <span class="variable constant_">ISMEAR</span>    = -<span class="number">5</span></span><br><span class="line">    </span><br><span class="line"><span class="title class_">Magnetism</span></span><br><span class="line">  <span class="variable constant_">ISPIN</span>     = <span class="number">2</span></span><br><span class="line">  <span class="variable constant_">MAGMOM</span> = <span class="number">2.0</span> -<span class="number">2.0</span> <span class="number">2</span>*<span class="number">0.0</span></span><br><span class="line">  # <span class="variable constant_">MAGMOM</span>    = <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">2</span> <span class="number">6</span>*<span class="number">0</span> # <span class="title class_">Including</span> <span class="title class_">Spin</span>-orbit</span><br><span class="line">  # <span class="variable constant_">LSORBIT</span>       = .<span class="property">True</span>.</span><br><span class="line">  # <span class="variable constant_">SAXIS</span> = <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> # <span class="title class_">Quantization</span> axis used to rotate all spins <span class="keyword">in</span> a direction defined <span class="keyword">in</span> the (O,x,y,z) <span class="title class_">Cartesian</span> frame</span><br><span class="line">    </span><br><span class="line"><span class="title class_">Orbital</span> mom.</span><br><span class="line">  <span class="variable constant_">LORBMOM</span> = T</span><br><span class="line">    </span><br><span class="line"><span class="title class_">Mixer</span></span><br><span class="line">  <span class="variable constant_">AMIX</span>      = <span class="number">0.2</span></span><br><span class="line">  <span class="variable constant_">BMIX</span>      = <span class="number">0.00001</span></span><br><span class="line">  <span class="variable constant_">AMIX_MAG</span>  = <span class="number">0.8</span></span><br><span class="line">  <span class="variable constant_">BMIX_MAG</span>  = <span class="number">0.00001</span></span><br><span class="line">    </span><br><span class="line"><span class="variable constant_">GGA</span>+U</span><br><span class="line">  <span class="variable constant_">LDAU</span>      = .<span class="property">TRUE</span>.</span><br><span class="line">  <span class="variable constant_">LDAUTYPE</span>  = <span class="number">2</span></span><br><span class="line">  <span class="variable constant_">LDAUL</span>     = <span class="number">2</span> -<span class="number">1</span></span><br><span class="line">  <span class="variable constant_">LDAUU</span>     = <span class="number">5.00</span> <span class="number">0.00</span></span><br><span class="line">  <span class="variable constant_">LDAUJ</span>     = <span class="number">0.00</span> <span class="number">0.00</span></span><br><span class="line">  <span class="variable constant_">LDAUPRINT</span> = <span class="number">1</span></span><br><span class="line">  <span class="variable constant_">LMAXMIX</span>   = <span class="number">4</span> </span><br></pre></td></tr></table></figure>
<h2 id="vaspkit"><a href="#vaspkit" class="headerlink" title="vaspkit"></a>vaspkit</h2><p>  先执行结构优化计算（略），之后使用以下INCAR参数并选择991 K点进行自旋极化静态计算，运行vasp_std得到CHGCAR文件。</p>
<p>  MAE的INCAR：</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#<span class="title class_">General</span></span><br><span class="line"><span class="variable constant_">PREC</span> = <span class="variable constant_">ACCURATE</span></span><br><span class="line"><span class="variable constant_">ISTART</span>= <span class="number">0</span></span><br><span class="line"><span class="variable constant_">ICHARG</span>= <span class="number">11</span></span><br><span class="line"><span class="variable constant_">ENCUT</span> = <span class="number">520</span></span><br><span class="line"><span class="variable constant_">EDIFF</span> = <span class="number">1E-8</span></span><br><span class="line"><span class="variable constant_">EDIFFG</span> = -<span class="number">0.001</span></span><br><span class="line"><span class="variable constant_">LREAL</span> = .<span class="property">F</span>.</span><br><span class="line"><span class="variable constant_">NPAR</span> = <span class="number">4</span></span><br><span class="line"><span class="variable constant_">NSW</span>= <span class="number">0</span></span><br><span class="line"><span class="variable constant_">IBRION</span> = -<span class="number">1</span></span><br><span class="line"><span class="variable constant_">ISIF</span> = <span class="number">2</span></span><br><span class="line"><span class="variable constant_">ISMEAR</span> = -<span class="number">5</span></span><br><span class="line"><span class="variable constant_">SIGMA</span> = <span class="number">0.05</span></span><br><span class="line"><span class="variable constant_">LCHARG</span> = .<span class="property">F</span>.</span><br><span class="line"><span class="variable constant_">LWAVE</span> = .<span class="property">F</span>.</span><br><span class="line"><span class="variable constant_">POTIM</span> = <span class="number">0.5</span></span><br><span class="line"><span class="variable constant_">NEDOS</span> = <span class="number">2001</span></span><br><span class="line"><span class="variable constant_">NBANDS</span> = <span class="number">144</span>        # 修改为上一步静态计算<span class="variable constant_">NBANDS</span>数值的<span class="number">2</span>倍</span><br><span class="line"></span><br><span class="line">#<span class="title class_">Magnetic</span> properties</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">MAGMOM</span> = <span class="number">18</span>*<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="variable constant_">NELMIN</span> = <span class="number">6</span></span><br><span class="line"><span class="variable constant_">LORBIT</span> = <span class="number">11</span></span><br><span class="line"><span class="variable constant_">ISYM</span> = <span class="number">0</span></span><br><span class="line"><span class="variable constant_">LSORBIT</span> = .<span class="property">True</span>.</span><br><span class="line"><span class="variable constant_">LMAXMIX</span> = <span class="number">4</span>  ! <span class="keyword">for</span> d-elements increase <span class="variable constant_">LMAXMIX</span> to <span class="number">4</span>, f-<span class="attr">elements</span>: <span class="variable constant_">LMAXMIX</span> = <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>和VPKIT.in</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1                              ! 1为预处理, 2为后处理</span><br><span class="line">0 360 12                       ! Phi, Spherical coordinate system</span><br><span class="line">0 180 12                       ! 0&lt;= theta &lt;=180, 90 degree means in x-y plane</span><br></pre></td></tr></table></figure>

<p>VPKIT.in说明：<br>第一行：在第二步计算前使用1，第二步计算完后设置为2；</p>
<p>第二行：三维球坐标系下矢量在xy面投影与x轴正方向的夹角方位角φ，由起始角度0°到终止角度360°(0°)，最后是分割角度的个数；</p>
<p>第三行：三维球坐标系下矢量与z轴的夹角θ，由起始角度0°到终止角度180°，最后是分割角度的个数(注意包含180°在内需要＋1，所以是7)；</p>
<p>其中和分别为方位角和极角，其值变化范围分别是从0°到180°和从0°到360°，这里方位角和极角各取12个离散点（共计144个计算作业）。如果计算资源允许，可以选取更小间隔。调用vaspkit-621命令产生如下所示的一系列计算作业。理论上要生成144个计算作业，考虑到一部分相等无需计算，实际上共生成了122个计算作业。预处理时VASPKIT会自动在每个计算作业文件夹里的INCAR后根据公式(1)追加SAXIS &#x3D; </p>
<p>接下来可使用以下脚本模板批量提交vasp_ncl作业。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># just for reference</span><br><span class="line">path=`pwd`</span><br><span class="line">for c in *.*</span><br><span class="line">do</span><br><span class="line">   cd $path/$c</span><br><span class="line">   echo `pwd`</span><br><span class="line">   qsub vasp_job_soc.sh   ! vasp_job_soc.sh为vasp_ncl作业脚本</span><br><span class="line">  cd $&#123;path&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>待vasp_ncl计算完成后，把INPUT.in文件中的第一行修改2，然后再次运行vaspkit-621得到MAE.dat文件。我们可利用vaspkit&#x2F;examples&#x2F;MAE文件夹中的MATLAB脚本mae_3D_plot_matlab.m进行可视化。</p>
<ul>
<li>如果想得到xy二维平面内的MAE，INPUT.in可设置为:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1                              ! 1为预处理, 2为后处理</span><br><span class="line">0 360 12                       ! Phi, Spherical coordinate system</span><br><span class="line">90 90 1                        ! xy平面内theta始终等于90°</span><br></pre></td></tr></table></figure></li>
<li>如果想得到xz二维平面内的MAE，INPUT.in可设置为:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1                              ! 1为预处理, 2为后处理</span><br><span class="line">0 0 1                      ! Phi, Spherical coordinate system</span><br><span class="line">0 180 12                       ! </span><br></pre></td></tr></table></figure>
tips:</li>
</ul>
<p>根据提示我们需要先执行一步sta，然后读取WAVECAR和CHGCAR进行Nocollinear的计算，当读取WAVECAR进行测试的时候，计算是一定会报错的，因为俩步计算电子的自由度是不同。这时候VASP一定会提示：ERROR: while reading WACECAR,plane wave coefficidents changed</p>
<p>那么继续根据官网的操作手册</p>
<ul>
<li><p>我们第一步只计算无磁性基态的CHGCAR,第二步去读取CHGCAR进行计算。<br>这里只比对了x方向和z方向的结果：发现计算的结果是一模一样的，无法区分。</p>
</li>
<li><p>接下来不读取之前的CHGCAR进行计算，还是依照之前的设置.这时候发现计算的结果是有区分的。方向不同。</p>
</li>
<li><p>还有一种计算方式是读取写入磁基态的CHGCAR，再进行自旋轨道耦合的计算。这样计算的结果是，无论选择量子化轴在哪个方向，计算的结果都是在Z轴方向，但是能量有所差距。但是根据以上俩种结果去推断Cr原子的磁晶各向异性能，发现这种计算的结果跟文献的600-800eV的结果更为接近。 所以姑且认为进行计算是合理的结果。</p>
</li>
</ul>
<h1 id="电子结构分析"><a href="#电子结构分析" class="headerlink" title="电子结构分析"></a>电子结构分析</h1><p>磁性一般来自于d、f轨道的半占据电子，下面以d轨道为例介绍电子结构的分析</p>
<ol>
<li>磁矩约等于非成对的电子数，但是电子的占据方式并不仅仅由洪特规则来决定。<br>以一个Mn2+为例，最外层5个电子，按照洪特规则Mn磁矩应该是5，但是在晶体场的作用下，它有可能呈现高自旋、<br>中自旋、低自旋态。</li>
</ol>
<p>如何查找结构晶体场：</p>
<ol>
<li>确定点群 运行vaspkit</li>
<li>查表<br><a target="_blank" rel="noopener" href="http://gernot-katzers-spice-/">http://gernot-katzers-spice-</a> pages.com&#x2F;character_tables&#x2F;index.html</li>
<li>判断能及大小</li>
</ol>
<h1 id="约束磁矩方向和大小"><a href="#约束磁矩方向和大小" class="headerlink" title="约束磁矩方向和大小"></a>约束磁矩方向和大小</h1><p><a target="_blank" rel="noopener" href="https://www.shangyexinzhi.com/article/5004393.html">https://www.shangyexinzhi.com/article/5004393.html</a><br><a target="_blank" rel="noopener" href="https://www.vasp.at/wiki/index.php/Constraining_local_magnetic_moments">https://www.vasp.at/wiki/index.php/Constraining_local_magnetic_moments</a></p>
<p>在系统中加入一个惩罚函数，将体系的局部磁矩驱动到期望的方向，当在输入中修改以下步骤时(注意惩罚函数对总能量的贡献):</p>
<p>磁矩约束的开关(I_CONSTRAINED_M&#x3D;1)。</p>
<p>设置积分半径来确定局部矩(RWIGS&#x3D;1.0)。</p>
<p>惩罚函数中的权重(LAMBDA&#x3D;10)。</p>
<p>磁矩约束的目标方向(M_CONSTR&#x3D; 0 0 1 0 1 1)。</p>
<p>当收敛性不好时，我们能做什么:</p>
<ol>
<li><p>从ISTART&#x3D;0 (或删除WAVECAR文件)和ICHARG&#x3D;1计算非自旋极化的电荷密度开始。</p>
</li>
<li><p>通过设置BMIX&#x3D;0.0001和BMIX_MAG&#x3D;0.0001来使用线性混合。</p>
</li>
<li><p>慢慢混合，即减少AMIX和AMIX_MAG。</p>
</li>
<li><p>减少MAXMIX，存储在Broyden混合器中的步骤数(默认MAXMIX&#x3D;45)。</p>
</li>
<li><p>从部分收敛的结果重新启动(大约20步后停止计算，然后从WAVECAR文件重新启动计算)。</p>
</li>
<li><p>使用约束来稳定磁配置。</p>
</li>
</ol>
<p>注意：</p>
<p>当I_CONSTRAINED_M&#x3D;1时，只固定磁矩方向不固定大小， M_CONSTR&#x3D; 0 0 1 0 1 1表示方向。</p>
<p>当 I_CONSTRAI NED_M&#x3D;2时，既固定磁矩方向也固定磁矩大小， M_CONSTR&#x3D; 0 0 3 0 0 3表示方向和大小。</p>
<h1 id="非共线或非共面磁"><a href="#非共线或非共面磁" class="headerlink" title="非共线或非共面磁"></a>非共线或非共面磁</h1><p><a target="_blank" rel="noopener" href="https://www-.vasp.at/wiki/index.php/Spin_spirals">https://www-.vasp.at/wiki/index.php/Spin_spirals</a></p>
<p><a target="_blank" rel="noopener" href="https://gpaw.readthedocs.io/algorithms.html">https://gpaw.readthedocs.io/algorithms.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/09/18-48-23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/09/18-48-23/" class="post-title-link" itemprop="url">6.1 USPEX</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-09 18:48:23" itemprop="dateCreated datePublished" datetime="2023-11-09T18:48:23+08:00">2023-11-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-17 14:56:40" itemprop="dateModified" datetime="2023-12-17T14:56:40+08:00">2023-12-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、USPEX-简介"><a href="#一、USPEX-简介" class="headerlink" title="一、USPEX 简介"></a>一、USPEX 简介</h1><p>USPEX: Universal Structure Predictor: Evolutionary Xtallography. USPEX 代码能够通过仅仅只知道材料的化学成分来预测具有任意 P-T 条件的晶体结构。在全世界有6000多名研究人员使用它，它的出现极大的促进了相关领域的发展。而它的发明者：Oganov教授，通过这个软件做出了一系列漂亮的结果。</p>
<p>而 CALYPSO 的主要是由吉林大学的马琰铭教授主导开发的。</p>
<h1 id="二、-下载安装"><a href="#二、-下载安装" class="headerlink" title="二、 下载安装"></a>二、 下载安装</h1><ol>
<li><p>浏览器进入：<a target="_blank" rel="noopener" href="https://uspex-team.org/en/uspex/downloads%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%98%AF">https://uspex-team.org/en/uspex/downloads，这个是</a> USPEX 下载地址和官方手册。点击红色标记的 register 进行注册和登录即可免费下载。<br>USPEX-9.4.4 是 USPEX 最经典的版本，体积最小，而最新的版本的体积急剧膨胀，相对老的版本，最新版本是Oganov教授团队采用 Python 将 USPEX-9.4.4 (MATLAB)改写了一遍，无大的新功能增加，发布时间较短，质量无法得到保证。更主要的是，USPEX-9.4.4 有中文文档！</p>
</li>
<li><p>确保机器上有 MATLAB 或者Octave，假如都没有，并且机器与外网隔离的情况下，可以参考这个安装 MATLAB( https: &#x2F;&#x2F;blog.csdn.net&#x2F;pihuanwan3227&#x2F;article&#x2F;details&#x2F;84849969 ), 参考这个安装Octave (<a target="_blank" rel="noopener" href="https://www.cnblogs.com/freeweb/p/7124589.html)%E3%80%82">https://www.cnblogs.com/freeweb/p/7124589.html)。</a></p>
</li>
<li><p>接下进行安装: .&#x2F;install.sh，。接下来会提示让填写安装地址(如果机器里面 Octave 已经安装好，会显示 Octave。当然 MATLAB 安装好，也会显示 MATLAB)</p>
</li>
<li><p>接下来还有重要的最后三步（这个就是设置环境变量，能够当前用户能够直接调用 USPEX）：</p>
</li>
</ol>
<ul>
<li>vi  ~&#x2F;.bashrc  </li>
<li>export PATH&#x3D;$PATH: &#x2F;home&#x2F;xiaoming&#x2F;EDU&#x2F;USPEX  </li>
<li>export USPEXPATH&#x3D;&#x2F;home&#x2F;xiaoming&#x2F;EDU&#x2F;USPEX&#x2F;src</li>
</ul>
<p>其中&#x2F;home&#x2F;xiaoming&#x2F;EDU&#x2F;USPEX为USPEX安装目录。</p>
<h1 id="三、进行计算"><a href="#三、进行计算" class="headerlink" title="三、进行计算"></a>三、进行计算</h1><p>在上一步中已经成功安装好 USPEX 了，这时候可以使用 USPEX 进行计算了，本教程使用的是最主流的软件组合：USPEX+VASP，本教程需要 VASP 已安装好，至于 VASP 懂不懂并不影响本教程的使用。</p>
<h2 id="3-1-准备输入文件"><a href="#3-1-准备输入文件" class="headerlink" title="3.1 准备输入文件"></a>3.1 准备输入文件</h2><p>首先建立一个名为&#x2F;La-H&#x2F;0GPa的文件夹，进入这个文件之后，在终端输入命令： USPEX –g,然后查看文件夹 0GPa，会发现多了四个文件夹：AntiSeeds、Seeds、Specific、Submission。</p>
<p>其中，AntiSeeds 和 Seeds 文件夹中里面的存放的的是结构文件，由于本教程使用的是VASP进行计算，故这两个文件夹放的是 POSCARS 的文件（至于为什么是POSCARS，等下解释）。而 Specific 文件夹里面放的是 VASP 进行计算时，需要的和赝势文件，而 Submission 文件夹里面放的是 USPEX 各种方式提交任务的脚本。这 4 个文件夹是 USPEX 程序自动生成的，因而需要进入每个文件夹里面进行修改或者准备所需要的输入文件。接下来我们一个个文件来进行详细说明（划重点）。</p>
<p>a. AntiSeeds 文件夹，这个文件顾名思义，就是禁止 USPEX 生成的结构的种子文件，与 Seeds 文件夹作用相反，并且这个功能不常使用，本教程 AntiSeeds 文件夹就不设置，不用管它，直接考虑 Seeds 文件夹。</p>
<p>b. Seeds文件夹，这个文件夹就是USPEX计算时，需要种子文件存放的地方。好了，既然需要种子文件，那么我们来准备种子文件吧。本教程要进行搜索的是 La-H 体系，那么开始准备La、H结构文件吧。首先到日本晶体结构数据NIMS网站(<a target="_blank" rel="noopener" href="https://crystdb.nims.go.jp/crystdb/search-materials">https://crystdb.nims.go.jp/crystdb/search-materials</a>: 免费注册且免费下载，并且里面结构文件多数有其引用的相关文献)上找结构。</p>
<pre><code>1）、 把这两种元素的cif结构文件全部下载下来；

2）、用VESTA 
(http://www.jp-minerals.org/vesta/en/download.html：下载后解压即可使用，功能很强大的软件) 打开，另存为VASP5 格式的POSCAR文件；

3）、打包上传到机器上刚刚建立的/La-H/0GPa /Seeds文件下；

4）、包把La和H的POSCAR文件合并为一个文件，并命名为POSCARS (1、可以使用cat 命令合并，如：cat POSCAR_La* POSCAR_H &gt;&gt; POSCARS，2、建议查看一下POSCARS文件格式，假如有类似乱码的东西，dos2unix POSCARS百度了解一下)。
</code></pre>
<p>c. Specific文件夹,这个文件夹主要存放的是USPEX控制的VASP进行计算的输入文件，由于本教程是La-H体系在0 GPa的变组分结构搜索，主要是用VASP计算USPEX生成结构的能量，因而这个文件内主要是POSCAR进行结构优化的文件：<br>INCAR_1-5: 这样设置的主要原因：考虑有你的初始结构通常远离局部最小点，在这种情况下，</p>
<p>INCAR_1，2首先应该在保持体积固定的情况下（ISIF&#x3D;4）弛豫原子和晶胞形状，然后在INCAR_3，4中做完全弛豫（ISIF&#x3D;3），在INCAR_5中完成非常精确的单点计算（ISIF&#x3D;2，NSW&#x3D;0）（至于更具体的细节问题，手册上有详细的描述，请查看手册第3章第3.4小节）。值得注意的是：K点设置由USPEX自动生成了，无需考虑。</p>
<p>d. Submission文件夹, 这个文件夹主要是USPEX来提交计算任务和检查计算任务的情况的一些脚本。一般情况下，提交计算任务都是通过登陆到服务器上进行提交，那么这时候需要修改submitJob_local.m和checkStatus_local.m这两个脚本。</p>
<p>e. INPUT.txt</p>
<p>USPEX 自动生成的4个文件夹已经处理好了，那么接下来就是控制USPEX计算的输入文件：INPUT.txt  (固定名字的文件)，在&#x2F;La-H&#x2F;0GPa文件通过文本编辑器(vi INPUT.txt)，把上面的内容输入进去，并并保存，下面来解释每行代表的意思，这是超级重重点。</p>
<p>上图都是USPEX计算输入控制文件：INPUT.txt主要内容，棕黄色的数字标志是行数，只是为了显示方便，不是需要输入的内容。</p>
<pre><code>1-3行、为注释说明行。
第4行、为选择计算类型行，主要是选择什么样的计算方法进行不同类型的计算，目前USPEX支持四种计算方法分别为：USPEX、VCNEB、META、PSO等。但目前采用变组分结构搜索的话，选用其王牌类型，USPEX就行，其他方法请参阅手册
第5行、需要计算的结构类型、是否为分子和是否为变组分计算，301：3代表了三维块状结构，0代表了不是分子，1代表了采用变组分。
第6行、1是代表了进行结构搜索最稳定结构时采用了生成焓作为筛选标准，当然还有其他标准：体积，硬度，结构有序度等等，详情参阅手册。
第7行、1代表了设置允许系统自动进行进化的变分操作，这个设置能加快运算。
第9-11行、是设置需要计算的体系，本教程是La-H体系，所以在第10行输入La H, 当然你也可以在第10行输入 La H 的原子序数：57 1 ，这样也是被允许的。
第13-16行、设置上面你设置的体系原子的个数之比，表示着：LaxHy，也就是说任意x个La和任意y个H的结构都是可以生成的。假如需要生成任意x个La和任意2y个H的结构怎么设置？
第17-24行、设置关于生成结构的数目，第20行populationSize设置除了第一代，其余以后每代生成的结构的数目，第21行initialPopSize设置第一代生成的结构的数目，第22行numGenerations，设置总共计算的最大代数。第23行stopCrit设置多少代的最好结构结构都一样就停止USPEX计算。第24行是设置是否重新优化幸存的结构，默认是0，意思就是不重新优化。（需要注意的是，这里的设置的大小，大致上决定你需要优化的结构的数目）
第25-29行、设置允许生成LaxHy结构中8&lt;=x+y&lt;=18，这样设置能够更好锁定搜索结构的范围，当然越小计算量越少了，这个主要看个人选择了，但是minAt和maxAt不要相差太大，太大容易出错或者最后结果漏掉一些结构，手册上有推荐选择范围，自己参阅考虑。
第30-37行、设置遗传变分操作的具体细节的，主要设置各个操作的所占比例，fracGene:基因遗传占的比例，fracRand：随机生成的占比例，fracAtomsMut:原子摄动占的比例，fracTrans：晶格转变占的比例，fracLatMut：点阵摄动占的比例。注意：所有比例之和必须为1。
第39行、这行是设置体系的压强大小，单位是GPa, 0是不施加外压。当然了前面提到的文章，压力有150 GPa 和 300 GPa，在相应的压力下进行搜索时，应该此处改为150 或 300。
第41-46行、是设置调用的外部程序执行具体计算用的，1代表了调用VASP，1 1 1 1 1  跟Specific 文件夹里面INCAR_1、INCAR_2、INCAR_3、INCAR_4、INCAR_5遥相呼应，表示一个结构需要优化5次得到精确的能量值。
第48行、设置USPEX一次总共提交多少个任务，
第49行、设置提交任务方式，1设置为local，毕竟USPEX一般都是安装在服务器上面的。
第51-56行、设置重新启动USPEX运算，这个设置应该好好琢磨一下，尤其是第54行pickUpYN，0是不进行计算，1是进行重新计算，第55行pickUpGen根据你的结果文件夹results*里面的generation*的数目进行设置，第56行pickUpFolder是根据哪个结果文件夹results*进行重新计算，这3行一定要配合使用，是相关联的。当然本教程是进行新计算，都设置为0，即可，这个弄明白了，重新计算时，可以节省大量时间。
</code></pre>
<p>好了，La-H 体系不同压强下变组分结构搜索的INPUT.txt的主要设置内容介绍完毕。</p>
<p>f. 最后一项设置，就是提交整个USPEX的脚本了，很简单的shell脚本，任何一个机器上提交USPEX任务，都可以用这个，只是切记一定要把这个脚本命名好。如果在自己机器上使用了MATLAB把 –o 去掉就行了，-o的意思是使用octave。</p>
<h2 id="3-2-提交USPEX任务"><a href="#3-2-提交USPEX任务" class="headerlink" title="3.2 提交USPEX任务"></a>3.2 提交USPEX任务</h2><p>如果前面一切输入文件准备好了之后，那么我们可以开始了神奇的USPEX变组分结构搜索之旅了。终端输入命令：n nohup .&#x2F;uspex_Lah0.sh &gt;&gt; log &amp;（其中uspex_Lah0.sh就是1.f中提到的提交USPEX任务的脚本）。</p>
<h1 id="四、官方算例1（EX01-3D-Si-vasp）"><a href="#四、官方算例1（EX01-3D-Si-vasp）" class="headerlink" title="四、官方算例1（EX01-3D_Si_vasp）"></a>四、官方算例1（EX01-3D_Si_vasp）</h1><p>案例1，0 GPa下的Si( 一个晶胞里面8个原子)<br>我们先把案例1拷贝到当前目录下：USPEX –c 1</p>
<h2 id="1、输入文件"><a href="#1、输入文件" class="headerlink" title="1、输入文件"></a>1、输入文件</h2><p>其中reference里面是案例1的计算结果，属于参考答案，等下我们来分析一下里面的文件。现在我们先考虑一下，USPEX计算需要哪些文件夹？这里是不是还少了一些文件夹？少哪些了？答案很简单嘛：USPEX –g ，然后我们看看INPUT.txt，了解一下这个案例是做什么的。</p>
<pre><code>第5行、calculationMethod （计算方法）：USPEX（遗传演化算法，也就是遗传、变异遗传算法那套原理的改进版）。
第6行、calculationType（计算类型）：300 （3：三维、0：非分子、0：非变组分）
第7行、optType（优化类型）：1（焓值）
第8行、AutoFrac ？？：我也不记得了。。。不要怕，前面不是讲过怎么查看参数嘛！USPEX -p AutoFrac
第11行、Si：计算的体系的原子类型
第15行、8：计算的体系的原子类型的个数为8
第20行、populationSize (每代多少结构)：20
第21行、numGenerations（要计算多少代）：25 (这个代数，是最多要计算的代数，假如达到收敛的条件，可以在提前结束)
第22行、stopCrit（收敛的条件）：8 （单位：代。意思就是假如连续有8代的最优结构的优化类型（本例中为焓值）是一样，那么证明计算收敛了，可以停止计算了）
第23行、bestFrac（上一代用于生成下一代结构的比例）：0.6 （这个值默认值是0.7，在0.6-0.8之间是合理的）
第27行、fracGene（本代由遗传生产结构的比例）：0.5
第28行、fracRand（本代由晶体对称性随机产生结构的比例）：0.2
第29行、fracAtomsMut（本代由较小的突变产生结构的比例）：0.2
第30行、fracLatMut（本代由点阵突变产生结构的比例）：0.1
特别需要注意的是：fracGene+ fracRand+ fracAtomsMut+ fracLatMut = 1
第35行、计算总能软件的代码：1 1 1 1 1（VASP、采用5步优化，那么Specific应该有哪些文件了？请到入门教程找找）
第39行、计算总能的K点密度设置：0.13 0.11 0.10 0.08 0.06（这个值越低、K点越密集）具体描述如下：USPEX -p KresolStart 。不懂哪个参数就USPEX -p
第43行、运行总能计算软件的指令：一般建议不在这个设置这个参数，直接在Submission文件夹里面提交计算任务的脚本里面改就可以了。
第46行、whichCluster(采用什么计算方式)：一般采用1，同第43行原理。
第47行、numParallelCalcs（并行计算数）：10 (意思就是一次提交10个总能计算任务)
第48行、ExternalPressure（计算外压）：0.00001 (GPa、老朋友啦，不解释了)
</code></pre>
<p>把这个INPUT.txt读完以后，案例1就是搜索包含8个Si原子的晶胞在大气压最稳定的结构。</p>
<p>返回INPUT.txt目录，USPEX计算4大准备目录：AntiSeeds、Seeds、Specific、Submission和提交任务脚本EX01-3D_Si_vasp.sh。</p>
<pre><code>a、AntiSeeds文件夹没特别需要，不用理它；
b、Seeds文件夹，需要从NIMS下载所有稳定的Si结构，最后做成一个POSCARS，具体操作，读者需要自己动动手了，参考入门教程；
c、Specific文件夹本案例中已经准备好了；
d、Submission文件夹，读者需要自己动动手了，参考入门教程。
f、EX01-3D_Si_vasp.sh：本案例已经准备好了，需要注意的一点就是USPEX –r –o &gt;&gt; log / USPEX –r &gt;&gt;log : (Octave/ MATLAB用哪个自己修改)。
</code></pre>
<h2 id="2、计算"><a href="#2、计算" class="headerlink" title="2、计算"></a>2、计算</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./EX01-3D_Si_vasp.sh &gt;&gt; log &amp; </span><br></pre></td></tr></table></figure>

<p>在计算的过程中会出现一个重要的文件夹results1，results1里面放的就是计算结果，随着计算的时间的增长，里面会有文件夹generation1、generation2、generation3…，还有一些其他文件。但是肯定包括reference(参考答案)里面的文件，文件夹reference包含了计算结果，但是笔者先提醒一下，本次计算的目的：搜索8个Si原子的晶胞在大气压下最稳定的结构。<br>那么带着目的和INPUT.txt，我们来看一下计算结果。</p>
<h2 id="3、输出文件"><a href="#3、输出文件" class="headerlink" title="3、输出文件"></a>3、输出文件</h2><p>我们先来看最需要的答案：BESTgatheredPOSCARS和BESTIndividuals，这两个文件是定组分变胞计算的最最重要的文件，并且相互对应。</p>
<ul>
<li><p>先看看BESTIndividuals：顾名思义，这个文件里面存着每一代最稳定的结构！</p>
<p>  第1行标题，Gen是generation的缩写，USPEX计算时种群的代数；ID是USPEX计算时给每个结构做的标记，这个数值一般就是整个USPEX计算时产生第几个结构；Origin表示这个结构由什么遗传算法操作产生的；Composition成分；Enthalpy焓值；Volume、Density、KPOINTS这三个看字面意思就能明白了，SYMM代表空间群对称性，这个数字代表1-230个空间群代表；Fitness、Q_entr、A_order 、S_order这些都是代表晶胞有序度相关的量，都是根据fingerprint这篇文章里面定义的(doi:10.1107&#x2F;S0108767310026395)！</p>
</li>
<li><p>好了，我们把标题了解完了，来查看结果：焓值越低，结构越稳定！显然可见第13代（第15行）的ID301结构最稳定，而这个结构是从第12代ID276结构继承来（Origin: keptBest）,那么可以从这个文件里面看到USPEX计算过程中，最稳定的结构一代代遗传演化过程！</p>
</li>
<li><p>既然我们已经得到最稳定的结构的ID是301，那么它的具体原子坐标了？这时候该BESTgatheredPOSCARS出马了！从文件名字意思可以猜出这是最好的结构的原子坐标的集合，当然POSCAR这个就可以看出是以VASP的POSCAR形式存储的。既然我们有ID&#x3D;301这个目标，看一下这个结构在文件里面哪一行？</p>
<p>  <code>grep 301 -n BESTgatheredPOSCARS</code></p>
<p> 在文件里面的193行，现在我们打开文件，定位到这一行。</p>
</li>
<li><p>整个文件是VASP5格式的POSCAR集合，打开文件定位到这一行的时候，ID&#x3D;301这个结构是位于文件的最后，而上一个结构是EA276，上上一个结构是EA254…而EA301是第13代最稳定的结构，EA276是第12代最稳定的结构，EA254是第11代最稳定的结构。。。可以看出BESTgatheredPOSCARS的结构原子坐标和BESTIndividuals每一代的最稳定的结构是一一对应的，那么BESTgatheredPOSCARS里面的结构原子坐标也是一代代最稳定的结构步步演化过程。</p>
</li>
<li><p>把BESTIndividuals和BESTgatheredPOSCARS理解透彻了，其余的文件根据文件名字也能知道里面存放的具体数据是什么。比如文件Individuals里面放的是所有结构的焓值、体积、密度和有序度等信息，gatheredPOSCARS里面放的是所有的结构的原子坐标，Parameters.txt就是INPUT.txt的副本。余下的文件里面值得注意的就是OUTPUT.txt，这个文件是USPEX计算过程的软件自身的log文件。</p>
<p> 里面包含了对于整个USPEX计算的解释，随着每一代计算的结束，OUTPUT.txt。这个文件里面也会有对于这一代计算的总结，整个计算结束以后，USPEX也会做出总结。总而言之，OUTPUT.txt就是log文件，假如不明白USPEX怎么计算的，或者USPEX计算过程出错了，在这里都能找到原因。</p>
</li>
</ul>
<h1 id="五、官方算例2（2-8）"><a href="#五、官方算例2（2-8）" class="headerlink" title="五、官方算例2（2-8）"></a>五、官方算例2（2-8）</h1><h2 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h2><ul>
<li><p>主要目标：在100 GPa，MgAl2O4（28个原子的单胞）使用GULP(General Utility Lattice Program，<a target="_blank" rel="noopener" href="http://gulp.curtin.edu.au/gulp/%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%8A%9B%E5%9C%BA%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%9C%89%E5%BE%88%E5%A4%9A%E6%9C%89%E6%84%8F%E6%80%9D%E7%83%AD%E5%8A%9B%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%8A%9F%E8%83%BD%EF%BC%8C%E6%9C%89%E6%9C%BA%E4%BC%9A%E5%86%8D%E4%BB%8B%E7%BB%8D">http://gulp.curtin.edu.au/gulp/，使用力场方法进行计算的软件包，里面有很多有意思热力学计算功能，有机会再介绍</a>) -采用Buckingham势-进行变胞计算。这个案例直接揭示了地球内部物理现象，但是由于力场方法精确性不如DFT方法，所以想要更精确的结果，可以改用VASP一类的软件，同时计算时间会增长不少！</p>
</li>
<li><p>看完案例的简单介绍，我们来读一下INPUT.txt，复习一下定成分变胞计算怎么设置参数。</p>
<p>第4行、 calculationMethod （计算方法）：USPEX（遗传演化算法，也就是遗传、变异遗传算法那套原理的改进版）。<br>第5行、calculationType（计算类型）：300 （3：三维、0：非分子、0：非变组分）<br>第6行、optType（优化类型）：1（焓值）<br>第7行、AutoFrac：1（允许系统自动变异演化，比用户自定义的快2倍）。一般建议设置为1即可。<br>第10行、Mg  Al  O：计算的体系的原子类型<br>第14行、4  8  16：计算的体系的Mg、Al、O的个数分别为4、8、16，也就是体系的原子总数为28的MgAl2O4。<br>第19行、populationSize (每代多少结构)：40<br>第20行、numGenerations（要计算多少代）：60 (这个代数，是最多要计算的代数，假如达到收敛的条件，可以在提前结束)<br>第21行、stopCrit（收敛的条件）：30（单位：代。意思就是假如连续有30代的最优结构的优化类型（本例中为焓值）是一样，那么证明计算收敛了，可以停止计算了）<br>第22行、bestFrac（上一代用于生成下一代结构的比例）：0.6 （这个值默认值是0.7，在0.6-0.8之间是合理的）<br>第26行、fracGene（本代由遗传生产结构的比例）：0.5<br>第27行、fracRand（本代由晶体对称性随机产生结构的比例）：0.2<br>第28行、fracPerm（本代由置换产生结构的比例）：0.1<br>第29行、fracAtomsMut（本代由较小的突变产生结构的比例）：0.2<br>特别需要注意的是：fracGene+ fracRand+ fracPerm+ fracAtomsMut &#x3D; 1<br>第35行、计算总能软件的代码：3 3 3 3 （GULP、采用4步优化，那么Specific应该有哪些文件了？等下介绍）</p>
<p>以上就是USPEX所有用于结构优化的软件包<br>第39行、运行总能计算软件的指令：一般建议不在这个设置这个参数，直接在Submission文件夹里面提交计算任务的脚本里面改就可以了。<br>第43行、numParallelCalcs（并行计算数）：1(意思就是一次提交1个总能计算任务，计算效率太低，建议设置16个左右)。<br>第44行、whichCluster(采用什么计算方式)：一般采用1，同第43行原理。<br>第45行、ExternalPressure（计算外压）：100 (GPa)</p>
<p>把INPUT.txt读完以后，案例2和案例1计算类型和参数设置几乎都是一样，但是需要注意的这次是采用GULP来计算的，那么问题来了！</p>
<p><strong>问题1. Seeds 和AntiSeeds里面的种子文件采用的是GULP格式的吗？</strong></p>
</li>
</ul>
<p>答：不是！还是VASP5 格式的POSCARS。另外提醒一下，种子文件都是POSCARS的形式，跟采用何种结构优化软件包无关！</p>
<p>  <strong>问题2. Specific里面的文件怎么设置？</strong></p>
<ul>
<li><p>GULP计算时，ginput 和goptions一一对应，文件夹里面的文件还和INPUT.txt里面的4次结构优化对应。<br> 文件夹Submission的文件需要读者自己根据自己机器去修改了，然后假如读者机器里面有GULP的话，可以提交任务计算结果和reference对比一下。笔者在此不多说，直接看reference文件夹。</p>
<p>里面的文件和案例2的文件都是一样的，可见定成分变胞计算结果都是由这些文件组成的。现在我们看看结果文件BESTIndividuals和BESTgatheredPOSCARS，其余文件就不再介绍了。</p>
<p>从文件BESTIndividuals中可以看出到了第34代计算停止，之前30代的结构的焓值计算是一样，与INPUT.txt中stopCrit参数值30是对应的。既然有第34代最稳定结构的ID&#x3D;1562，那么根据ID&#x3D;1562去BESTgatheredPOSCARS中找结构，直接到文件最后找一下，另存ID&#x3D;1562的结构信息为一个文本文件，然后拖到VESTA，可以很直观的看到计算出的最稳定的结构究竟长什么样！</p>
</li>
</ul>
<h2 id="官方算例3"><a href="#官方算例3" class="headerlink" title="官方算例3"></a>官方算例3</h2><p>案例3：MgSiO3（每个单胞有20个原子）使用GULP(采用Buckingham势)在知道结构参数的条件下进行结构预测。这个结构的晶格参数和后钙钛矿一致。后钙钛矿的发现（Oganov &amp; Ono, Nature 2004; Murakami et al., Science 2004）在地球科学领域是一个重大突破。<br>我们直接来来读一下INPUT.txt：</p>
<pre><code>第11-13行、symmetries：16-74。第一次出现，设置生成结构的晶体对称性。三维晶体的取值范围：2-230。
第42-44行、Latticevalues：2.474 8.121 6.138 90.0 90.0 90.0 = b, c, alpha, beta, and gamma values。此参数仅用作初始猜测，仅影响第一代，USPEX计算的每个结构都经过充分优化，并采用与（自由）能量最小值相对应的晶体参数。INPUT.txt中其他的参数都在案例2中讲解过一次了，就不再解释了。下面我们来继续看一下结果！
</code></pre>
<p>可以看出，案例3总共计算20代，共626个结构，得到最稳定的结构的原子结构之后，可以去计算MgSiO3其他的性质。</p>
<h2 id="其他算例解释"><a href="#其他算例解释" class="headerlink" title="其他算例解释"></a>其他算例解释</h2><p><strong>案例4</strong>：预测16个C原子的最稳定的晶胞，但是使用LAMMPS优化结构计算能量，跟案例2、案例3基本上一样的，就不多介绍了!</p>
<p><strong>案例5</strong>：预测8个Si原子的最稳定的晶胞，但是ATK里面的tight binding近似方法来优化结构计算总能，不多解释啦！</p>
<p><strong>案例6</strong>：预测10 GPa下8个C原子的最稳定的晶胞，但是使用CASTEP优化结构计算能量，你懂的!</p>
<p><strong>案例7</strong>：预测8个Si原子构成的二维晶体在0 GPa下最稳定的结构。<br>这个案例有点不一样，我们来直接看一下INPUT.txt，再讲一下不一样的参数怎么构成不一样的计算。</p>
<pre><code>第5行、calculationType：-200。
这个为什么是-2，没这个维数取值呀？不懂直接USPEX –p calculationType！

可以看到2是表面结构，而-2是二维晶体结构，至于二维晶体和表面结构有什么区别？这个问题笔者不能很通俗易懂告诉大家，只能告诉你在USPEX中，二维晶体计算既不需要端点参考能也不需要衬底，而只需设置二维初始结构的厚度即可，而表面计算需要！

第7行、thicknessS：3.0。初始层厚度，最后一个是大写的S，因为是Start的缩写。


第10-12行、vacuumSize：8 9 10 12（20）？。设置真空层厚度，这是二维晶体和表面计算必须要设置的，不然的话，没有真空层，就会有作用力，计算的也就不是二维晶体。而这个参数，这里貌似设置错误了，少了1个参数。
</code></pre>
<p><strong>既然，我们读完INPUT.txt，那么有一个问题出来了：Seeds里面的文件怎么去设置了？还是POSCARS，里面还是放所有稳定的Si原子结构！</strong></p>
<p>我们现在来看一下结果！总共计算了13代共295个结构。那么最后一代稳定的结构长什么样了？显然POSCAR的原子坐标，根本看不出什么，而单胞结构示意图也看不出是二维晶体，做一个3x3x3的超胞，可以看出这就是一个二维晶体！USPEX多么神奇！</p>
<p><strong>案例8</strong>： 36个Mo原子的纳米粒子结构预测。使用Lennard-Jones对势函数的GULP进行结构优化。<br>这个案例值得看一下INPUT.txt。</p>
<pre><code>第5行、calculationType：000。纳米颗粒结构计算。

第36-38行、vacuumSize：10 10 11 12 12。真空厚度，案例7已经提到了，显然这个案例中真空层厚度值设置正确了。

这个计算结果，显示在第7代一下突然找到低焓值的结构，然后一直持续到了26代，总共有20代的最稳定的结构的焓值是一样。所以到了第26代计算结束了。而我们查看第26代最稳定的结构示意图如下，也真是纳米颗粒结构！
</code></pre>
<p><strong>总结</strong>：</p>
<pre><code>案例2：在100 GPa，MgAl2O4（28个原子的单胞）使用GULP采用Buckingham势-进行变胞计算。（calculationType：300）
案例3：MgSiO3（每个单胞有20个原子）使用GULP(采用Buckingham势)在知道结构参数的条件下进行结构预测。（calculationType：300）
案例4：预测16个C原子的最稳定的晶胞，但是使用LAMMPS优化结构计算能量。（calculationType：300）
案例5：预测8个Si原子的最稳定的晶胞，但是ATK里面的tight binding近似方法来优化结构计算总能。（calculationType：300）
案例6：预测10 GPa下8个C原子的最稳定的晶胞，但是使用CASTEP优化结构计算能量。（calculationType：300）
案例7：预测8个Si原子构成的二维晶体在0 GPa下最稳定的结构。（calculationType： -200）
案例8：36个Mo原子的纳米粒子结构预测。使用Lennard-Jones对势函数的GULP进行结构优化。（calculationType： 000）
</code></pre>
<p>其实可以看出，USPEX刚开始开发的时候，主要是用于定组分变胞的三维晶体最稳定的结构预测，后来功能慢慢的扩展开来，能够预测二维晶体、纳米粒子结构以及后面要讲案例中有关分子结构的预测、进化准动力学方法、表面结构预测、三元变组分结构预测方面的内容。</p>
<h1 id="六、官方算例（9-13）"><a href="#六、官方算例（9-13）" class="headerlink" title="六、官方算例（9-13）"></a>六、官方算例（9-13）</h1><p><strong>案例9</strong>：预测有4个甲烷分子的单胞在20 GPa下最稳定结构，结构优化采用的是VASP。<br>分子？这个我们还是第一次遇到，现在来看看怎么一回事？</p>
<p>可以看到案例9多出一个MOL_1的文件，现在我们先看看这个MOL_1文件有些什么：<br>这个文件在手册里面第5章里面有介绍，也可以在线观看（<a target="_blank" rel="noopener" href="https://uspex-team.org/online_utilities/uspex_manual_release/ChineseVersion/uspex_manual_chinese_V10.2/sect0029.html%EF%BC%89%EF%BC%8C%E9%87%8C%E9%9D%A2%E8%BF%98%E4%BB%8B%E7%BB%8D%E6%80%8E%E4%B9%88%E9%80%9A%E8%BF%87XYZ%E5%9D%90%E6%A0%87%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%A5%E5%88%9B%E5%BB%BAUSPEX%E4%BD%BF%E7%94%A8%E7%9A%84MOL%E6%96%87%E4%BB%B6%E3%80%82%E6%89%8B%E5%86%8C%E4%B8%8A%E9%9D%A2%E8%BF%99%E5%9D%97%E8%AE%B2%E7%9A%84%E6%8C%BA%E9%BA%BB%E7%83%A6%E7%9A%84%EF%BC%8C%E8%AE%A9%E7%AC%94%E8%80%85%E6%91%B8%E4%B8%8D%E7%9D%80%E5%A4%B4%E8%84%91%EF%BC%8C%E6%AF%95%E7%AB%9F%E7%AC%94%E8%80%85%E5%AF%B9%E4%BA%8E%E5%88%86%E5%AD%90%E6%8E%A5%E8%A7%A6%E7%9A%84%E5%B0%91%E3%80%82%E4%BD%86%E6%98%AF%E4%BB%8E%E6%9C%B1%E5%BC%BA%E5%8D%9A%E5%A3%AB%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E4%B8%AD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AF%BB%E5%88%B0%E8%BF%99%E4%B8%AA%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A%E5%9C%A8USPEX%E4%BA%A7%E7%94%9F%E5%88%86%E5%AD%90%E7%BB%93%E6%9E%84%E7%9A%84%E6%97%B6%E5%80%99%E8%BF%9B%E8%A1%8C%E7%BA%A6%E6%9D%9F%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%A4%A7%E5%A4%A7%E9%99%8D%E4%BD%8E%E6%90%9C%E7%B4%A2%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%87%8F%E5%B0%91%E8%AE%A1%E7%AE%97%E9%87%8F%EF%BC%9B%E5%85%B6%E6%AC%A1%EF%BC%8C%E4%BB%BB%E4%BD%95%E5%88%86%E5%AD%90%E7%9A%84%E8%83%BD%E9%87%8F%E5%80%BC%EF%BC%8C%E9%83%BD%E8%A6%81%E6%AF%94%E5%85%B6%E5%88%86%E8%A7%A3%E4%B8%BA%E6%B0%B4%E5%92%8C%E7%9B%90%E7%9A%84%E5%8C%96%E5%90%88%E7%89%A9%E7%9A%84%E8%83%BD%E9%87%8F%E5%80%BC%E4%BD%8E%E3%80%82">https://uspex-team.org/online_utilities/uspex_manual_release/ChineseVersion/uspex_manual_chinese_V10.2/sect0029.html），里面还介绍怎么通过XYZ坐标格式的文件来创建USPEX使用的MOL文件。手册上面这块讲的挺麻烦的，让笔者摸不着头脑，毕竟笔者对于分子接触的少。但是从朱强博士相关论文中，可以读到这个文件设置的作用：在USPEX产生分子结构的时候进行约束，这样大大降低搜索空间，减少计算量；其次，任何分子的能量值，都要比其分解为水和盐的化合物的能量值低。</a></p>
<p>进行分子结构预测时的INPUT.txt又需要注意哪些呢？</p>
<pre><code>第5行、calculationType：310 三维分子定组分。
第14行、numSpecies：1 4，这个官方案例有点问题，少了一个1，知道为啥不？
第35-38行、IonDistances，设置不同原子类型之间的最小原子间距离矩阵，而低于离子距离低于这个距离都被认为没有物理意义的，将被忽略！这里只有两种原子，所以只设置两行就行！第36行的2.0，表示C原子和C原子之间的最小距离，1.7表示C原子和H原子之间的最小距离；第37行的0.7表示H原子和H原子之间的最小距离。这些值都要比真实健值要小！

第40-42行、MolCenters，设置分子中心之间最小距离的矩阵，而任何低于这值的距离都表明分子有很大的重叠，是没有物理意义的，将被严格避免！第41行的2.8表示CH4的最小距离，单位为埃。进行分子结构预测时，这个必须设置！

INPUT.txt其余的参数在前面的案例中，已经介绍了。可以看出结构优化时，计算CH4结构的能量采用的是VASP，那么Specific文件夹里面就是INCAR五部曲和C、H原子的赝势！当然进行计算时，Seeds文件夹依旧是POSCARS，里面放的是C、H原子的最稳定的结构！可以看到除了多了MOL_1文件和INPUT.txt部分参数不一样外，分子结构预测跟其他晶体预测设置不一样？
</code></pre>
<p>下面我们来看看参考结果的reference文件夹：</p>
<p>里面也有MOL_1文件，这个是从之前的那个MOL_1拷贝过来的。其余的文件格式和内容与之前介绍的定成分计算的文件格式和内容都是一样！</p>
<p>案例9总共计算了9代197个结构，其中最稳定的结构也是这个对称性最低的CH4。</p>
<p><strong>案例10</strong>：预测有8个甲烷分子的单胞在常压下最稳定结构，结构优化采用的是DMACRYS；跟案例9类似，就不介绍了！</p>
<p><strong>案例11</strong>：预测有2个尿素分子的单胞在常压下最稳定结构，结构优化采用的是TINKER；跟案例9、10类似，就不介绍了！</p>
<p><strong>案例12</strong>：预测Mo-B二元体系常用最稳定的结构，变组分的结构预测，结构优化是采用Lennard-Jones对势的GULP做的。<br>案例12跟入门教程的La-H二元体系变组分结构预测是相似的，只是结构优化软件的软件包是不一样的，所以INPUT.txt就不介绍了。而在La-H二元变组分结构预测中，没来得及对计算结果进行分析，这次就在本教程对变组分的结果进行详细讨论。</p>
<p>我们先看参考答案reference文件夹里面有哪些文件：</p>
<p>这次文件夹里面有很多文件，又有些文件和定组分不同，但是对于变组分结构预测而言，只有extended_convex_hull、extended_convex_hull_POSCARS、extendedConvexHull.pdf和OUTPUT.txt这四个文件最重要，彻底掌握了这四个文件就掌握了变组分结构预测的结果分析。</p>
<p>下面先来看看老朋友OUTPUT.txt，看一下Mo-B变组分运算过程的信息：</p>
<p>可以看到总共计算了60代共5287个结构，最后列出来最稳定的成分，也就是凸包线点：Mo4、B6、MoB14、Mo4B8、Mo4B4、Mo2B6。（ps: 凸包线上稳定的单胞）。那么现在读者肯定很想知道凸包线是什么？直接打开extendedConvexHull.pdf！</p>
<p>图中绿色的点就是本次计算的结构的，而最下面的那条黑色就是凸包线，位于这条线上的点就是热力学上稳定的结构。在本图中从左到右总共有6个落在线上的点，和OUTPUT.txt里面的6个稳定的成分是相对应的。读者应该知道能够很清楚的知道X轴代表什么意思，怎么计算的。而Y轴形成焓（Enthalpy of formation，eV&#x2F;atom）是由下面公式计算出来的：<br>Y &#x3D; (E(AxBy)-x<em>E(A)-y</em>E(B))&#x2F;(x+y)<br>在案例12中，x: Mo原子的个数，y:B原子的个数。</p>
<p>而凸包线画法麻烦一点，先从两个端点开始，连接焓值最低点，然后找到端点到焓值最低点这段直线中下方最远的点，连线。迭代下去，直到没有一个点位于凸包线下面！<br>这条线的做法决定了稳定的结构都位于凸包线上。 假如有一个稳定的点在凸包线上方，那么它很容易分解为距离这个点最近的凸包线上的两个稳定点，有点类似直线方程的意思。</p>
<p>读者需要仔细体会上面一段内容，因为理解了上面的观点也就明白了变组分结构预测中凸包线的意思，那么一大堆相关论文也就会明白了。<br>既然我们得到知道稳定的成分，那么它们具体的结构是什么了？先看一下extended_convex_hull文件：</p>
<p>这个文件有些意思，第1-4行解释了extended_convex_hull文件的X、Y和Fitness这些标题的含义，其中X、Y和extendedConvexHull.pdf中X、Y轴是一一对应的，而Fitness这个就是结构离凸包线的距离，值为0意思就是在凸包线上，而值大于0就是在为凸包线上方，那么一个小小的思考题来了：为什么这个文件中没有Fitness值小于0的？（提示：思考凸包线的画法）</p>
<p>现在我们把注意放在第7-12行，因为它们Fitness的值为0，也就是说它们就是凸包线上的点。再看一下它们的Compositions和Enthalpies值，与OUTPUT.txt里面的值是一一对应的，综合以上信息，可以确定以上6个结构就是我们要找的稳定结构。从第13行往后就是根据Fitness从小到大排下去的，也可以认为这是根据稳定性排下去的，当然大部分情况下，这些结构都是不需要考虑的！既然我们知道要找到的稳定结构，那么怎么找到这些结构的原子坐标？这就需要看看extended_convex_hull_POSCARS了：</p>
<p>整个文件就是POSCAR的集合，并且每个结构的表头和之前的BESTgatheredPOSCARS是一样的，再加上第1行和第25行的ID，与extended_convex_hull里面前两个稳定结构的ID是一一对应的，那么显而易见extended_convex_hull_POSCARS文件和extended_convex_hull文件里面的结构是一一对应的。</p>
<p>既然知道这些预测出的稳定新结构了，就可以继续通过DFT计算它们的性质，然后得到数据，发Paper了，这还不简单？<br>这就是变组分结构预测需要了解和处理的文件：extended_convex_hull、extended_convex_hull_POSCARS、extendedConvexHull.pdf和OUTPUT.txt。除了凸包线画法需要用心体会，其余很简单吧！</p>
<p><strong>案例13</strong>：USPEX能很容易地找到最无序的合金结构。这个案例只是为了演示TixCo(1-x)O。您需要在&#x2F;Seeds&#x2F;POSCARS中指定初始结构，并且只使用置换突变操作。（在这种情况下，不需要使用任何外部代码。在这个例子中，我们优化（最小化）结构有序度（Oganov and Valle（2009）；Lyakhov Oganov Valle（2010））而不需要进行结构优化（abinitioCode&#x3D;0）。种子结构（Ti-Co-O结构的超级细胞）中的Ti原子和Co原子被置换，以寻找具有最小的有序度。在这种情况下最小化有序度，我们得到了“特殊准随机结构”的广义形式。）</p>
<p>这个案例的说明比较饶舌，还是直接看INPUT.txt吧：</p>
<pre><code>第6行、optType: -4，寻找有序最小的结构！因为4是寻找有序度最大的结构，所以-4是相反的意思。
第30行、howManySwaps：15，设置为这个值，是因为在第29行设置本次计算的子代结构都是通过交换父代结构中的原子产生的。本次计算的Co16Ti16O64的单胞，总共有96个原子，这个值占比15%左右。

第32-34行、specificSwaps：

1 2，指明只有Co、Ti原子能进行置换。
</code></pre>
<p>其余没有什么新鲜的参数要介绍了，不过读者可能会注意到，本次并没有进行结构优化，或者说是调用外部软件进行计算。都是USPEX通过自己的Fingerprint算法来计算有序度，这个具体是怎么一回事？可以参考这个在线网址(<a target="_blank" rel="noopener" href="https://uspex-team.org/online_utilities/fingerprints2/)%E3%80%82">https://uspex-team.org/online_utilities/fingerprints2/)。</a></p>
<p>好了，再把Seeds&#x2F;POSCARS文件准备好：放入Co、Ti、O原子所有稳定的结构信息进去就OK了。至于计算，本地计算就可以。我们先来看看结果吧（由于这次是300计算，结果只是需要关注BESTIndividuals、BESTgatheredPOSCARS、OUTPUT.txt），先看一下BESTIndividuals文件：</p>
<p>可见BESTIndividuals文件还是跟以前，到文件末尾总共有50代 (本图志截取到19代 )，那么问题又来了，我们需要预测的结构长什么样了？我们接着打开BESTgatheredPOSCARS文件：可以看出这个结构还是比较复杂的，有点无序的感觉，有点高熵合金的感觉。</p>
<p><strong>总结</strong>：</p>
<pre><code>案例9：预测有4个甲烷分子的单胞在20 GPa下最稳定结构，结构优化采用的是VASP。310
案例10：预测有8个甲烷分子的单胞在常压下最稳定结构，结构优化采用的是DMACRYS； 310
案例11：预测有2个尿素分子的单胞在常压下最稳定结构，结构优化采用的是TINKER； 310
这三个都是分子结构预测：310类型的，所以只详细的介绍了310。

案例12：预测Mo-B二元体系常用最稳定的结构，变组分的结构预测，结构优化是采用Lennard-Jones对势的GULP做的。301
这个案例主要是介绍了结果分析，其中关于凸包线的那段值得读者思考一下，弄明白了，很多Paper都能理解了。

案例13：预测最无序的TixCo(1-x)O合金结构。300
这个案例主要介绍无序结构预测，有点准随机的感觉，目前笔者感觉其在高熵合金方面有潜在用途。
</code></pre>
<h1 id="七、官方案例讲解（14-15）"><a href="#七、官方案例讲解（14-15）" class="headerlink" title="七、官方案例讲解（14-15）"></a>七、官方案例讲解（14-15）</h1><p><strong>案例14</strong>：通过进化准动力学(Evolutionary metadynamics)预测下常压下Si的低能亚稳结构，结构优化采用的是VASP。<br>这个案例就是为了展示Evolutionary Metadynamics强大的威力，其实最近为了演示水分子结晶问题这一科学热点问题，Metadynamics出了很大一把力。下面还是闲话少说，我们来看看怎么设置计算和分析结果的。<br>先看一下INPUT.txt</p>
<pre><code>第1行、calculationMethod: META，第一次看到不是USPEX，而是META(Evolutionary metadynamics)。
第8行、minVectorLength: 2.0，设置生成的子代结构最短的健长

第9行、maxVectorLength：8.0，这个值是Evolutionary metadynamics独有的，是设置最大的健长，假如在进化准动力学计算中，单胞的健长没有处在最小健长和最大健长之间，那么在计算时，软件会自动校正，使晶胞进入正常的范围。


第15行、mutationDegree：3.0、设置软模突变(softmutation)的程度，单位为埃。简单一点的意思就是设置晶格某个原子位置方向的突变距离。在Evolutionary metadynamics算法中，晶胞都是通过软模突变生成子代结构的。


第16行、：GaussianHeight：250.0，进化准动力学专门的参数，用来促进晶胞相变，具体的值跟晶格常数和剪切模量相关。

第17行、GaussianWidth：0.3。有高斯高度，那么肯定会有一个高斯宽度了！作用和GaussianHeight一样，但是这个参数只和晶胞最小长度有关。

第18行、FullRelax：2，metadynamics原理是晶胞在某个方向上，长度发生变化，然后进行固定体积结构优化。而这个FullRelax就是设置结构优化的程度，可以理解为精度，0：精度最低，1：精度一般，2：精度可靠，大部分计算都采用2。
</code></pre>
<p>好了，进化准动力学参数介绍就介绍了到这里了。但是读者可能会有点好奇，这里为什么我们没有设置体系？ 因为不需要！META计算类型，计算很特别的:</p>
<p>不需要设置Seeds&#x2F;POSCARS文件，因为计算时一般采用POSCAR_1作为初始结构，然后通过软模突变(softmutation)生成子代结构，然后结构优化，选择最稳定结构迭代下去，另一个需要注意的是这个计算截止条件是INPUT.txt里面设置的代数。</p>
<p>好了我们来处理一下结果，这里需要提一句的就是，进化准动力学是寻找跟初始结构相差不是很大的亚稳结构，因而每一代焓值最低的结构都要考虑。我们来看一下参考文件夹reference</p>
<p>这里面有很多文件很熟悉，看着名字也能猜出文件里面放的是什么，那么META(进化准动力学) 最重要的文件就是BESTIndividuals_relaxed 和BESTgatheredPOSCARS_relaxed这两个文件，不过我们先看一下BestEnthalpy.pdf</p>
<p>这个图片，绿色的点连成的红色虚线是未完全弛豫的最好结构的焓值，而蓝色的线则是完全弛豫结构的焓值。<br>接着打开BESTIndividuals_relaxed，熟悉的味道：</p>
<p>打开BESTgatheredPOSCARS_relaxed也还是熟悉的味道，就不多解释了。</p>
<p>不过这样打开展示结果并不是一个很好的方式，也许在BestEnthalpy.pdf的图片中添加亚稳结构的示意图会更有意思，更直观，但是不在这个教程演示了，会在案例21：EX21-META_MgO_gulp里面展示，并总结一下META方法和USPEX方法之间的对比。</p>
<p>BESTgatheredPOSCARS_relaxed就是案例9计算最后得到的亚稳结构，在研究中，所有的这些结构都需要考虑。也许有人会感觉这个META方法有点鸡肋，但是在研究相变的时候，尤其是水分子结晶过程，这个方法很有用！</p>
<p><strong>案例15</strong>：通过VCNEB (variable-cell nudged elastic band)预测下常压下Ar的fcc-hcp的转变过程，结构优化采用的是GULP，并采用Lennard-Jones对势。<br>闲话少说，我们先看看INPUT.txt是怎么一回事：</p>
<pre><code>第18行、vcnebType：111，指定VCNEB计算的类型。此变量由三个指标组成：计算选项（1：VCNEB方法，2：没有VCNEB计算的结构优化模式）、虚像结构数目的可变性（0：VCNEB虚像结构的数目是固定的，1：VCNEB虚像结构的数目是固定的是可变的）和弹簧常数的可变性（0：固定的弹性常数，1：可变的弹性的常数）；111，一般是推荐在重构相变（reconstructive phase transitions）上使用。重构相变：在热力学上，重构相变在相变压力/温度下呈现出焓和体积 “跳跃”变化的特征，其中，由于原子位置的变化，自由能一阶导数（熵和体积）存在不连续性。

第19行、numImages：15，执行VCNEB的初始虚像的结构的数目。
第20行、numSteps：500，执行VCNEB计算相变路径优化时的最大步数，由于VCNEB计算的过程收敛比较慢，所以一般推荐设置为500。
第21行、optimizerType：1，结构优化采用的算法：1、最速下降法，2、FIRE (Fast Inertial Relaxation Engine)。
第22行、optReadImages：2，虚像结构文件（Images）类型读取选项：0，文件中包含了所有的虚像结构，1，文件中只包含初始和最后的虚像结构，2，文件包含了初始、最后和特别指定中间虚像结构。其中选项1，2其余的虚像结构都是通过线性插值获得。
第23行、optRelaxType：3，结构优化的模式，选项：1，晶胞固定只优化原子位置，经典的NEB的方法；2，只优化晶胞点阵大小（仅仅用作测试）；3，晶胞点阵大小和原子位置都优化（变胞优化）。
第24行、dt：0.25，结构优化的时间步，设置的值太小时收敛很慢，设置很大的时候经常产生没意义的相变路径。
第25行、ConvThreshold：0.003，整个VCNEB计算收敛的标准：RMS（Root Mean Square forces）。
第29行、VarPathLength：0.3，变虚像结构方法的虚像结构的路径长度批判准则。当两个相邻虚像结构之间的长度大于VarPathLength的1.5倍时，将使用线性插值方法在两个虚像结构之间添加一个新虚像结构；当长度小于该值的0.5时，将删除第二个虚像结构。
第30行、K_min：3，单位：eV/A^2，最小的弹性常数，只在变弹性常数的VCNEB中使用。
第31行、K_max：6，单位：eV/A^2，最大的弹性常数，只在变弹性常数的VCNEB中使用。
第32行、optFreezing：0，达到收敛标准时，虚像结构是否还变动，0：变，1：不变。
第33行、optMethodCIDI：0，是否采用Climbing-Image (CI)/ Downing-Image (DI)方法，推荐使用0：CI/DI方法不采用。具体讲解如下：
</code></pre>
<p>到此案例15的VCNEB计算参数介绍也算完成了，VCNEB就是用来研究固体相变和反应路径的，比NEB更高级一点。<br>设置完了INPUT.txt，就可以准备计算了，但是需要注意VCNEB计算不需要设置种子文字Seeds，需要设置一个Images的文件，也就是虚像结构文件，包括初始虚像结构和最终虚像结构，（VCNEB就是计算初始结构和最终结构之间的相变路径的），其采用的是VASP4的POSCAR形式，如下图所示：</p>
<p>计算完之后，我们来看看结果!</p>
<p>里面有很多文件，我们不认识，但是没关系的，很多文件通过文字名字也能了解很多，我们一般只熟悉EnergyBarrier.pdf和transitionPath_POSCARs即可，因为EnergyBarrier.pdf里面放的是反应路径中虚像结构和能量的图，而transitionPath_POSCARs则是这个反应路径中对应的虚像结构的POSCAR文件。综合EnergyBarrier.pdf和transitionPath_POSCARs这两个文件，可以得到如下漂亮的结果：</p>
<p>图中，展示了初始、最终和中间鞍点的Ar结构，其余结构就没多做演示了。但是从这个这个图可以看出VCNEB计算相变路径的强大的能力。但是为什么选择这个路径了？从计算结果文件里面查看PATH这个文件夹内容，就会发现有500个相变路径（和INPUT.txt的参数numSteps对应），但是最后还是找到EnergyBarrier的反应路径（step 434），因为这个是实际情况最接近了，也可以从SelectedEnergyBarrier.pdf文件里面直观看出来为什么选择step 434：</p>
<p>从初始的fcc-Ar结构怎么变成了最后的hcp-Ar结构了？VCNEB给出最佳路径和中间反应的一系列的结构是不是真实的？从这个方法的程序编写者钱博士（虽然他现在不从事科研，去做人工智能创业）的PPT中可以看到VCNEB还是比较有用的：</p>
<p>上面讲了很多VCNEB在USPEX程序中的参数设置和简单的结果的文件分析，但是这个VCNEB方法跟NEB有什么区别了？或者说它的原理是什么了？可以看出在Update Images这个过程当中使用的进化算法进行迭代，其余过程和NEB计算过程都差不多。还有一个特别值得一提的是：VCNEB能够给出一个相对可靠的相变路径，但是结合TPS（Transition Path Sampling）方法，能够给出更可靠的相变路径，这是这个方法存在的意义！</p>
<p><strong>总结</strong>：</p>
<pre><code>案例14：通过进化准动力学(Evolutionary metadynamics)预测下常压下Si的一系列低能亚稳结构，结构优化采用的是VASP。
案例15：通过VCNEB (variable-cell nudged elastic band)预测下常压下Ar的fcc-hcp的相变路径，结构优化采用的是GULP，并采用Lennard-Jones对势。
</code></pre>
<p>这两个案例比较特殊，分别介绍了META、VCNEB两个计算方法，虽然目前这两个方法用的人比较少，但是笔者相信，这两个方法对于某些工作绝对是一个有力的工具。</p>
<h1 id="八、官方案例讲解（16-18）"><a href="#八、官方案例讲解（16-18）" class="headerlink" title="八、官方案例讲解（16-18）"></a>八、官方案例讲解（16-18）</h1><p><strong>案例16</strong>：变胞定组分预测SrTiO3（50 原子&#x2F;单胞 ）0 GPa下稳定的结构，结构优化采用的是GULP（采用Buckingham势）。（这个案例存在的意义就是为了吊打XtalOpt：也是遗传算法的结构预测软件，USPEX大体系的成功率大于90%，而XtalOpt只有7-12%）。<br>案例16是300类型，我们的老朋友了，就不介绍INPUT.txt了，直接来看结果吧。300类型的计算，结果需要看哪些文件了？BESTIndividuals和BESTgatheredPOSCARS！</p>
<p>从BESTIndividuals可以看到本次计算了42代结构，计算了大概1400多个结构，最后得到如下的稳定结构：</p>
<p>可见对于单胞50个原子这么大的结构，USPEX也能很快得到稳定的结果，而其中执行结构优化的GULP也功不可没呐。</p>
<p><strong>案例17</strong>：以最高德拜温度为目的变胞定组分预测单胞8个C原子的稳定结构，结构优化采用VASP软件包。</p>
<p>案例17还是300类型的计算，但是这次是预测具有最高德拜温度的温度结构，那么也只需要在optType参数中，将我们通用的以焓值为优化目的改为以德拜温度为目的就行了。其余的话，参数设置和一般300类型类似。但是这次需要对Specific文件里面的INCAR做一次了解，因为根据INCAR也能猜测出USPEX究竟怎么计算的。</p>
<p>Specific文件里面有5个INCAR，可以看出第一次和第二次是定体积的结构优化，而第三次和第四次结构优化是变体积的，经过这四步结构优化得到最小能量和相应的构型，最后才做弹性常数计算，因为德拜温度和弹性常数计算相关（当然这些计算是在VASP当中完成的）。</p>
<p>从OUT.txt中可以看出USPEX总共计算了15代共351个结构，这样计算量并不大，因为这个案例是作为演示用的，INPUT.txt里面设置的代数和每代个数并不多。</p>
<p>300计算类型的还需要看的就是BESTIndividuals和BESTgatheredPOSCARS这两个文件。先来看看BESTIndividuals这个文件：</p>
<p>由于这次是根据德拜温度为目标进行稳定结构预测，那么就是根据Fitness大小程度来筛选德拜温度最高的稳定结构，Fitness负的越大的结构，德拜温度更高，接下来我们来看看这个德拜温度最高的稳定结构长什么样？</p>
<p>可以看出只需要在optType参数里面修改优化参数就能获得具有相应特殊性质的稳定结构，这些特殊性质包括：</p>
<p><strong>案例18</strong>：三元体系Zn-O-H的变成分结构预测，结构优化还是采用GULP软件进行的。</p>
<p>由于变组分结构预测这方面非常非常重要，我们前面也介绍过两次了，但是这次准备继续再一次仔细介绍一下，因为大部分USPEX文章都是靠这个变组分结构预测方法产生。先来看看INPUT.txt文件：</p>
<pre><code>第4-17行是设置整个大的计算类型和体系，也就是让软件知道采用USPEX方法进行301计算，以焓值最低为目的进行优化（焓值越低越稳定）。而计算哪个体系？Zn-O-H，这三个元素以任意比例构成的结构。
第21-25行是设置USPEX遗传算法种群大小和代数。
第29-33行是设置遗传算法的产生子代结构的具体操作。
第37-46行是设置外挂的第一性原理软件。
</code></pre>
<p>USPEX的参数设置总结起来就是，先设置体系和类型，再设置种群和遗传操作，最后设置外挂的第一性原理软件，当然从官方案例拷贝一个类型的INPUT.TXT修改一下就行，不懂的参数USPEX –p xxx，就这么简单。</p>
<p>前面介绍过二元体系的变组分结构预测的结果处理，强调了凸包线的原理和作用，而此次是三元体系的变组分结构预测，还是凸包线吗？想想也是不可能，只能往三元金字塔相图那边想，预测结果最直观的展示就是打开compositionStatistic.pdf文件：</p>
<p>当然看到这个图，肯定会有点懵逼的感觉了，这个图要表达什么意思，这个Stable的结构到底是哪个了？不要着急，这个只是展示结构分布的图，具体的稳定的结构从OUTPUT.txt可以得到的：</p>
<p>这里需要抱怨一下USPEX开发者吧，这里数据并没有处理，三元体系的稳定的结构的成分为三种元素构成，前两个是整数，后一个为啥是小数了？虽然最后一位是小说看起来很别扭，但是这些结构都是我们的指路明灯，有些这些结构我们就能很有针对性和目标性的处理extended_convex_hull和extended_convex_hull_POSCARS这两个重要的文件。</p>
<p>先来看看extended_convex_hull这个文件，这个和二元体系有什么区别，其实是没多大区别的，但是二元体系里面的数据能够生动的和凸包线结合在一起，二元体系里面前面的几行的数据和OUTPUT.txt里面总结出来的稳定结构一一对应，也就是说都是凸包线上的点。而三元体系的数据有点让人摸不着头脑的感觉，看看前面几行的数据和OUTPUT.txt得到的稳定结构对应不上，只能根据OUTPUT.txt得到的稳定结构的成分来搜索。比如想找Zn1O5H10这个成分的稳定结构，直接<br><code>grep &quot;1  5 10&quot; extended_convex_hull</code><br>一下子就能extended_convex_hull找到好几个成分为Zn1O5H10的结构，当然是焓值最低的结构最稳定，那么ID为9219的结构最稳定了，既然知道了稳定的结构的ID，那么它的原子坐标信息也就好办了，直接上extended_convex_hull_POSCARS搜索一下就行：<br>grep -n EA9219 extended_convex_hull_POSCARS</p>
<p>很简单一个命令就能找到ID为9219的原子坐标信息所在的行数，那么知道行数以后，直接去extended_convex_hull_POSCARS找。</p>
<p>当然这只是一个结构的处理，OUTPUT.txt那么多稳定的结构还等待读者去处理。当然可以一个个手工去处理，也可以写一个简单脚本去处理。接下来请稍微深入的思考一下：三元体系变组分的有了这么一个初步的结果，怎么把这些结果变成paper了？下面一篇文章能够得到很好答案。<br>doi: 10.1038&#x2F;srep18347 (2015)</p>
<p>对于三元变组分结构预测，笔者还有一些需要说道一下：三元变组分搜索的计算巨大，比二元变组分计算量大的不只是一点点，并且准确率还是一个值得考虑的问题，所以一般并不建议采用这个三元体系去计算，除非计算资源很大，并不考虑投入产出的问题，存粹只是为了科研。</p>
<p>就拿Zn-O-H这三元体系计算来说，问题还是比较大的，总共计算了9339种结构，并且每种结构计算了5次，这就是差不多5W次计算，服务器跑起来至少一个月左右。再对结果进行进一步的处理，一个月左右的时间又过去了。这仅仅是一个压强下的结果，而实际上还需要计算不同压强的情况。此外有时候为了更好的处理三元体系的结果，还需要从三元体系里面找一些二元体系进行计算，这是一个庞大的工作。笔者在这里只是想强调三元体系计算变组分并不容易，如果准备三元体系计算变组分还需要做好心理准备。</p>
<p><strong>总结</strong></p>
<pre><code>案例16：变胞定组分预测SrTiO3（50 原子/单胞 ）0 GPa下稳定的结构，结构优化采用的是GULP（采用Buckingham势）。300
案例17：以最高德拜温度为目的变胞定组分预测单胞8个C原子的稳定结构，结构优化采用VASP软件包。300
案例18：三元体系Zn-O-H的变成分结构预测，结构优化还是采用GULP软件进行的。301
</code></pre>
<p>这三案例都是老朋友，前面都讲过很多次，但还是有些不一样的地方，所以这次教程比较详细的介绍了不同的地方：大体系定组分稳定结构预测、以德拜温度为目的进行定组分结构预测、计算量惊人的三元体系的变组分结构预测。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/11/18-47-22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/11/18-47-22/" class="post-title-link" itemprop="url">5.3 非绝热分子动力学</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-11 18:47:22" itemprop="dateCreated datePublished" datetime="2023-09-11T18:47:22+08:00">2023-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-16 10:08:45" itemprop="dateModified" datetime="2025-07-16T10:08:45+08:00">2025-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>参考官网：<br><a target="_blank" rel="noopener" href="https://www.vasp.at/wiki/index.php/Machine_learning_force_field_calculations:_Basics">https://www.vasp.at/wiki/index.php/Machine_learning_force_field_calculations:_Basics</a></p>
<p><a target="_blank" rel="noopener" href="https://www.vasp.at/wiki/index.php/Best_practices_for_machine-learned_force_fields">https://www.vasp.at/wiki/index.php/Best_practices_for_machine-learned_force_fields</a></p>
<p><a target="_blank" rel="noopener" href="https://www.vasp.at/wiki/index.php/Machine_learning_force_field:_Theory">https://www.vasp.at/wiki/index.php/Machine_learning_force_field:_Theory</a></p>
<h1 id="Hefei-NAMD"><a href="#Hefei-NAMD" class="headerlink" title="Hefei-NAMD"></a>Hefei-NAMD</h1><p>on-the-fly训练是基于分子动力学(MD)模拟来采样训练结构。逐步自动组装数据集，并在可行时用于生成MLFF。相反，在每个时间步骤中，当前力场预测能量、力和相应的贝叶斯误差估计。简单来说，如果误差超过一定阈值，将执行另一个从头开始的计算，并将参考能量和力添加到训练数据集中。相反的情况下，从头开始的步骤将被省略，系统将通过MLFF预测进行传播。随着轨迹上力场的改善，许多从头开始的步骤可以被避免，MD模拟将显著加速。最终，现场训练会产生一个准备投入生产的MLFF，即以预测模式运行MD模拟。以下步骤概述了从开始到生产运行的路径：</p>
<h1 id="PYXAID"><a href="#PYXAID" class="headerlink" title="PYXAID"></a>PYXAID</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/09/18-50-22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/09/18-50-22/" class="post-title-link" itemprop="url">5.2 分子动力学2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-09 18:50:22" itemprop="dateCreated datePublished" datetime="2023-09-09T18:50:22+08:00">2023-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-16 10:09:52" itemprop="dateModified" datetime="2025-07-16T10:09:52+08:00">2025-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>参考官网：<br><a target="_blank" rel="noopener" href="https://www.vasp.at/wiki/index.php/Machine_learning_force_field_calculations:_Basics">https://www.vasp.at/wiki/index.php/Machine_learning_force_field_calculations:_Basics</a></p>
<p><a target="_blank" rel="noopener" href="https://www.vasp.at/wiki/index.php/Best_practices_for_machine-learned_force_fields">https://www.vasp.at/wiki/index.php/Best_practices_for_machine-learned_force_fields</a></p>
<p><a target="_blank" rel="noopener" href="https://www.vasp.at/wiki/index.php/Machine_learning_force_field:_Theory">https://www.vasp.at/wiki/index.php/Machine_learning_force_field:_Theory</a></p>
<h1 id="vasp6自带的机器学习"><a href="#vasp6自带的机器学习" class="headerlink" title="vasp6自带的机器学习"></a>vasp6自带的机器学习</h1><p>on-the-fly训练是基于分子动力学(MD)模拟来采样训练结构。逐步自动组装数据集，并在可行时用于生成MLFF。相反，在每个时间步骤中，当前力场预测能量、力和相应的贝叶斯误差估计。简单来说，如果误差超过一定阈值，将执行另一个从头开始的计算，并将参考能量和力添加到训练数据集中。相反的情况下，从头开始的步骤将被省略，系统将通过MLFF预测进行传播。随着轨迹上力场的改善，许多从头开始的步骤可以被避免，MD模拟将显著加速。最终，现场训练会产生一个准备投入生产的MLFF，即以预测模式运行MD模拟。以下步骤概述了从开始到生产运行的路径：</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="1、准备"><a href="#1、准备" class="headerlink" title="1、准备"></a>1、准备</h3><p>准备POSCAR、POTCAR、KPOINTS和AIMD的INCAR文件。</p>
<h3 id="2、从零开始-on-the-fly训练"><a href="#2、从零开始-on-the-fly训练" class="headerlink" title="2、从零开始 on-the-fly训练"></a>2、从零开始 on-the-fly训练</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ML_LMLFF = .TRUE.  #开启机器学习</span><br><span class="line">ML_MODE = train    #训练模式</span><br></pre></td></tr></table></figure>
<p>将会生成几个重要的文件：</p>
<p>ML_LOGFILE The log file for all MLFF-related details; training status, current errors and other important quantities can be extracted from here.(search err)</p>
<p>ML_ABN This file contains the collected training structures and a list of selected local reference configurations.</p>
<p>ML_FFN A binary file containing the current MLFF.</p>
<h3 id="3、重复训练（可选）"><a href="#3、重复训练（可选）" class="headerlink" title="3、重复训练（可选）"></a>3、重复训练（可选）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp ML_ABN ML_AB</span><br><span class="line">cp CONTCAR POSCAR</span><br></pre></td></tr></table></figure>

<p>也可以重复2步骤完全重新训练。INCAR和其他文件保持不变。如果读取上一步的力场，可以修改POSCAR以完成结构的变化，比如吸附、表面等。</p>
<p>将 ML_MODE 设置为 train 不变，然后重新启动 VASP。日志文件将包含一个描述现有数据集的部分，以及在生成力场之后，常规的即时程序将继续进行。最终，ML_ABN 将包含来自两个即时运行的训练结构。类似地，ML_FFN 文件是一个合并的力场。在存在 ML_AB 文件的情况下，train 模式将始终执行一个续集运行。如果想重新开始，只需从执行目录中删除 ML_AB 文件。</p>
<h3 id="4、refit快速预测"><a href="#4、refit快速预测" class="headerlink" title="4、refit快速预测"></a>4、refit快速预测</h3><p><code>cp ML_ABN ML_AB</code></p>
<p>INCAR修改：</p>
<p><code>ML_MODE = refit</code></p>
<p>会生成新的 ML_FFN。官网提示这一步是必要的。在即时训练成功且结果符合你对适用性和剩余误差的期望时，在力场应用于仅预测的 MD 运行之前还有最后一步需要完成：为快速预测模式重新拟合。再次将最终数据集拷贝到 ML_AB 文件中：</p>
<p>cp ML_ABN ML_AB<br>同时，在 INCAR 文件中设定：</p>
<p>ML_MODE &#x3D; refit<br>运行 VASP 将会创建一个新的 ML_FFN 文件，最终可以用于生产。</p>
<p>重要提示：尽管在技术上可能直接进行第5步，但强烈不建议这样做。没有重新拟合步骤，VASP 无法启用具有大约 20 到 100 倍加速的快速预测模式。你可以检查 ML_FFN 文件的 ASCII 头部信息，确保其中的力场支持快速预测。</p>
<h3 id="5、运行机器学习MD"><a href="#5、运行机器学习MD" class="headerlink" title="5、运行机器学习MD"></a>5、运行机器学习MD</h3><p><code>cp ML_FFN ML_FF</code></p>
<p>INCAR修改：</p>
<p><code>ML_MODE = run</code></p>
<p>选择这个设置后，VASP 将仅使用来自 MLFF 的预测结果，不进行从头算的计算。与相应的从头算运行相比，每个时间步的执行时间将降低几个数量级。</p>
<p>提示：MLFF 可以应用于更大的系统尺寸，即，你可以复制模拟盒以获得改进的统计数据。由于这种方法与原子数呈线性关系，因此你可以轻松估计对计算需求的影响。</p>
<p>ML_MODE参数见：<br><a target="_blank" rel="noopener" href="https://www.vasp.at/wiki/index.php/ML_MODE">https://www.vasp.at/wiki/index.php/ML_MODE</a></p>
<h3 id="建议："><a href="#建议：" class="headerlink" title="建议："></a>建议：</h3><p>即时学习可能比单点电子计算要复杂得多，因为它结合了 VASP 的多个特征。每个部分都需要通过可用的 INCAR 标签进行适当设置。如果计算的某个部分配置错误，可能会严重影响生成的 MLFF 的质量。在最坏的情况下，成功的训练甚至可能不可能实现。更具体地说，即时学习需要控制以下方面：</p>
<p>一致的收敛性<br>需要确保通过即时学习收集的所有从头算参考数据在单点电子计算设置方面是一致且收敛良好的。注意分子动力学运行中针对不同温度和密度的目标。一个 MLFF 只能再现单一的势能景观！<br>正确设置分子动力学模拟<br>考虑热力学集合的选择、恒温器和恒压器设置以及适当的时间步长。<br>正确设置机器学习力场参数<br>注意系统相关参数，如截断半径或原子环境描述符分辨率。<br>通过即时学习控制数据集生成<br>监控和控制通过自动贝叶斯阈值确定和稀疏化收集多少从头算参考数据。<br>质量控制<br>建立对剩余训练误差的合理期望。通过将预测与已知量（从从头算中）进行比较来评估生成的力场的质量。<br>提示：在尝试从头开始生成 MLFF 之前，首先要彻底熟悉系统的纯从头算计算。一旦你有信心控制收敛性，可以继续进行一次简短的 MD 模拟，不使用机器学习辅助。验证结果是否符合预期的值，如守恒原理等。只有在这样做之后，才能继续进行计算的机器学习方面。</p>
<ul>
<li>熟悉第一性原理计算，机器学习之前先进行简短的MD模拟以验证结构是否符合预期。</li>
<li>为了结果的准确性，要注意动态训练收集的参考数据与单点电子计算设置保持一致且收敛良好。注意 MD 运行中针对的不同温度和密度。MLFF只能再现单一的势能！</li>
<li>选择MD过程合适的系综、时间步长等参数</li>
</ul>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>使用机器学习力场方法，VASP可以基于第一性原理模拟来构建力场。在构建、测试、重新学习和应用力场时，必须仔细考虑许多方面。这里列出了一些最佳实践，但请注意，这个列表并不全面，这种方法尚未被应用到大量系统中。因此，我们建议进行常规严格的监测，这对所有研究项目都是必要的。机器学习力场（MLFF）培训所需的基本步骤可以在机器学习力场计算的基础页面上找到。</p>
<p>要开始训练运行，请将 ML_MODE &#x3D; TRAIN。取决于在执行 VASP 的文件夹中是否存在有效的 ML_AB，将自动选择两种模式中的一种：没有 ML_AB 文件：训练算法将从零开始。存在 ML_AB 文件：基于现有结构数据库将继续训练。在这种操作模式下，将从现有数据库（ML_AB 文件）生成一个力场，然后从指定的 POSCAR 文件中继续进行 MD 运行。这种模式用于从材料的相空间中选择额外的结构。但也可以用于通过首先训练块材料，然后在 POSCAR 文件中向表面添加分子并继续训练来检查表面。<br>如果有几个相同种类的原子应该由机器学习算法进行不同处理，重要的是在 POSCAR 文件中给它们不同的名称。例如，如果在块材料中有氧原子并且在表面的分子中也有氧原子，建议在 POSCAR 中将氧原子分成两组，并分别命名为 O1 和 O2。不可能在POSCAR文件中给不同的原子组相同的名称，名称限制为两个字符。训练模式要求VASP执行从头算计算，因此第一步是建立电子最小化方案。</p>
<p>警告：非常重要的一点是在从头开始训练和继续训练之间不要更改INCAR文件中的从头参数设置。同样，在恢复训练时不允许更改POTCAR文件。</p>
<h3 id="第一性原理计算部分"><a href="#第一性原理计算部分" class="headerlink" title="第一性原理计算部分"></a>第一性原理计算部分</h3><ul>
<li>先进行自洽计算，不要设置 MAXMIX&gt;0 </li>
<li>一般可以先单胞，然后应用到超胞。</li>
<li>自洽计算检查K点、截断能等收敛情况。</li>
<li>(ISYM&#x3D;0)对于标准的MD</li>
<li>NPT等不固定体积的ENCUT要比固体体积大30%。</li>
</ul>
<p>通常，VASP DFT 计算适用的一切也适用于这里。电子最小化的准则可用于为即时学习设置从头算部分。另外，我们强烈建议在即时学习期间遵循以下关于从头算计算的准则：<br>当使用用于机器学习的力场时，请不要设置 MAXMIX&gt;0。在机器学习过程中，常常会跳过第一原理计算数百甚至数千个离子步骤，而离子在第一原理计算之间可以有明显的移动。在这些情况下，使用 MAXMIX 往往会导致电子结构不收敛或在自洽循环中出现错误。<br>通常可以在较小的单元胞上训练力场，然后将其应用于较大的系统。务必选择一个足够大的结构，以便声子或集体振荡“适应”到超晶格中。<br>学习准确的力很重要。为此，必须检查电子最小化是否收敛。这些检查可能包括 KPOINTS 文件中的 k 点数目、平面波极限（ENCUT）、电子最小化算法等。<br>关闭标准分子动力学运行的对称性（ISYM&#x3D;0）。<br>对于没有固定网格（NpT）的模拟，平面波截断 ENCUT 必须设置得比固定体积计算高出至少 30%。此外，经常重新启动（ML_MODE&#x3D;TRAIN，工作目录中存在现有的 ML_AB 文件）以重新初始化 KS 轨道的 PAW 基函数并避免 Pulay 应力。</p>
<h3 id="MD部分"><a href="#MD部分" class="headerlink" title="MD部分"></a>MD部分</h3><ul>
<li>有轻原子要减小POTIM或增大轻原子的POMASS，氢原子不超过0.7 fs 氧原子不超过 1.5 fs。</li>
<li>TEEND要大于TEBEG，且大于目标温度30%。</li>
<li>最好NPT，或者NVT+ Langevin thermostat，避免NVE。</li>
</ul>
<p>通过Hellmann-Feynman定理从电子最小化获得力之后，VASP必须传播离子以在相空间中获得新的构型。对于分子动力学部分，熟悉设置分子动力学运行是有利的。此外，在分子动力学部分，我们建议以下设置：</p>
<p>如果系统中含有轻元素，请减小积分步长（POTIM），或者在INCAR或POTCAR文件中增加轻元素质量（POMASS）。作为一个经验法则，时间步长不应超过氢元素和含氧化合物分别为0.7 fs和1.5 fs。然而，对于重元素（如硅），3 fs的时间步长可能效果更好。<br>如果可能的话，通过温度梯度逐渐加热系统（将TEEND设置得高于TEBEG）。从一个较低的温度（不是零度）开始，并逐渐增加到所需应用温度的30%以上。这将有助于“实时”训练探索相空间的更大部分，并将导致更稳定的力场。<br>如果可能的话，更倾向于在NpT集合中进行分子动力学训练（ISIF&#x3D;3）。额外的晶胞波动可以提高所得到的力场的稳健性。但是，对于流体，只允许超晶胞的体积变化，否则晶胞可能“崩溃”，即极端倾斜，使系统成为一层原子。这可以通过ICONST在这里和这里来实现。有关约束晶胞形状的示例输入，请参阅ICONST页面或本页面的末尾。NVT集合（ISIF&#x3D;2）对于训练也是可以接受的，但使用随机热浴恒温器，因为它非常适合相空间采样（遍历性）。<br>我们应该尽可能地探索材料相空间的更多部分。因此，应始终避免在NVE集合中训练。</p>
<h3 id="训练部分"><a href="#训练部分" class="headerlink" title="训练部分"></a>训练部分</h3><ul>
<li>分步训练：比如表面吸附分子，先训练晶体，然后表面、单独分子和整个系统。</li>
<li>给定结构，温度、压力越大，误差越大，</li>
</ul>
<p>ML_MODE&#x3D;TRAIN已经为机器学习中的即时训练设置了广泛使用的默认值。尽管如此，我们仍然想为设置单独的机器学习参数提供以下指导：</p>
<p>如果系统包含不同组件，首先要分别训练它们。例如，如果系统由一个晶体表面和与该表面结合的分子组成。先训练主要的晶体，然后是表面，可能是孤立的分子，最后是整个系统（如果您不需要描述孤立的分子，可以跳过对该分子的训练）。通过这种方式，可以避免在计算密集型的复合系统中进行大量的从头算计算。</p>
<p>如果在训练过程中没有足够的参考配置（在ML_ABN中可以看到），则应该调整ML_EPS_LOW的默认值，以稀疏使用从ML_AB中提取的局部参考配置。这可以改善训练好的力场的性能。但是，这也可能会降低准确性。</p>
<p>注意：超参数优化应始终从默认值开始。对于流体，减少ML_LMAX2&#x3D;2和ML_RCUT2&#x3D;4可能会导致更好的拟合结果。</p>
<h2 id="准确性"><a href="#准确性" class="headerlink" title="准确性"></a>准确性</h2><p>力场的可实现准确性取决于许多因素，例如物种、温度、压力、电子收敛、机器学习方法等。在我们实现的核岭回归中，随着本地参考构型数量的增加，力场的准确性也会提高。这种增加并非是线性的，同时计算成本也会线性增加。在生成机器学习力场时，总是存在准确性和效率之间的权衡。</p>
<p>以下是一些经验指南：</p>
<p>对于给定的结构，随着温度和压力的增加，误差也会增加。因此，力场不应该在与目标条件相距太远的条件下进行训练。例如，对于在 300 K 下的生产运行，最好是在这个温度以上（450-500 K）学习，以捕获可能在生产运行中出现的更多结构，但是在比如 1000 K 下学习同一相位并不有益，因为这可能会降低力场的准确性。<br>液体通常需要更多的训练结构和本地参考构型才能达到与固体类似的准确性。要达到大约 30 meV&#x2F;埃的误差，液体通常需要 2000-4000 个本地参考构型，而对于简单的周期体积系统，500-1000 个参考构型可能就足够了。<br>一般来说，能量的拟合误差应该小于 1 meV&#x2F;原子，而在 300-1000 K 之间的温度下，力的误差应该在 30-100 meV&#x2F;埃之间。略高于这些值的错误可能是可以接受的，但是这些计算应该仔细检查准确性。</p>
<p>准确的力场:<br>控制学习和采样的默认参数被选择为在准确性和效率之间提供良好的权衡。特别是，ML_EPS_LOW 的默认设置倾向于在稀疏化步骤中去除本地参考构型，从而限制了准确性。然而，进一步降低 ML_EPS_LOW 至 1.0E-11 以下的值并不会提高准确性，因为在贝叶斯回归中求解的正则化正规方程的条件数大约与在稀疏化过程中考虑的 Gram 矩阵的条件数的平方成正比（见此处）。因此，如果 Gram 矩阵的条件数为 1E9，那么正规方程的条件数就为 1E18，这意味着在解正规方程时会发生精度损失。</p>
<p>要获得保留更多本地参考构型的高度准确的力场，必须使用以下两步过程：</p>
<p>首先，进行完全的即时学习：</p>
<p>ML_IALGO_LINREG&#x3D;1; ML_SION1&#x3D;0.3; ML_MRB2&#x3D;12<br>这可以由许多不同的训练步骤组成，包括所有所需的结构。将 ML_MRB1 从 8 增加到 12，并将 ML_SION1 从 0.5 减少到 0.3，可以将 Gram 矩阵的条件数提高约 10 倍，并允许稀疏化步骤保留更多本地参考构型（通常约 2 倍）。当然，这会在一定程度上减慢力场计算的速度。</p>
<p>如果无法进行完全的重新训练，还可以尝试仅增加本地参考计算的数量，就像上面描述的那样，通过使用 ML_MODE&#x3D;SELECT 并选择一个为 ML_CTIFOR 值，以获得令人满意的本地参考构型数量。</p>
<p>其次，使用 ML_MODE&#x3D;REFIT 对力场进行重新调整。</p>
<p>使用 SVD 而不是求解正则化正规方程可以避免问题的平方化，因此设计矩阵的条件数而不是它的平方变得重要。根据我们的经验，使用默认值 ML_SION1&#x3D;0.5 进行 SVD 调整总是会提高力场的准确性。</p>
<h2 id="动态调节参数"><a href="#动态调节参数" class="headerlink" title="动态调节参数"></a>动态调节参数</h2><p>如果选择了太多或太少的训练结构和本地参考配置，可以调整一些动态参数（关于学习和阈值算法的概述，请参考这里）：</p>
<p>ML_CTIFOR：为每个原子的贝叶斯力误差定义学习阈值。在继续运行中，它可以设置为先前运行的ML_CTIFOR的最后一个值。这样可以跳过计算开始时不必要的采样。然而，当从一个结构转移到另一个结构时，此标记应该非常小心设置。ML_CTIFOR取决于物种和系统。例如，低对称结构，比如液体，通常比同一化合物的高对称固体具有更高的误差。如果首先学习液体，并且使用液体的最后一个ML_CTIFOR用于对应的固体，则此ML_CTIFOR对于固体而言太大，所有预测的错误都将低于阈值。因此，在固体上不会进行任何学习。在这种情况下，最好从ML_CTIFOR的默认值开始。ML_CTIFOR的典型可达值约为0.02在300-500 K左右，约为0.06在1000-2000 K左右，因此取决于温度，也取决于系统。</p>
<p>ML_CX：它涉及阈值的计算，ML_CTIFOR &#x3D;（历史上存储的贝叶斯错误的平均值）*（1.0 + ML_CX）。此标记影响选择训练结构和本地参考配置的频率。ML_CX的正值导致更少的采样（因此更少的自始至终的计算），负值导致相反的结果。ML_CX的典型值介于-0.3和0之间。对于使用加热的训练运行，默认通常会导致平衡良好的机器学习力场。当在固定温度下进行训练时，通常希望将ML_CX减小至-0.1，增加第一性原理计算的数量，从而增加训练集的规模（默认值可能导致训练数据太少）。</p>
<p>ML_MHIS：设置用于更新ML_CTIFOR的先前贝叶斯错误数量（从ML_ICRITERIA的默认学习步骤）。如果在初始阶段之后，阈值更新之间出现贝叶斯错误的强烈变化，并且每次更新后阈值也会发生强烈变化，则可以降低此标记的默认值10。</p>
<p>ML_SCLC_CTIFOR：仅在选择本地参考配置时缩放ML_CTIFOR。与ML_CX相比，此标记不会影响采样的频率（自始至终的计算）。较小的值意味着选择更多的本地参考配置；较大的值意味着选择更少的本地参考配置。</p>
<p>ML_EPS_LOW：控制选定的贝叶斯错误估计本地参考配置数量的稀疏化。增加ML_EPS_LOW会增加删除的本地参考配置数量，减少则相反。此标记也不会影响学习频率，因为在选定新结构的本地参考配置之后才执行稀疏化。我们不建议将阈值增加到大于1E-7的值。在该值以下，此标记可以很好地控制本地参考配置的数量，但是对于多组分系统，稀疏化算法往往会导致不同物种的本地参考配置数量出现明显不平衡。</p>
<p>ML_LBASIS_DISCARD：控制在任何物种的最大本地参考配置数量ML_MB达到之后是否继续计算。先前的默认行为是ML_LBASIS_DISCARD&#x3D;.FALSE.：当任何物种的本地参考配置数量达到ML_MB时，计算将停止并要求增加ML_MB。在多组分系统中，对于一种物种，稀疏表示很快超过ML_MB，而其他物种的本地参考配置尚未被确定地描述，并且仍远低于限制ML_MB。因此，目前的默认值是ML_LBASIS_DISCARD&#x3D;.TRUE.：在这种情况下，代码在达到阈值时处置本地参考配置。它是根据物种而不同的。</p>
<h2 id="实时学习监控"><a href="#实时学习监控" class="headerlink" title="实时学习监控"></a>实时学习监控</h2><p>你的学习监控可以分为两部分：</p>
<h3 id="分子动力学-x2F-系综相关数量："><a href="#分子动力学-x2F-系综相关数量：" class="headerlink" title="分子动力学&#x2F;系综相关数量："></a>分子动力学&#x2F;系综相关数量：</h3><p>通过视觉方式监测结构。这意味着查看带有结构&#x2F;轨迹查看器的CONTCAR或XDATCAR文件。很多时候，当出现问题时，可以立即追溯到不希望或非物理形变。</p>
<p>OUTCAR、XDATCAR和CONTCAR文件中的体积和晶格参数。确认平均体积保持在期望范围内是很重要的。在恒温恒压运行中，如果平均体积随时间发生强烈变化，表明可能存在相变或未适当平衡系统。特别麻烦的是在单个VASP运行期间发生强烈的剪切：由于VASP保持平面波基组固定并最初使用球形截断球，截断球实际上变成一个椭球。也就是说，截断球在某些倒易格子方向上变小。在单次运行中，晶格矢量的变化超过10%必须避免。相关的数据文件（ML_AB）不适合继续训练（将你的计算分批进行）。</p>
<p>OUTCAR和OSZICAR文件中的温度和压力。计算开始时温度和压力与期望值存在较大偏差，表明起始位置未适当平衡。如果期望特征发生强烈振荡，可以使用块平均值来监测它们（有关块平均值的更多信息，请参见下文中的“应用”）。<br>成对关联函数（PCDAT）。</p>
<h3 id="ML-LOGFILE文件中的机器学习特定量："><a href="#ML-LOGFILE文件中的机器学习特定量：" class="headerlink" title="ML_LOGFILE文件中的机器学习特定量："></a>ML_LOGFILE文件中的机器学习特定量：</h3><p>每核所需内存估计。这在分配之前写在ML_LOGFILE的开头（见这里）。非常重要的一点是，如果所需内存超过物理可用内存，计算不会立即在静态数组分配时崩溃，因为许多系统使用懒惰分配。在内存不足之前，计算可能运行很长时间。因此，必须在启动后始终检查内存估计。<br>状态：显示每个分子动力学步骤发生的情况。当状态为“学习&#x2F;关键”时，状态“力场”被更新。从一开始就经常监测这个变量（在ML_LOGFILE.1中搜索“状态”ML_LOGFILE.1|grep -E ‘learning|critical’|grep -v“#”）。如果经过50次迭代后计算仍然在每步更新“力场”，这表明计算中有严重问题。如果计算在几步后停止学习并且以后仅进行力场步骤，那么将不会得到有用的力场。在理想的学习中，力场更新频率一开始很高，然后持续降低，直到算法只是间歇性地学习。需要注意的是，由于贝叶斯错误的近似预测，学习频率永远不会降到零。如果在分子动力学运行的后期阶段学习频率突然增加，通常表示正在探索当前力场未知的新相空间。但在训练结束时学习步骤的突然增加也可能表明系统发生了不希望的变形，这需要仔细研究。</p>
<p>LCONF：每个学习步骤的本地配置数。</p>
<p>ERR：关于从头计算数据对于所有训练结构到当前分子动力学步骤的预测能量、力和应力<br>${\displaystyle \Delta O&#x3D;{\sqrt {\sum \limits <em>{N}(O</em>{\mathrm {AI} }-O_{\mathrm {MLFF} })^{2}&#x2F;N}}}$. 这里<br>N遍历所有训练结构的能量，逐元素遍历每个训练结构，乘以每个结构中每个原子的个数乘以三个笛卡尔方向的力，逐元素遍历每个训练结构，乘以张量的九个成分的每个张量组分力。</p>
<p>BEEF：能量、力和应力的估计贝叶斯错误（列3-5）。力的最大贝叶斯误差ML_CTIFOR的当前阈值在列6上。</p>
<p>THRUPD：ML_CTIFOR的更新。</p>
<p>THRHIST：用于ML_CTIFOR的贝叶斯错误历史。</p>
<p>力的真实误差（ERR的第4列）、贝叶斯误差（BEEF的第4列）和阈值（BEEF的第6列）的典型演变如下所示：</p>
<h2 id="ICONST"><a href="#ICONST" class="headerlink" title="ICONST"></a>ICONST</h2><p>在ICONST文件中定义了几何参数，然后在分子动力学模拟中进行监控或控制。例如，两个位置之间的距离可以通过偏差势的作用来约束或影响。最后，VASP将输出写入REPORT文件。</p>
<h3 id="In-case-of-primitive-coordinates"><a href="#In-case-of-primitive-coordinates" class="headerlink" title="In case of primitive coordinates"></a>In case of primitive coordinates</h3><p>flag &#x3D; R: interatomic distance between atoms item(1) and item(2).</p>
<p>flag &#x3D; A: angle defined by atoms item(1), item(2) and item(3) (with the atom item(2) being the apex).</p>
<p>flag &#x3D; T: torsional angle defined by atoms item(1), item(2), item(3) and item(4).</p>
<p>flag &#x3D; M: distance between atom item(1) and the center of bond between atoms item(2) and item(3).</p>
<p>flag &#x3D; B: distance between the center of bond between atoms item(1) and item(2) and the center of bond between atoms item(3) and item(4)</p>
<p>flag &#x3D; P: ratio of length of the bond between atoms item(1) and item(2) and the length of the bond between atoms item(3) and item(4)</p>
<p>flag &#x3D; W: function<br>${\displaystyle {\frac {1-\left(R&#x2F;c\right)^{M}}{1-\left(R&#x2F;c\right)^{N}}}}$ wit with<br>𝑅 being the bond length (in Å) between the atoms item(1) and item(2),<br>𝑐 is the reference bond length specified as item(3), and the exponents 𝑀 and 𝑁 are defined as item(4) and item(5), respectively.</p>
<p>flag &#x3D; X, Y, and Z: fractional (direct) coordinates linked with the lattice vectors<br>𝑎, 𝑏, and 𝑐.</p>
<p>flag &#x3D; cX, cY, and cZ: Cartesian coordinates<br>𝑥, 𝑦, and 𝑧.</p>
<p>flag &#x3D; LR: length of lattice vector item(1)</p>
<p>flag &#x3D; LA: angle between lattice vectors item(1) and item(2)</p>
<p>flag &#x3D; LV: cell volume (no item(i) is defined in this case)</p>
<h3 id="complex-coordinates"><a href="#complex-coordinates" class="headerlink" title="complex coordinates"></a>complex coordinates</h3><p>flag &#x3D; S: simple linear combination of primitive coordinates, i.e., $\left(\xi &#x3D;\sum <em>{ {i&#x3D;1} }^{ {M} }c</em>{i},q_{i}\right)$.</p>
<p>flag &#x3D; C: norm of the vector of primitive coordinates, which reads<br>$\left(\xi &#x3D;{\sqrt  {\sum <em>{ {i&#x3D;1} }^{ {M} },(c</em>{i},q_{i})^{2}}}\right)$.</p>
<p>flag &#x3D; D: coordination number[1], i.e.,<br>$\left(\xi &#x3D;\sum <em>{ {i&#x3D;1} }^{ {M} }{\frac  {1-\left(q</em>{ {i} }&#x2F;c_{ {i} }\right)^{9} }{1-\left(q_{ {i} }&#x2F;c_{ {i} }\right)^{ {14} }}}\right)$.</p>
<p>flag &#x3D; IS: path-based coordinate[2] measuring progress along discretized path represented by<br>${\displaystyle {\tilde {q}}(j)}$ predefined in file IRCCAR, i.e.,<br>${\displaystyle \xi &#x3D;{\frac {1}{N-1}}{\frac {\sum <em>{i&#x3D;1}^{N}(i-1)\exp \left(-\sum <em>{j&#x3D;1}^{M}c</em>{j}(q</em>{j}-{\tilde {q}}<em>{j}(i))^{2}\right)}{\sum <em>{i&#x3D;1}^{N}\exp \left(-\sum <em>{j&#x3D;1}^{M}c</em>{j}(q</em>{j}-{\tilde {q}}</em>{j}(i))^{2}\right)}}}$</p>
<p>flag &#x3D; IZ: path-based coordinate[2] measuring orthogonal distance from the path ${\displaystyle {\tilde {q}}}$ predefined in file IRCCAR, i.e.,<br>${\displaystyle \xi &#x3D;-{\frac {1}{c_{1}}}\log \sum _{i&#x3D;1}^{N}\exp \left(-\sum <em>{j&#x3D;1}^{M}c</em>{j}(q-{\tilde {q}}(i))^{2}\right)}$ with 𝑁 as defined above The complex coordinates are functions defined in the space spanned by the primitive coordinates.</p>
<p>Mind: 所有复杂坐标都必须在最后一个基本坐标之后定义。一旦定义了复杂坐标，基本坐标只是它们定义的基础，它们的状态就会被忽略。</p>
<h3 id="Settings-for-item-i"><a href="#Settings-for-item-i" class="headerlink" title="Settings for item(i)"></a>Settings for item(i)</h3><p>它取决于标志的设置。在大多数情况下，item(i)是一个整数，指定原子的位置或晶格矢量在POSCAR文件中的位置。请注意，需要两个原子来定义键长，需要三个原子来定义键角等等。在标志W的特殊情况下，还通过item(i)定义一些额外的参数，即参考键长（通常是一个浮点数）和用于定义的指数（整数）。请查看相应标志的描述信息。</p>
<h3 id="Settings-for-status"><a href="#Settings-for-status" class="headerlink" title="Settings for status"></a>Settings for status</h3><p>status &#x3D; 0: the coordinate is constrained.</p>
<p>status &#x3D; 4: the coordinate is affected by a Fermi-type step function</p>
<p>status &#x3D; 5: the coordinate defines the collective variable in metadynamics</p>
<p>status &#x3D; 7: the coordinate is monitored</p>
<p>status &#x3D; 8: the coordinate is affected by a harmonic potential</p>
<h3 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R 1 6 0</span><br><span class="line">R 1 5 0</span><br><span class="line">S 1 -1 0</span><br></pre></td></tr></table></figure>
<p>第一行代表原子1和6的距离，末尾0代表状态为约束。同样第二行代表原子1和5的距离，状态约束。</p>
<p>第三行代表复合坐标调节，S代表原始坐标的简单结合；后面代表两个键长的差值。</p>
<p>无论复合坐标调节何时定义都要以原始坐标为基础，因此尽管键长状态是0，但它受第三行控制。假如要固定第一个键长和复合坐标调节，应该设置为例2。</p>
<h3 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R 1 6 0</span><br><span class="line">R 1 5 0</span><br><span class="line">S 1 -1 0</span><br><span class="line">S 1 0 0</span><br></pre></td></tr></table></figure>
<p>如果1-6距离是1.1 Å，1-5是1.5 Å，可以用两种方式调节。</p>
<p>（1） 用复杂调节参数D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R 1 6 0</span><br><span class="line">R 1 5 0</span><br><span class="line">D 1.1 1.5 0</span><br></pre></td></tr></table></figure>
<p>在这种情况下，出现在定义 D 的公式的分子和分母中的指数分别固定为值 9 和 14。</p>
<p>(2) 使用 W 原始和 S 复杂坐标来固定相同的配位数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">W 1 6 1.1 9 14 0</span><br><span class="line">W 1 5 1.5 9 14 0</span><br><span class="line">S 1 1 0</span><br></pre></td></tr></table></figure>
<p>这种格式的优势在于，可以为每个距离单独设置系数 M 和 N (请参阅上面 W 的定义)。此外，这种格式还允许简单直观地定义多个配位数的按比例总和和&#x2F;或差异，只需通过与 S 相关联的系数的合适选择即可，这些系数可以是正、负或零。</p>
<h3 id="例子3：约束体积或形状"><a href="#例子3：约束体积或形状" class="headerlink" title="例子3：约束体积或形状"></a>例子3：约束体积或形状</h3><ol>
<li>固定体积变形状<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LV 0</span><br></pre></td></tr></table></figure></li>
<li>固定基矢角度变长度<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LA 1 2 0</span><br><span class="line">LA 1 3 0</span><br><span class="line">LA 2 3 0</span><br></pre></td></tr></table></figure></li>
<li>固定形状立方晶系变体积</li>
</ol>
<p>Note that the S type constraints involving the lengths of the lattice vectors (𝑎𝑖−𝑎𝑗&#x3D;0) are chosen so as to preserve ratios 𝑎1:𝑎2:𝑎3&#x3D;1:1:1, as required by the cubic shape.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LA 1 2 0</span><br><span class="line">LA 1 3 0</span><br><span class="line">LA 2 3 0</span><br><span class="line">LR 1 0</span><br><span class="line">LR 2 0</span><br><span class="line">LR 3 0</span><br><span class="line">S  1  0  0  0  0  0 0</span><br><span class="line">S  0  1  0  0  0  0 0</span><br><span class="line">S  0  0  1  0  0  0 0</span><br><span class="line">S  0  0  0  1 -1  0 0</span><br><span class="line">S  0  0  0  1  0 -1 0</span><br><span class="line">S  0  0  0  0  1 -1 0</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>固定单斜晶系变体积</li>
</ol>
<p>Here, in order to fix ratios between the lengths of the lattice vectors (𝑎1:𝑎2:𝑎3), we define the constraints of the form 𝑐𝑖∗𝑎𝑖+𝑐𝑗∗𝑎𝑗&#x3D;0. For instance, if the cell vectors are such that the relative proportions of their lengths are 𝑎1:𝑎2:𝑎3&#x3D;1:1.5:2, the following ICONST can be used:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LA 1 2 0</span><br><span class="line">LA 1 3 0</span><br><span class="line">LA 2 3 0</span><br><span class="line">LR 1 0</span><br><span class="line">LR 2 0</span><br><span class="line">LR 3 0</span><br><span class="line">S  1  0  0  0      0    0 0</span><br><span class="line">S  0  1  0  0      0    0 0</span><br><span class="line">S  0  0  1  0      0    0 0</span><br><span class="line">S  0  0  0  1.5 -1.0  0.0 0</span><br><span class="line">S  0  0  0  2.0  0.0 -1.0 0</span><br><span class="line">S  0  0  0  0.0  4.0 -3.0 0</span><br></pre></td></tr></table></figure>

<h3 id="REPORT"><a href="#REPORT" class="headerlink" title="REPORT"></a>REPORT</h3><p>输出文件REPORT包含有关MD运行的信息，例如模拟中使用的参数列表，受控几何参数的值，与热浴（Andersen热浴）的碰撞次数，计算自由能梯度所需的数量等。</p>
<h3 id="监控几何参数"><a href="#监控几何参数" class="headerlink" title="监控几何参数"></a>监控几何参数</h3><p>仅适用NVT系综。在ICONST文件中，状态为7的几何参数在MD模拟期间进行监控。相应数值在每个MD步骤之后的Monit_coord字符串后的行中写入REPORT文件。</p>
<p>有时，如果所有监控参数的数值大于预定义的上限和&#x2F;或下限，终止模拟是可取的。用户可以通过VALUE_MAX和VALUE_MIN标签设置这些限制。</p>
<p>在MD运行期间监控几何参数：</p>
<ul>
<li>设置标准的MD相关标签：IBRION&#x3D;0，TEBEG，POTIM和NSW</li>
<li>设置MDALGO&#x3D;2，并选择适当的SMASS设置</li>
<li>在ICONST文件中定义几何约束，并将受约束坐标的状态参数设置为7</li>
<li>可选地，通过VALUE_MAX和VALUE_MIN标签分别设置坐标的上限和&#x2F;或下限。</li>
</ul>
<h3 id="Metadynamics"><a href="#Metadynamics" class="headerlink" title="Metadynamics"></a>Metadynamics</h3><p>仅适用NVT系综。<br>要运行带有Andersen热浴的元动力学，需要做到：</p>
<ul>
<li>设置标准的分子动力学相关标签：IBRION&#x3D;0，TEBEG，POTIM和NSW。</li>
<li>设置MDALGO&#x3D;1（或在VASP 5.x中为MDALGO&#x3D;11），并选择适当的ANDERSEN_PROB设置。</li>
<li>设置参数HILLS_H，HILLS_W和HILLS_BIN。</li>
<li>在ICONST文件中定义集体变量，并将集体变量的STATUS参数设置为5。</li>
<li>如果需要，在PENALTYPOT文件中定义偏置势。</li>
<li>实际的时间相关偏置势被写入HILLSPOT文件，在添加新的高斯函数后进行更新。在模拟开始时，VASP尝试从PENALTYPOT文件中读取初始偏置势。要继续进行元动力学运行，将HILLSPOT复制到PENALTYPOT中。每个MD步骤的所有集体变量的值都列在REPORT文件中，在字符串“Metadynamics”之后检查这些行。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/09/18-47-21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keke Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lightchaser">
      <meta itemprop="description" content="一个小学生的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Lightchaser">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/09/18-47-21/" class="post-title-link" itemprop="url">5.1 分子动力学1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-09 18:47:21" itemprop="dateCreated datePublished" datetime="2023-09-09T18:47:21+08:00">2023-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-04 21:41:21" itemprop="dateModified" datetime="2024-06-04T21:41:21+08:00">2024-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DFT%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">DFT学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>从头算分子动力学（ab initio molecular dYnamics, AIMD），又称为第一性原理分子动力学，为研究电子与原子核相互耦合系统的力学进动过程的理论方法。AIMD是在早期经验力场分子动力学基础上发展起来的理论方法。经验力场分子动力学中，针对原子核之间相互作用，均采用经验性的力场，这种力场往往是对相互作用，基于这些相互作用势场好处是计算量小，能够模拟的体系较大，模拟时长也比较长，统计数据也较多。</p>
<p>最初的AIMD为理想的Born-Oppenheimer分子动力学（BOMD），该理论将原子核-电子耦合体系的运动问题拆分为电子结构和分子动力学两部分，用密度泛函（DFT）等方法对特定原子核构型下的电子结构进行计算，得到K-S轨道及能量，在此基础上得到理想B-O势能面上原子核感受的势能和力，进而用经典力学来考察原子核在Born-Oppenheimer势能面上的运动。</p>
<p>为解决理想的BOMD所遇到计算瓶颈的问题，Reberto Car和Michele Parrinello于1985年提出了一种近似的BOMD方法- Car-Parrinello MD（简称CPMD）（Car, R., &amp; Parrinello, M，1985）。该方法首次使用了一个扩展的Lagrangian量来描述电子-原子核耦合体系的动力学问题，Lagrangian量引入了虚拟电子质量u，基于这个Lagrangian量可给出运动方程，通过原子核的经典运动来近似更新电子波函数，而不再需要每一步通过矩阵对角化对电子结构进行SCF计算，简化了电子结构计算，大幅降低了计算成本，使得AIMD在技术上首次具备了可操作性，开创了近几十年AIMD模拟的时代。</p>
<h1 id="第一性原理分子动力学（AIMD）结果分析"><a href="#第一性原理分子动力学（AIMD）结果分析" class="headerlink" title="第一性原理分子动力学（AIMD）结果分析"></a>第一性原理分子动力学（AIMD）结果分析</h1><p>与经典分子动力学不同，第一性原理分子动力学不需要提供力场参数，只需要提供原子初始结构，就能根据电子波函数正交化产生的虚拟力，求解牛顿运动方程。在运行优化任务时，VASP生成的XDATCAR记录的是优化步骤的离子构型；在运行AIMD任务时，记录的就是运动轨迹。而现阶段读取XDATCAR轨迹分析性质的后处理软件并不多，能读取的兼容性也并不好。__VASPKIT0.72版本之后支持了将XDATCAR转换成通用的多帧PDB文件的功能（504）以便可视化并进行后处理分析__。但是并没有提供后处理分析接口，因此我们开发了一个Python脚本XDATCAR_toolkit.py，除了实现了选择一定范围内的帧数转换成PDB文件的功能，还可以提取分子动力学模拟过程中的能量，温度并做出变化趋势图。这对判断动力学是否平衡很有帮助。另外本脚本预留了接口，可以调用读取每一帧的晶格信息和原子坐标，以便进行后续扩展编程。此脚本需要安装了numpy包的python环境，以及matplotlib包以便于画图。</p>
<p>在得到通用轨迹PDB文件后，就可以利用现用的分子动力学后处理软件进行处理分析，比如VMD，MDtraj，MD Analysis， Pymol等。__本教程将演示通过VMD和MD Analysis软件包分析RDF（径向分布函数）和RMSD（均方根偏差）__，前者可以用来分析结构性质，后者对判断结构是否稳定以及模拟是否平衡很有帮助。</p>
<p>将XDATCAR转换成PDB文件<br>以VASP官网中单个水分子的AIMD模拟为例。模拟的输入文件如下，模拟的步长是0.5fs，模拟步数1000步，模拟时间500fs。脚本和测试例子可以在Github仓库(<a target="_blank" rel="noopener" href="https://github.com/tamaswells/VASP_script/tree/master/XDATCAR_tookit)%E4%B8%8B%E8%BD%BD%E3%80%82">https://github.com/tamaswells/VASP_script/tree/master/XDATCAR_tookit)下载。</a></p>
<p>图1. 模拟的盒子<br>INCAR</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">PREC</span> = <span class="title class_">Normal</span>    ! standard precision </span><br><span class="line"><span class="variable constant_">ENMAX</span> = <span class="number">400</span>      ! cutoff should be set manually</span><br><span class="line"><span class="variable constant_">ISMEAR</span> = <span class="number">0</span> ; <span class="variable constant_">SIGMA</span> = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">ISYM</span> = <span class="number">0</span>         ! strongly recommened <span class="keyword">for</span> <span class="variable constant_">MD</span></span><br><span class="line"><span class="variable constant_">IBRION</span> = <span class="number">0</span>       ! molecular dynamics</span><br><span class="line"><span class="variable constant_">NSW</span> = <span class="number">1000</span>       ! <span class="number">1000</span> steps</span><br><span class="line"><span class="variable constant_">POTIM</span> = <span class="number">0.5</span>      ! timestep <span class="number">0.5</span> fs</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">SMASS</span> = -<span class="number">3</span>       ! <span class="title class_">Nose</span> <span class="title class_">Hoover</span> thermostat</span><br><span class="line"><span class="variable constant_">TEBEG</span> =  <span class="number">2000</span> ; <span class="variable constant_">TEEND</span> = <span class="number">2000</span> ! temperature</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">NBANDS</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>POSCAR</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">H2O</span> _2</span><br><span class="line"><span class="number">0.52918</span>   ! scaling parameter</span><br><span class="line"> <span class="number">12</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">12</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">12</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line">select</span><br><span class="line">cart</span><br><span class="line">      <span class="number">0.00</span>     <span class="number">0.00</span>     <span class="number">0.00</span> T T F</span><br><span class="line">      <span class="number">1.10</span>    -<span class="number">1.43</span>     <span class="number">0.00</span> T T F</span><br><span class="line">      <span class="number">1.10</span>     <span class="number">1.43</span>     <span class="number">0.00</span> T T F</span><br></pre></td></tr></table></figure>
<p>KPOINTS</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Gamma</span>-point only</span><br><span class="line"> <span class="number">1</span>        ! one k-point</span><br><span class="line">rec       ! <span class="keyword">in</span> units <span class="keyword">of</span> the reciprocal lattice vector</span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>  ! <span class="number">3</span> coordinates and weight</span><br></pre></td></tr></table></figure>
<p>模拟完成后将XDATCAR_toolkit.py上传到文件夹中（或者置于环境变量的路径文件夹中并赋予可执行权限即可直接调用命令XDATCAR_toolkit.py运行脚本），在shell环境中运行以下命令:</p>
<p><code>python XDATCAR_toolkit.py -p -t 0.5  --pbc</code><br>即可将XDATCAR的全部帧也就是0~499.5fs的轨迹转化成PDB格式。<strong>其中-p用于开启PDB转换功能，-t 0.5用于指定时间步为0.5fs，–pbc用于获取基于第一帧演变的连续轨迹。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Now reading vasp MD energies and temperature.</span><br><span class="line">Now reading vasp XDATCAR.</span><br><span class="line">Total frames 1000, NpT is False</span><br><span class="line">Finish reading XDATCAR.</span><br><span class="line">Selected time-range:0.0~499.5fs</span><br><span class="line">[debug] Now entering function plotfigure.....</span><br></pre></td></tr></table></figure>
<p>运行完成后，将会在文件夹内生成Temperature.dat，Energy.dat，ENERGY.png和XDATCAR.pdb四个文件，前面两个分别为温度和能量随着模拟时间的的变化数据，第三个是使用matplotlib绘制的趋势图（如下图），最后一个是转换得到的轨迹PDB文件，可以用于可视化轨迹，亦可用于后处理分析。</p>
<p>-b参数用于指定转换从哪一帧开始，-e参数用于指定转换到哪一帧结束。经刘锦程博士建议，增加一个–pbc的选项，用于处理周期性获取连续的轨迹。当分子穿过盒子边界时，记录真实的位置坐标（尽管它出了边界）而不是从盒子另一边穿入的ghost原子的坐标。这对于分析与时间相关性的量（比如RMSD）很有帮助。所谓连续指的是后面的轨迹都是从第一帧演变得到的真实坐标，但是并不能保证第一帧的分子是完整的，由于周期性的缘故，第一帧内摆放的分子可能分处于盒子两侧。李继存老师有篇博文(<a target="_blank" rel="noopener" href="http://jerkwin.github.io/2016/05/31/GROMACS%E8%BD%A8%E8%BF%B9%E5%91%A8%E6%9C%9F%E6%80%A7%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%A4%84%E7%90%86/)%E8%AE%B2%E7%9A%84%E5%BE%88%E6%98%8E%E7%99%BD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E3%80%82%E5%A6%82%E6%9E%9C%E5%8F%91%E7%8E%B0%E7%AC%AC%E4%B8%80%E5%B8%A7%E5%86%85%E5%88%86%E5%AD%90%E4%B8%8D%E5%AE%8C%E6%95%B4%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%B7%BB%E5%8A%A0%60-i">http://jerkwin.github.io/2016/05/31/GROMACS%E8%BD%A8%E8%BF%B9%E5%91%A8%E6%9C%9F%E6%80%A7%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%A4%84%E7%90%86/)讲的很明白，可以参考。如果发现第一帧内分子不完整，可以通过添加`-i</a> 1参数将分子向第一个原子靠近平移以获得完整的分子。如果发现不理想，可以通过调整-i&#96;的参数获得完整的分子。</p>
<p>图2. 温度和系统能量的变化趋势图<br>RDF径向分布函数分析</p>
<p>得到PDB文件后，可以使用VMD，MD Analysis等分子动力学后处理软件进行分析。</p>
<h3 id="使用VMD分析工具分析"><a href="#使用VMD分析工具分析" class="headerlink" title="使用VMD分析工具分析"></a>使用VMD分析工具分析</h3><p>打开VMD，将PDB文件拖入显示窗口，在主菜单VMD Main中选择</p>
<p>Extensions-Analysis-Radial Pair Distribution Function g(r)，选择分析H(type H)在O(type O)周围的概率分布。值得注意的是分析RDF时,横坐标也就是max r不能超过盒子最小边长的一半，也就是得满足最小映像约定。如图4所示，在计算RDF时，如果max r的取值大于盒子最小边长的一半，就有可能重复算到一个粒子和它的映像粒子，这使得程序的周期性判断失准。将生成的dat文件的第一列和第二列作图即可得到RDF图。</p>
<p>图3. VMD中计算RDF</p>
<p>图4. 最小映像约定示意图</p>
<h3 id="使用-MD-Analysis分析-RDF"><a href="#使用-MD-Analysis分析-RDF" class="headerlink" title="使用 MD Analysis分析 RDF"></a>使用 MD Analysis分析 RDF</h3><p>MD Analysis是一个成熟的分子动力学后处理软件，使用Python编写，开源。其教程不仅步骤详细还会给出背景理论知识。可以通过conda或者pip工具在线安装。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels conda-forge</span><br><span class="line">conda install mdanalysis</span><br><span class="line">#or</span><br><span class="line">pip install --upgrade MDAnalysis</span><br></pre></td></tr></table></figure>

<p>RDF分析的介绍和使用方法在网页(<a target="_blank" rel="noopener" href="https://www.mdanalysis.org/docs/documentation_pages/analysis/rdf.html#radial-distribution-functions-mdanalysis-analysis-rdf)%E4%B8%8A%E6%9F%A5%E7%9C%8B%E3%80%82%E4%BD%BF%E7%94%A8%E4%BB%A5%E4%B8%8B%E7%9A%84%E8%84%9A%E6%9C%AC%E5%BE%97%E5%88%B0%E5%9C%A8O%E5%8E%9F%E5%AD%90%E5%91%A8%E5%9B%B4%E6%89%BE%E5%88%B0H%E5%8E%9F%E5%AD%90%E7%9A%84%E6%A6%82%E7%8E%87%EF%BC%8C%E5%B9%B6%E8%B0%83%E7%94%A8%60matplotlib%60%E7%BB%98%E5%88%B6RDF%E5%9B%BE%E3%80%82%E5%9C%A81.0">https://www.mdanalysis.org/docs/documentation_pages/analysis/rdf.html#radial-distribution-functions-mdanalysis-analysis-rdf)上查看。使用以下的脚本得到在O原子周围找到H原子的概率，并调用`matplotlib`绘制RDF图。在1.0</a> Å<br> 处出现一个尖峰，也就是对应了O-H键的平衡键长（0.96$Å$）。</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MDAnalysis</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MDAnalysis</span>.<span class="property">analysis</span>.<span class="property">rdf</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.<span class="property">pyplot</span> <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">u = <span class="title class_">MDAnalysis</span>.<span class="title class_">Universe</span>(<span class="string">&#x27;XDATCAR.pdb&#x27;</span>, permissive=<span class="title class_">True</span>)</span><br><span class="line">g1= u.<span class="title function_">select_atoms</span>(<span class="string">&#x27;type O&#x27;</span>)</span><br><span class="line">g2= u.<span class="title function_">select_atoms</span>(<span class="string">&#x27;type H&#x27;</span>)</span><br><span class="line">rdf = <span class="title class_">MDAnalysis</span>.<span class="property">analysis</span>.<span class="property">rdf</span>.<span class="title class_">InterRDF</span>(g1,g2,nbins=<span class="number">75</span>, range=(<span class="number">0.0</span>, <span class="title function_">min</span>(u.<span class="property">dimensions</span>[:<span class="number">3</span>])/<span class="number">2.0</span>))</span><br><span class="line">           </span><br><span class="line">rdf.<span class="title function_">run</span>()</span><br><span class="line"></span><br><span class="line">fig = plt.<span class="title function_">figure</span>(figsize=(<span class="number">5</span>,<span class="number">4</span>))</span><br><span class="line">ax = fig.<span class="title function_">add_subplot</span>(<span class="number">111</span>)</span><br><span class="line">ax.<span class="title function_">plot</span>(rdf.<span class="property">bins</span>, rdf.<span class="property">rdf</span>, <span class="string">&#x27;k-&#x27;</span>,  label=<span class="string">&quot;rdf&quot;</span>)</span><br><span class="line"></span><br><span class="line">ax.<span class="title function_">legend</span>(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">ax.<span class="title function_">set_xlabel</span>(r<span class="string">&quot;Distance ($\AA$)&quot;</span>)</span><br><span class="line">ax.<span class="title function_">set_ylabel</span>(r<span class="string">&quot;RDF&quot;</span>)</span><br><span class="line">fig.<span class="title function_">savefig</span>(<span class="string">&quot;RDF_all.png&quot;</span>)</span><br><span class="line">#plt.<span class="title function_">show</span>()</span><br></pre></td></tr></table></figure>

<p>图5. RDF_O_H<br>RMSD均方根偏差分析</p>
<h3 id="VMD分析RMSD"><a href="#VMD分析RMSD" class="headerlink" title="VMD分析RMSD"></a>VMD分析RMSD</h3><p>确保使用了-pbc参数以获取连续的轨迹，将生成的XDATCAR.pdb文件拖入显示窗口。如图6右所示，第一帧内水的三个原子不在同一个镜像内，分子不完整。在进行RMSD分析时，尽管轨迹是连续的，但是在对齐分子时就会出现问题。因此在本例中需要选择第一个原子作为中心将分子平移完整，在图6左中，分子已经在同一个镜像中了。</p>
<p><code>python XDATCAR_toolkit.py -p -t 0.5  --pbc -i 1</code></p>
<p>图6. 完整和不完整的水分子<br>将重新生成的PDB文件拖入显示窗口，在主菜单VMD Main中选择Extensions-Analysis-Analysis-RMSD Trajectory Tool，在计算RMSD前必须先做Align（对齐），这会使得每一帧结构进行平移、旋转来与参考帧的结构尽可能贴近，从而使得RMSD最小化。刘锦程提到研究生物法分子的RMSD时需要对齐操作，而研究小分子时不需要对齐分子。</p>
<p>图7. VMD中计算RMSD</p>
<p>把左上角文本框里的默认的Protein改成all（代表所有原子都纳入考虑），然后把noh复选框的勾去掉（否则将忽略氢原子）。然后点右上角的ALIGN按钮，此时所有帧的结构就已经对齐了。本例中演示以模拟的第一帧为参考，分析氧原子位置的均方根偏差。因此在Reference mol那里选top作为参考结构，左上角文本框由all改为type O（代表计算O原子的RMSD），然后勾上Plot复选框，最后点击RMSD按钮即可得到O原子的RMSD图。在File菜单栏可以选择导出dat数据。</p>
<p>图8. VMD中未对齐轨迹计算的RMSD</p>
<p>图9. VMD中对齐了轨迹后计算的RMSD</p>
<h3 id="使用-MD-Analysis分析-RMSD"><a href="#使用-MD-Analysis分析-RMSD" class="headerlink" title="使用 MD Analysis分析 RMSD"></a>使用 MD Analysis分析 RMSD</h3><p>RMSD分析的介绍和使用方法在网页（<a target="_blank" rel="noopener" href="https://www.mdanalysis.org/docs/documentation_pages/analysis/rms.html?highlight=average%EF%BC%89%E4%B8%8A%E6%9F%A5%E7%9C%8B%E3%80%82">https://www.mdanalysis.org/docs/documentation_pages/analysis/rms.html?highlight=average）上查看。</a></p>
<p>使用以下的脚本可以分别得到所有原子，氢原子，氧原子的RMSD，并调用<code>matplotlib</code>绘制RMSD图。网页中有一段话（Note If you use trajectory data from simulations performed under periodic boundary conditions then you must make your molecules whole before performing RMSD calculations so that the centers of mass of the selected and reference structure are properly superimposed.）也就是在计算RMSD的时候选择的分子必须是完整的，不能分处于盒子的两边。这与我们之前的描述是一致的。MD Analysis默认对齐了分子。</p>
<p>使用以下脚本可以绘制对齐了轨迹后所有原子，氧原子和氢原子的RMSD。</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MDAnalysis</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MDAnalysis</span>.<span class="property">analysis</span>.<span class="property">rms</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.<span class="property">pyplot</span> <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">u = <span class="title class_">MDAnalysis</span>.<span class="title class_">Universe</span>(<span class="string">&#x27;XDATCAR.pdb&#x27;</span>, permissive=<span class="title class_">True</span>)</span><br><span class="line">ref = <span class="title class_">MDAnalysis</span>.<span class="title class_">Universe</span>(<span class="string">&#x27;XDATCAR.pdb&#x27;</span>, permissive=<span class="title class_">True</span>)     # reference (<span class="keyword">with</span> the <span class="keyword">default</span> ref_frame=<span class="number">0</span>)</span><br><span class="line">ref.<span class="property">trajectory</span>[<span class="number">0</span>] #use first frame <span class="keyword">as</span> reference</span><br><span class="line">R = <span class="title class_">MDAnalysis</span>.<span class="property">analysis</span>.<span class="property">rms</span>.<span class="title function_">RMSD</span>(u, ref,</span><br><span class="line">           select=<span class="string">&quot;all&quot;</span>,         # superimpose on whole backbone <span class="keyword">of</span> all atoms # align based on all atoms</span><br><span class="line">           groupselections=[<span class="string">&quot;type H&quot;</span>,<span class="string">&quot;type O&quot;</span>],</span><br><span class="line">           filename=<span class="string">&quot;rmsd_all.dat&quot;</span>,center=<span class="title class_">True</span>)#,   # <span class="variable constant_">CORE</span></span><br><span class="line">timestep=<span class="number">0.0005</span>  #<span class="number">0.</span>5fs <span class="keyword">from</span> fs to ps <span class="keyword">as</span> <span class="title class_">Reader</span> has no dt information, set to <span class="number">1.0</span> ps          </span><br><span class="line">R.<span class="title function_">run</span>()</span><br><span class="line">rmsd = R.<span class="property">rmsd</span>.<span class="property">T</span>   # transpose makes it easier <span class="keyword">for</span> plotting</span><br><span class="line">time = rmsd[<span class="number">1</span>]*timestep</span><br><span class="line"></span><br><span class="line">fig = plt.<span class="title function_">figure</span>(figsize=(<span class="number">5</span>,<span class="number">4</span>))</span><br><span class="line">ax = fig.<span class="title function_">add_subplot</span>(<span class="number">111</span>)</span><br><span class="line">ax.<span class="title function_">plot</span>(time, rmsd[<span class="number">2</span>], <span class="string">&#x27;k-&#x27;</span>,  label=<span class="string">&quot;all&quot;</span>)</span><br><span class="line">ax.<span class="title function_">plot</span>(time, rmsd[<span class="number">3</span>], <span class="string">&#x27;r--&#x27;</span>, label=<span class="string">&quot;type H&quot;</span>)</span><br><span class="line">ax.<span class="title function_">plot</span>(time, rmsd[<span class="number">4</span>], <span class="string">&#x27;b--&#x27;</span>, label=<span class="string">&quot;type O&quot;</span>)</span><br><span class="line">ax.<span class="title function_">legend</span>(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">ax.<span class="title function_">set_xlabel</span>(<span class="string">&quot;time (ps)&quot;</span>)</span><br><span class="line">ax.<span class="title function_">set_ylabel</span>(r<span class="string">&quot;RMSD ($\AA$)&quot;</span>)</span><br><span class="line">fig.<span class="title function_">savefig</span>(<span class="string">&quot;rmsd_md_analysis.png&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="应用python工具pymatgen，"><a href="#应用python工具pymatgen，" class="headerlink" title="应用python工具pymatgen，"></a>应用python工具pymatgen，</h1><p>可以直接得到MSD，diffusion，donductivity。</p>
<p><strong>得到XDATCAR后，需要首先配置pymatgen。</strong><br>需要用到conda命令，windows：可以安装anaconda3，通过spyder启动。<br>进入anaconda prompt中启动中断，配置conda environment:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create –name my_pymatgen python</span><br><span class="line">activate my_pymatgen</span><br></pre></td></tr></table></figure>

<p>linux环境下一个比较好的选择是安装miniconda3<br>wget <a target="_blank" rel="noopener" href="https://repo.anaconda.com/minico">https://repo.anaconda.com/minico</a> … -Windows-x86_64.exe</p>
<p><code>bash Miniconda3-latest-linux-x86_64.sh</code><br>如果原来在bashrc中配置了anaconda，则注释掉，重启terminal。<br>与windows下相同，需要设置一个pymatgen环境。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create –name my_pymatgen</span><br><span class="line">source activate my_pymatgen</span><br></pre></td></tr></table></figure>

<p><strong>在my_pymatgen环境下安装 pymatgen：</strong></p>
<p><code>conda install --channel conda-forge pymatgen</code></p>
<p><strong>安装好之后运行建立如下test.py脚本, 可以得到结果：</strong></p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pymatgen.<span class="property">core</span>.<span class="property">trajectory</span> <span class="keyword">import</span> <span class="title class_">Trajectory</span></span><br><span class="line"><span class="keyword">from</span> pymatgen.<span class="property">io</span>.<span class="property">vasp</span>.<span class="property">outputs</span> <span class="keyword">import</span> <span class="title class_">Xdatcar</span></span><br><span class="line"><span class="keyword">from</span> pymatgen <span class="keyword">import</span> <span class="title class_">Structure</span></span><br><span class="line"><span class="keyword">from</span> pymatgen.<span class="property">analysis</span>.<span class="property">diffusion_analyzer</span> <span class="keyword">import</span> <span class="title class_">DiffusionAnalyzer</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"># 这一步是读取 <span class="variable constant_">XDATCAR</span>，得到一系列结构信息</span><br><span class="line">traj = <span class="title class_">Trajectory</span>.<span class="title function_">from_file</span>(<span class="string">&#x27;XDATCAR&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># 这一步是实例化 <span class="title class_">DiffusionAnalyzer</span> 的类</span><br><span class="line"># 并用 from_structures 方法初始化这个类； <span class="number">300</span> 是温度，<span class="number">1</span>是<span class="variable constant_">POTIM</span> 的time step，<span class="number">1000</span>是间隔步数</span><br><span class="line"># 间隔步数（step_skip）不太容易理解，但是根据官方教程(这里具体怎么回事我不太清楚，好像potim*step_skip需要小于<span class="number">1000</span>，<span class="number">1000</span>为<span class="variable constant_">NSW</span>值，这是我没彻底弄清楚的地方):</span><br><span class="line"># dt = timesteps * self.<span class="property">time_step</span> * self.<span class="property">step_skip</span></span><br><span class="line"></span><br><span class="line">diff = <span class="title class_">DiffusionAnalyzer</span>.<span class="title function_">from_structures</span>(traj,<span class="string">&#x27;Li&#x27;</span>,<span class="number">300</span>,<span class="number">1</span>,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"># 可以用内置的 plot_msd 方法画出 <span class="variable constant_">MSD</span> 图像</span><br><span class="line"># 有些终端不能显示图像，这时候可以调用 <span class="title function_">export_msdt</span>() 方法，得到数据后再自己作图</span><br><span class="line">diff.<span class="title function_">plot_msd</span>()</span><br><span class="line">diff.<span class="title function_">export_msdt</span>(<span class="string">&quot;write_msd&quot;</span>)</span><br><span class="line"># 接下来直接得到 离子迁移率， 单位是 mS/cm，diffusity单位是 cm^<span class="number">2</span>/S</span><br><span class="line"></span><br><span class="line">C = diff.<span class="property">conductivity</span></span><br><span class="line">D = diff.<span class="property">diffusivity</span></span><br><span class="line"><span class="keyword">with</span> <span class="title function_">open</span>(<span class="string">&#x27;result.dat&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> <span class="attr">f</span>:</span><br><span class="line">    f.<span class="title function_">write</span>(<span class="string">&#x27;# AIMD result for Li-ion\n&#x27;</span>)</span><br><span class="line">    f.<span class="title function_">write</span>(<span class="string">&#x27;temp\conductivity\diffusivity\n&#x27;</span>)</span><br><span class="line">    f.<span class="title function_">write</span>(<span class="string">&#x27;%d\t%.2f  %.10f&#x27;</span> %(<span class="number">300</span>,C,D))</span><br></pre></td></tr></table></figure>

<p>在1.dat中是msd，conductivity和diffusivity会直接输出在result.dat中，模拟石墨烯表面Li的MD（excessive state）结果diffusivity为2*10-7 cm^2&#x2F;S，我觉得算出diffusivity后自己求conductivity比较好，请问应该怎么求？与文件对比，基本吻合（J. Phys. Chem. Lett. 2010, 1, 1176–1180；<a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/jp910134u%EF%BC%89%E3%80%82">https://pubs.acs.org/doi/10.1021/jp910134u）。</a><br>其它不对的地方，欢迎批评指正。<br>参考：<br><a target="_blank" rel="noopener" href="https://pymatgen.org/installation.html">https://pymatgen.org/installation.html</a><br><a target="_blank" rel="noopener" href="https://www.bigbrosci.com/2020/09/08/A18/">https://www.bigbrosci.com/2020/09/08/A18/</a></p>
<p><strong>VTST的脚本里有一个xdat2xyz.pl，可以直接把XDATCAR转化成movie.xyz文件。xdatcar可以通过ase转换成ms的xtd，也可以转ext-xyz，理论上支持xyz格式的程序也能打开。ase convert xdatcar xxx.xtd（注意会生成隐藏文件xxx.arc，如果要移动xtd，应该要使两个文件在相同的目录）。</strong></p>
<p>事实上，有xtd格式的话，如果你有MS的版权，有些针对xtd格式的分析其实可以直接在MS里面做。arc文件跟着xtd一块拷贝到相同目录。</p>
<h1 id="离子的电导率"><a href="#离子的电导率" class="headerlink" title="离子的电导率"></a>离子的电导率</h1><p>Pymatgen 是 python materials genomics 的缩写，它是一款基于 python 的、开源的、强大的材料分析软件（<a target="_blank" rel="noopener" href="https://pymatgen.org/%EF%BC%89%E3%80%82">https://pymatgen.org/）。</a></p>
<p>Pymatgen 包含一系列能够表示元素（Element）、位点（Site）、分子（Molecule）、和结构（Structure）的类（Class）。它具有为很多计算软件提供前处理和后处理的能力。这些计算软件包括VASP，ABINIT，exciting，FEFF，QCHEM，LAMMPS，ADF，AIIDA，ASE，Gaussian，Lobster，Phonopy，Shengbte，Pwscf，和Zeo++等等。它能实现科研狗的众多后处理需求，包括生成相图（Phase diagram）和布拜图（Pourbaix diagrams），分析态密度和能带等等。</p>
<p>Pymatgen 还提供了很多数据库（Materials Project REST API，Crystallography Open Database，and other external data sources）的接口，方便大家从数据库中查询结构和其他数据。</p>
<p>以下是Pymatgen官网提供的后处理的例子：</p>
<p>Top: (left) Phase and (right) Pourbaix diagram from the Materials API. Bottom left: Calculated bandstructure plot using pymatgen’s parsing and plotting utilities. Bottom right: Arrhenius plot using pymatgen’s DiffusionAnalyzer.</p>
<p><strong>本文就介绍一下如何使用 Pymatgen 的 DiffusionAnalyzer 类去计算锂离子固态电解质中锂离子电导率。</strong></p>
<h3 id="计算离子电导率的理论与公式"><a href="#计算离子电导率的理论与公式" class="headerlink" title="计算离子电导率的理论与公式"></a>计算离子电导率的理论与公式</h3><p>目前，比较准确的计算离子电导率的方法是先用NVT系综第一性原理分子动力学（AIMD，ab initio molecular dynamics）模拟材料中离子在不同温度下的运动，然后计算出离子的平均（average）均方位移（MSD，mean square displacement），再计算出自扩散系数（D<br>，self-diffusion coefficient），最后求得离子在某温度下的电导率（<br>，conductivity）。</p>
<h3 id="如何进行AIMD计算"><a href="#如何进行AIMD计算" class="headerlink" title="如何进行AIMD计算"></a>如何进行AIMD计算</h3><p>AIMD计算通常非常耗时，所以，为了减少计算成本，我们可以适当放宽计算精度。如果用 VASP 进行计算，具体的，大家可以</p>
<p>采用较小的截断能。氧化物用 400 eV，硫化物用 280 eV，硒化物用 270 eV<br>采用Gamma点作为K点设置，并使用gam版本的 VASP 进行计算<br>采用单胞计算，如果材料的单胞包含比较多的原子<br>采用合适的步长，比如2 fs，即 POTIM &#x3D; 2<br>后处理的基本公式<br>一旦AIMD计算完成，大家就可以着手计算离子电导率了。本文首先先介绍以下计算过程中使用的公式，方便有兴趣的同学自己开发脚本。</p>
<h3 id="平均均方位移（average-MSD）可以通过以下公式计算："><a href="#平均均方位移（average-MSD）可以通过以下公式计算：" class="headerlink" title="平均均方位移（average MSD）可以通过以下公式计算："></a>平均均方位移（average MSD）可以通过以下公式计算：</h3><p> 是第<br> 个离子在<br> 时刻的位移。</p>
<p>自扩散系数（<br>）可以通过以下公式计算：</p>
<p> 是离子在材料中的扩散维度（一般地，<br>），<br> 是离子扩散的时间。</p>
<p>最后，离子电导率（<br>）可以这样计算：</p>
<p> 是材料中的离子密度，<br> 是元电荷，<br> 是离子的价态，<br> 是玻尔兹曼常数，<br> 是温度。</p>
<p>电导率计算的例子<br>现在我们通过一个 Li_Sn_S 材料的例子来详细了解一下整个计算和处理的过程。该材料的结构显示如下：</p>
<p>本例中采用单胞做计算，INCAR 设置如下：</p>
<p>[test@ln0%tianhe2 li_sn_s]$ vi INCAR</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ISTART = 0</span><br><span class="line">ICHARG = 2</span><br><span class="line">IBRION = 0</span><br><span class="line">ISIF = 2</span><br><span class="line">NPAR = 8</span><br><span class="line">NSW = 30000</span><br><span class="line">TEBEG = 900 #还要设置成 1500K 等等</span><br><span class="line">PREC = N</span><br><span class="line">POTIM = 2</span><br><span class="line">SMASS = 0.0</span><br><span class="line">NELMIN = 4</span><br><span class="line">LWAVE = F</span><br><span class="line">LCHARG = F</span><br><span class="line">IALGO = 48</span><br><span class="line">LREAL = A</span><br></pre></td></tr></table></figure>
<p>AIMD 计算结束之后会得到 XDATCAR 文件。很多时候，由于超算的时间限制，一个完整的AIMD计算需要提交两三次，从而产生两三个 XDATCAR 文件，这时，我们只要把它们按顺序通过 cat 命令合并在一起就行。例如我们有三个 XDATCAR 文件，分别命名成 XDATCAR01，XDATCAR02，和 XDATCAR03。</p>
<p><code>[test@ln0%tianhe2 li_sn_s]$ cat XDATCAR01 XDATCAR02 XDATCAR03 &gt; XDATCAR </code><br>新得到的XDATCAR文件，注意删掉重复的与晶格信息相关的行，一般续算的次数也不多，在使用上面命令的时候，手动把XDATCAR02, XDATCAR03 中的删除即可。</p>
<p>Pymatgen 大显身手<br>安装pymatgen<br>首先让我们安装 pyamtgen，推荐大家参考官网，使用 anaconda 安装，否则会出现问题。安装好了anaconda之后，不管是 linux 还是 windows, 安装 pyamtgen 的指令是一样的。下面以吕梁天河超算为例：</p>
<p>[test@ln0%tianhe2 li_sn_s]$ conda install –channel conda-forge pymatgen<br>安装完成后，我们可以试着运行 python，导入 Pyamtgen 模块，如果像下面一样没有出错，就是安装成功了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[test@ln0%tianhe2 li_sn_s]$ python</span><br><span class="line">Python 3.7.3 (default, Mar 27 2019, 22:11:17) </span><br><span class="line">[GCC 7.3.0] :: Anaconda, Inc. on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import pymatgen</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure>
<p>查看 DiffusionAnalyzer 的类<br>大家可以通过官方文档（<a target="_blank" rel="noopener" href="https://pymatgen.org/pymatgen.analysis.diffusion_analyzer.html%EF%BC%89%E6%9F%A5%E7%9C%8B%E6%8E%A5%E4%B8%8B%E6%9D%A5%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B1%BB%EF%BC%8C%E7%86%9F%E6%82%89%E4%B8%80%E4%B8%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E7%94%A8%E6%B3%95%E3%80%82">https://pymatgen.org/pymatgen.analysis.diffusion_analyzer.html）查看接下来要使用的类，熟悉一下代码的用法。</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class DiffusionAnalyzer(MSONable):</span><br><span class="line">    def __init__(self, structure, displacements, specie, temperature,</span><br><span class="line">                 time_step, step_skip, smoothed=&quot;max&quot;, min_obs=30,</span><br><span class="line">                 avg_nsteps=1000, lattices=None):</span><br></pre></td></tr></table></figure>
<p>这段代码显示，运行这个类需要一系列的输入信息，包括材料结构（structure），位移（displacements），要研究的离子（specie），温度（temperature）等等。</p>
<p>但是这个类提供了很多方法让大家可以通过读取 XDATCAR 或者 vasprun 文件的方式来实例化，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@classmethod</span><br><span class="line">    def from_structures(cls, structures, specie, temperature,</span><br><span class="line">                        time_step, step_skip, initial_disp=None,</span><br><span class="line">                        initial_structure=None, **kwargs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Convenient constructor that takes in a list of Structure objects to</span><br><span class="line">        perform diffusion analysis.</span><br><span class="line">        Args:</span><br><span class="line">            structures ([Structure]): list of Structure objects (must be</span><br><span class="line">                ordered in sequence of run). E.g., you may have performed</span><br><span class="line">                sequential VASP runs to obtain sufficient statistics.</span><br><span class="line">        ... ...</span><br><span class="line">        &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>好了，废话不多说，直接上代码，开始进行后处理。</p>
<p>代码示例<br>新建一个文件，名字为li_conductivity.py</p>
<p>‘’’<br>分析AIMD结果，计算MSD 和 conductivity<br>‘’’</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">from pymatgen.core.trajectory import Trajectory</span><br><span class="line">from pymatgen.io.vasp.outputs import Xdatcar</span><br><span class="line">from pymatgen import Structure</span><br><span class="line">from pymatgen.analysis.diffusion_analyzer import DiffusionAnalyzer</span><br><span class="line">import numpy as np</span><br><span class="line">import pickle</span><br><span class="line"></span><br><span class="line"># 这一步是读取 XDATCAR，得到一系列结构信息</span><br><span class="line">traj = Trajectory.from_file(&#x27;XDATCAR&#x27;)</span><br><span class="line"></span><br><span class="line"># 这一步是实例化 DiffusionAnalyzer 的类</span><br><span class="line"># 并用 from_structures 方法初始化这个类； 900 是温度，2 是POTIM 的值，1是间隔步数</span><br><span class="line"># 间隔步数（step_skip）不太容易理解，但是根据官方教程:</span><br><span class="line"># dt = timesteps * self.time_step * self.step_skip</span><br><span class="line"></span><br><span class="line">diff = DiffusionAnalyzer.from_structures(traj,&#x27;Li&#x27;,900,2,1)</span><br><span class="line"></span><br><span class="line"># 可以用内置的 plot_msd 方法画出 MSD 图像</span><br><span class="line"># 有些终端不能显示图像，这时候可以调用 export_msdt() 方法，得到数据后再自己作图</span><br><span class="line">diff.plot_msd()</span><br><span class="line"></span><br><span class="line"># 接下来直接得到 离子迁移率， 单位是 mS/cm</span><br><span class="line">C = diff.conductivity</span><br><span class="line"></span><br><span class="line">with open(&#x27;result.dat&#x27;,&#x27;w&#x27;) as f:</span><br><span class="line">    f.write(&#x27;# AIMD result for Li-ion\n&#x27;)</span><br><span class="line">    f.write(&#x27;temp\tconductivity\n&#x27;)</span><br><span class="line">    f.write(&#x27;%d\t%.2f\n&#x27; %(900,C))</span><br></pre></td></tr></table></figure>
<p>在终端运行该文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[test@ln0%tianhe2 li_sn_s]$ python li_conductivity.py</span><br></pre></td></tr></table></figure>
<p>一段时间后就会得到MSD图像和离子电导率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[test@ln0%tianhe2 li_sn_s]$ vi result.dat</span><br><span class="line"></span><br><span class="line"># AIMD result for Li-ion</span><br><span class="line">temp	conductivity</span><br><span class="line">900	884.05</span><br></pre></td></tr></table></figure>
<p>可见，该材料在 900K 时的锂离子电导率为 884.05 mS&#x2F;cm。</p>
<p>例子下载：<br>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1WGzOVJBoe6Ym8mvR1uWanA">https://pan.baidu.com/s/1WGzOVJBoe6Ym8mvR1uWanA</a><br>提取码：jhc5</p>
<p>思考<br>简短几行代码就可以计算出离子电导率，那么如何得出材料在300K下的电导率呢？<br>如何计算离子在材料中的迁移势垒？<br>如何可视化离子在材料中的扩散路径？</p>
<h1 id="如何使用-Pymatgen-可视化离子的迁移概率密度。"><a href="#如何使用-Pymatgen-可视化离子的迁移概率密度。" class="headerlink" title="如何使用 Pymatgen 可视化离子的迁移概率密度。"></a>如何使用 Pymatgen 可视化离子的迁移概率密度。</h1><p>先举个例子，</p>
<p>在“Design principles for solid-state lithium superionic conductors”一文中（Wang et al., Nature Materials 2015, 14 , 1026–1031. ），作者用Ab Initio Molecular Dynamic （AIMD）计算了Li 离子在Li$\mathrm{_1}\mathrm{_2}，<br>\mathrm{_7}<br>\mathrm{_3}<br>\mathrm{_1}$$\mathrm{_1}，<br>\mathrm{_2}，和<br>\mathrm{_4}<br>\mathrm{_4}$ 四种材料中的迁移概率密度（Probability Density），结果如下图所示：</p>
<p>从图中可以看出Li离子在图a所示材料中主要沿c轴方向的通道迁移，而且由于这个通道连通得比较好，Li离子的迁移势垒会比较低（0.22<del>0.25 eV）。<br>Li离子在图b所示的材料的迁移路径形成了一个三维网格，而且由于这个概率密度比图b中的概率密度分布得更加均匀，Li离子的迁移势垒更低（0.18</del>0.19 eV）。<br>图b所示的材料就完全不行了，因为Li离子的概率密度仅分布在特定的位点附近，说明离子不能有效地移动。<br>Li离子在图d所示材料中也存在迁移局域化的行为。<br>作者总结说 “A general principle for the design of Li-ion conductors with low activation energy can be distilled from the above findings: all of the sites within the diffusion network should be energetically close to equivalent, with large channels connecting them.”<br>那么我们如何在自己的计算中画出这样的图呢？Pymatgen 举手说，它可以帮忙！</p>
<p>但是在开始之前，我们要安装Pymatgen的插件：Pymatgen-diffusion（<a target="_blank" rel="noopener" href="https://github.com/materialsvirtuallab/pymatgen-diffusion%EF%BC%89%E3%80%82">https://github.com/materialsvirtuallab/pymatgen-diffusion）。</a></p>
<p>安装 Pymatgen-diffusion<br>推荐大家使用最新版的Anaconda安装Pymatgen及其插件。点击上面的链接，进入官网后，点击最新版本链接，</p>
<p>我们可以下载.zip文件，</p>
<p>下载完成后，大家可以解压这个文件，得到 pymatgen-diffusion-2019.8.18文件夹。</p>
<p>我们把其中的 pymatgen_diffusion 文件夹放到 Anaconda的site-packages文件夹下，路径是 Windows 系统：……\Anaconda\Lib\site-packages；Linux系统：……&#x2F;anaconda3&#x2F;lib&#x2F;pythonx.x&#x2F;site-packages，就算安装好了。</p>
<p>接下来我们可以启动python，导入这个模块，如果不报错就没有问题了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[test@ln0%tianhe2 li_sn_s]$ python</span><br><span class="line">Python 3.8.3 (default, Jul  2 2020, 16:21:59) </span><br><span class="line">[GCC 7.3.0] :: Anaconda, Inc. on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import pymatgen_diffusion</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure>
<p>学习用法<br>我们可以在其github网站上通过例子学习这个模块的用法。</p>
<p>点击打开 probbility_analysis.ipynb 文件。</p>
<p>其内容如下（有所删减）：如果不想看的话可直接查看 开始作图 部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pymatgen.analysis.diffusion_analyzer import DiffusionAnalyzer</span><br><span class="line">from pymatgen_diffusion.aimd.pathway import ProbabilityDensityAnalysis</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">#ProbabilityDensityAnalysis object</span><br><span class="line">filename=&quot;/Users/iekhengchu/repos/pymatgen-diffusion/pymatgen_diffusion/aimd/tests/cNa3PS4_pda.json&quot;</span><br><span class="line"></span><br><span class="line">data = json.load(open(&quot;../pymatgen_diffusion/aimd/tests/cNa3PS4_pda.json&quot;, &quot;r&quot;))</span><br><span class="line">diff_analyzer = DiffusionAnalyzer.from_dict(data) # 初始化DiffusionAnalyzer类</span><br><span class="line"></span><br><span class="line">pda = ProbabilityDensityAnalysis.from_diffusion_analyzer(diff_analyzer, interval=0.5, </span><br><span class="line">                                                         species=(&quot;Na&quot;, &quot;Li&quot;)) #可以指定离子</span><br><span class="line">#Save probability distribution to a CHGCAR-like file</span><br><span class="line">pda.to_chgcar(filename=&quot;CHGCAR_new2.vasp&quot;) #保存概率密度文件</span><br></pre></td></tr></table></figure>
<p>开始作图<br>代码（test.py）如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pymatgen_diffusion.aimd.pathway import ProbabilityDensityAnalysis</span><br><span class="line">from pymatgen.core.trajectory import Trajectory</span><br><span class="line">from pymatgen.io.vasp.outputs import Xdatcar</span><br><span class="line">from pymatgen.analysis.diffusion_analyzer import DiffusionAnalyzer</span><br><span class="line"></span><br><span class="line">traj = Trajectory.from_file(&#x27;XDATCAR&#x27;)</span><br><span class="line">diff = DiffusionAnalyzer.from_structures(traj,&#x27;Li&#x27;,900,2,1)</span><br><span class="line">pda = ProbabilityDensityAnalysis.from_diffusion_analyzer(diff,interval=0.5,species=(&quot;Li&quot;))</span><br><span class="line">pda.to_chgcar(filename=&quot;pda.vasp&quot;) #保存概率密度文件</span><br></pre></td></tr></table></figure>
<p>此处理过程大概耗时8分钟，因机器而异。</p>
<p>在VESTA中可视化</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Keke Liu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
